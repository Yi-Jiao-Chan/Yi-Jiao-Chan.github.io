<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/posts/69e7b86f.html"/>
      <url>/posts/69e7b86f.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>确保一个类<strong>只有一个实例</strong>，且在类的内部<strong>自行进行实例化</strong>并<strong>向整个系统提供这个实例</strong>，是一种<strong>对象创建型模式</strong></p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Singleton：单例类</li></ul><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p><code>Singleton</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="comment">// 双重检验避免同一时刻加锁然后重复初始化</span></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>懒汉式：实现了懒加载，需要用到该实例的时候才进行初始化，但要避免多线程同时初始化，需要进行双重检测和加锁，系统性能受一定影响。</p><p>饿汉式：无需考虑多线程同时访问的问题，调用速度更快，但是由于类加载时就进行了初始化，因此系统资源的利用率稍低，系统加载速度稍慢。</p><ul><li><p>优点：</p><ul><li>提供了<strong>对唯一实例的受控访问</strong></li><li>可以<strong>节约系统资源，提高系统的性能</strong></li><li>允许看一遍数目的实例<strong>（多例类）</strong></li></ul></li><li><p>缺点：</p><ul><li>扩展困难（缺少抽象层）</li><li>单例类的职责过重</li><li>由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失</li></ul></li><li><p>使用场景：</p><ul><li>系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象</li></ul></li><li><p>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/posts/92a38b2.html"/>
      <url>/posts/92a38b2.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>使用了原型模式的类，可以通过<strong>复制该类的实例化对象，来创建新的对象。</strong></p><p>原型模式允许一个原型对象创建一个或多个同类型的其他对象，而无需知道任何创建的细节。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Client：客户类</li><li>Prototype：抽象原型类</li><li>ConcretePrototype：具体原型者</li></ul><p><img src="http://typora.lemonchan.top/image-20220324153149241.png" alt="image-20220324153149241"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p><code>Prototype</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> implement Cloneable&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"><span class="keyword">protected</span> String date;</span><br><span class="line"><span class="keyword">protected</span> String content;</span><br><span class="line">    <span class="comment">// 省略Setter、Getter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Prototype <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="keyword">return</span> (Prototype) <span class="built_in">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcretePrototype</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> extend Prototype&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span>&#123;</span><br><span class="line">Prototype cloneObj=<span class="keyword">new</span> <span class="title class_">WeeklyLog</span>();</span><br><span class="line">cloneObj.setContent(<span class="keyword">new</span> <span class="title class_">String</span>(content));</span><br><span class="line">cloneObj.setDate(<span class="keyword">new</span> <span class="title class_">String</span>(date));</span><br><span class="line">cloneObj.setName(<span class="keyword">new</span> <span class="title class_">String</span>(name));</span><br><span class="line">System.out.println(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Client</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prototype</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line">Prototype clonePro=pro.clone();</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>java中Object类实现了clone方法，是浅拷贝的方式（对于成员变量，如果是基本数据类型，则进行值拷贝，如果是引用数据类型，则直接把原来的引用值拷贝一份，即<strong>拷贝后对象的该成员变量与原来对象的该成员变量在内存中是同一个对象</strong>）</p><ul><li><p>优点：</p><ul><li>简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率，无需工厂</li><li>扩展性较好</li><li>可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作</li></ul></li><li><p>缺点：</p><ul><li>需要为每一个类配备一个克隆方法，该克隆方法位于类的内部，当对已有类进行改造时，需要修改源代码，违背了开闭原则。</li><li>实现深克隆需要编写较为复杂的代码，如果对象之间存在剁成嵌套关系时，需要对每层对象都实现深克隆，实现麻烦</li></ul></li><li><p>使用场景：</p><ul><li>创建新对象的成本较大</li></ul></li><li><p>新对象与旧对象仅有小部分差别</p><ul><li>系统需要保存对象的状态</li></ul></li><li><p>避免使用分层次的工厂类来创建分层次的对象</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造者模式</title>
      <link href="/posts/2a48474d.html"/>
      <url>/posts/2a48474d.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>一步一步<strong>创建一个复杂的对象</strong>，允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户<strong>不需要知道内部的具体构建细节（比如成员遍历的赋值顺序）</strong>。建造者模式属于<strong>对象创建型模型</strong>。</p><p><em>建造者模式是使用一个建造者，用多个方法实现对象中各部分的构建。用一个指挥者以一定的顺序来调用建造者的方法，最后生成一个对象。</em></p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Product：产品类</li><li>Builder：抽象建造者</li><li>ConcreteBuilder：具体建造者</li><li>Director：指挥者</li></ul><p><img src="http://typora.lemonchan.top/image-20220324115550702.png" alt="image-20220324115550702"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object A;</span><br><span class="line">    <span class="keyword">private</span> Object B;</span><br><span class="line">    <span class="keyword">private</span> Object C;</span><br><span class="line">    <span class="comment">// 省略ABC的getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Builder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Product product=<span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildC</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteBuilder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> extend Builder&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 构造产品的变量A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 构造产品的变量B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildC</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">// 构造产品的变量C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Director</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.builder=builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuilder</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.builder=builer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">builder.buildA();</span><br><span class="line">        builder.buildC();</span><br><span class="line">builder.buildB();</span><br><span class="line"><span class="keyword">return</span> builder.getResult();</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>Client</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Builder builder=<span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>();</span><br><span class="line">Director director=<span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">Product product=director.construct();</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li>客户端<strong>不必知道产品内部组成的细节</strong>，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li><strong>每一个具体建造者都相对独立</strong>，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则</li><li>可以更加精细<strong>控制产品的创建过程</strong></li></ul></li><li><p>缺点：</p><ul><li>不同建造者所创建的产品<strong>具有较多的共同点</strong>（是同一个类），其组成部分相似，如果产品之间的差异性很大，则不适用建造者模式</li><li>如果产品的<strong>内部变化复杂</strong>，可能会需要定义很多具体建造类来<strong>实现这种变化</strong>，会使得系统变得很庞大，增加了系统的理解难度和运行成本。</li></ul></li><li><p>使用场景：</p><ul><li>需要生成的产品具有<strong>复杂的内部结构</strong>，通常包含多个成员变量</li></ul></li><li><p>需要生成的产品对象的属性相互依赖，<strong>需要指定产品内部组成的生成顺序</strong></p><ul><li>对象的创建过程独立于创建该对象的类。即：对象是建造者创建的，但是创建过程是由指挥者控制的。</li></ul></li><li><p>隔离复杂对象的创建和使用，使得相同的创建过程可以创建不同的产品（同一个指挥者但是不同建造者）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-抽象工厂模式</title>
      <link href="/posts/5a86ebac.html"/>
      <url>/posts/5a86ebac.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列<strong>相关</strong>或<strong>相互依赖的对象</strong>的接口，而无需执行它们具体的类，属于对象创建型模式。<br>与工厂方法模式的区别是：抽象工厂模式中，一个工厂负责生产多个产品。而工厂方法模式一个工厂只负责生产一个产品</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Product：抽象产品类，是工厂生产的所有产品的基类&#x2F;接口</li><li>Factory：抽象工厂类，是所有工厂的父类，定义工厂的接口</li><li>ConcreteProduct：具体产品类</li><li>ConcreteFactory：具体工厂类</li></ul><p><img src="http://typora.lemonchan.top/image-20220324104545067.png" alt="image-20220324104545067"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AirConditioner</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeTemperature</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteProduct</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierAC</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeTemperature</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier空调正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseAC</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeTemperature</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense空调正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Tv <span class="title function_">productTv</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> AirConditioner <span class="title function_">productAC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierFactory</span> extend Factory&#123;</span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">productTv</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Haier电视！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> AirConditioner <span class="title function_">ProductAC</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Haier空调！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierAC</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseFactory</span> extend Factory&#123;</span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">productTv</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Hisense电视！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> AirConditioner <span class="title function_">ProductAC</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Hisense空调！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseAC</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>优点：<ul><li>隔离了具体类的生成，使得客户端不需要知道什么被创建</li><li>当一个产品族（同一工厂生茶你的不同品种的产品）的多个对象被设计成一起工作时，保证客户端时钟只使用一个产品族中的对象</li><li>增加新的产品族很方便（增加新的品牌，只需要增加对应的产品和工厂），无需修改原有系统，符合开闭原则</li></ul></li><li>缺点：<ul><li>增加新的产品很不方便，需要修改工厂基类，修改每一个工厂，违背开闭原则。</li></ul></li><li>使用场景：<ul><li>系统不应当依赖于产品类实例如何被创建、组合和表达的细节</li><li>系统中有多个产品族，且每次只是用一个产品族</li><li>同个产品族的产品将一起使用</li><li>产品族的结构稳定（即设计完成后，不会修改产品族的组成，只会增删产品族）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂方法模式</title>
      <link href="/posts/89a20157.html"/>
      <url>/posts/89a20157.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>工厂方法模式（Factory Method Pattern）简称工厂模式，也叫<strong>虚拟构造器模式</strong>或者<strong>多态工厂模式</strong>，它属于<strong>类创建型模式</strong>。</p><p>在工厂方法模式中，有一个<strong>抽象工厂类</strong>，它定义了创建产品的接口。不同产品的<strong>工厂都是该抽象工厂的子类</strong>，负责实现该接口来生产具体的产品。这样的目的是<strong>将产品类的实例化操作交给工厂子类</strong>，通过确定工厂子类类确定实例化哪一个产品</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Product：抽象产品类，是工厂生产的所有产品的基类&#x2F;接口</li><li>Factory：抽象工厂类，是所有工厂的父类，定义工厂的接口</li><li>ConcreteProduct：具体产品类</li><li>ConcreteFactory：具体工厂类</li></ul><p><img src="http://typora.lemonchan.top/image-20220324100624337.png" alt="image-20220324100624337"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p>要求：每种品牌的电视机由相应的子工厂进程生产，每个工厂只负责一种电视机的生产。当增加新品种电视机时，无需修改原有结构，只需增加新的电视机和新的电视机工厂即可。</p><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteProduct</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TVFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">productTv</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTVFactory</span> extend TVFactory&#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">productTv</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Haier电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTVFactory</span> extend TVFactory&#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">productTv</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Hisense电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li>向用户提供了实例化产品类的方法，并且向客户隐藏了具体哪个产品将被实例化这一细节</li><li>产品类实例化的细节完全由工厂决定</li><li>允许系统在不修改原有工厂类、产品类的情况下引入新产品，符合开闭原则</li><li>每个工厂类负责一个产品的生产，不会使得单一工厂职责过重</li></ul></li><li><p>缺点：</p><ul><li>系统中类的数量成对增加，每增加一个产品，就要增加两个类，增加了系统复杂度</li><li>增加了系统的抽象性和理解难度</li></ul></li><li><p>使用场景：</p><ul><li><p>客户端不知道需要的具体产品类，只需要知道工厂类名即可</p></li><li><p>抽象工厂通过其子类来指定创建哪个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File xmlFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/lab1/topic2/config.xml&quot;</span>);</span><br><span class="line">factory = (LogFactory) XMLUtil.getBean(xmlFile);</span><br><span class="line">log = factory.createLog();</span><br><span class="line">log.writeLog();</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记-Http1.0、1.1、2.0的区别</title>
      <link href="/posts/e792a541.html"/>
      <url>/posts/e792a541.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP1-1与1-0的区别"><a href="#HTTP1-1与1-0的区别" class="headerlink" title="HTTP1.1与1.0的区别"></a>HTTP1.1与1.0的区别</h2><ol><li>HTTP1.1默认使用长连接，而1.0默认使用短连接</li><li>HTTP1.1增加了大量的状态码，比如：<code>100(Continue)</code>——在请求大量资源时返回的预热，询问Client是否真的需要该资源</li><li>HTTP1.1在缓存上增加了许多细节，但具体实现与1.0一致。<ol><li>每个响应体都会带上一个时间，表示服务器中这些数据最后被修改的时间。</li><li>Client每次发送请求的时候都会携带对应的时间，询问服务器该资源是否过期，服务器比对Client发送过来的时间以及资源的最后修改时间，如果一致，则返回状态码为304的响应让Client从缓存取，否则返回200并带上最新资源响应体。</li></ol></li><li>HTTP1.1在请求头加入了Host字段，标记了服务器的主机名。因为一个IP地址可以由多个域名映射，一台服务器可以部署多个应用，不同的域名往往是不同的应用。DNS解析之后，会将已解析的域名替换成ip地址，此时服务器不知道客户想要访问的到底哪个应用。而HTTP1.1的Host字段就记录下了该域名，服务器就可以知道客户想要访问的应用</li><li>HTTP1.1增加了范围请求(<code>Range</code>)，可以请求某个数据的一部分（比如客户端只需要某个对象的一部分信息），也支持了断点传输。服务器可以忽略<code>Range</code>并返回全部数据，也可以返回若干<code>Range</code>响应。</li></ol><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><h3 id="SPDY：HTTP1-x的升级"><a href="#SPDY：HTTP1-x的升级" class="headerlink" title="SPDY：HTTP1.x的升级"></a>SPDY：HTTP1.x的升级</h3><p>是由Google剔除的方案，优化了HTTP1.X的请求延迟，解决了安全性，具体如下。</p><ol><li><strong>降低延迟</strong>：使用多路复用，使多个请求可以使用同一个TCP连接并发执行（长连接是串行）。</li><li><strong>请求优先级</strong>：因为多路复用可能会导致重要请求被阻塞，因此SPDY允许给不同请求设置优先级，重要的优先级会先响应。比如访问一个网站，对html内容的请求应该是最先响应，然后才是css、js、图片等。</li><li><strong>压缩请求头</strong>：HTTP1.X的请求&#x2F;响应头是文本传输，而SPDY对请求头进行压缩再传输。</li><li><strong>基于HTTPS</strong>：强制使用HTTPS加密传输。</li><li><strong>服务端推送</strong>：允许在浏览器明确发出请求前，将一些资源推送给浏览器，存放在浏览器缓存中。避免了浏览器对所有资源的分次请求，提高效率。</li></ol><h3 id="HTTP2-0：SPDY的升级"><a href="#HTTP2-0：SPDY的升级" class="headerlink" title="HTTP2.0：SPDY的升级"></a>HTTP2.0：SPDY的升级</h3><p>HTTP2.0与SPDY的不同：</p><ol><li>HTTP2.0支持明文传输，而SPDY必须使用HTTPS</li><li>HTTP2.0与SPDY的请求&#x2F;响应头压缩算法不一样</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记-Https是如何加密的？</title>
      <link href="/posts/ed7edf56.html"/>
      <url>/posts/ed7edf56.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul><li>HTTP使用明文通信（不加密），内容可能被窃听。</li><li>HTTP不验证通信双方身份，因此有可能遭遇伪装。</li><li>HTTP无法验证报文的完整性，报文可能会遭到篡改。</li></ul><p><strong>HTTPS&#x3D;HTTP+通信加密+证书+完整性保护</strong></p><h2 id="二、通信加密"><a href="#二、通信加密" class="headerlink" title="二、通信加密"></a>二、通信加密</h2><p>HTTPS同时使用了两种加密方式</p><ol><li>对称加密：加密和解密用的是同一密钥，优点是加密解密速度快，缺点是需要将密钥发送给接收方。用于HTTP通信交换报文阶段。</li><li>非对称加密：加密和解密用的是不同密钥，优点是不需要将密钥发送给接收方，缺点是加密解密速度慢。用于传输《对称加密的密钥》</li></ol><p><img src="http://typora.lemonchan.top/image-20220305233950281.png" alt="image-20220305233950281"></p><h2 id="三、证书"><a href="#三、证书" class="headerlink" title="三、证书"></a>三、证书</h2><p>如果公开密钥在传输过程中被攻击者拦截，并将公开密钥进行替换，接收端如果使用该被替换的公开密钥进行加密，则数据会被攻击方轻松破解。数字证书正是解决这种问题而出现的。</p><p><strong>数字证书</strong>：</p><ol><li>是由数字证书认证机构（CA）和其相关机关颁发的的公开密钥证书。</li><li>证书组成：证书内容（包括证书所有人、服务器公钥等信息）、加密算法、加密密文（证书内容加密的产物）</li></ol><p><strong>数字认证机构</strong>：是客户端和服务器双方都可信赖的第三方机构。</p><p><strong>证书申请过程</strong>：</p><ol><li>服务器运营人员向CA提出公开密钥的申请。</li><li>CA核实申请者身份后，将申请者提交的公开密钥、申请者信息、CA的信息等组合成证书内容，然后做数字签名（实际上是将证书内容使用SHA1算法进行hash，然后用CA的私钥对hash结果进行加密）</li><li>CA将证书内容、加密算法、数字签名组合成证书，然后交还给服务器。</li></ol><p><strong>证书如何保证安全？</strong></p><ol><li>服务器将数字证书发送给客户端，客户端收到证书后对数字证书进行验证（使用对应的CA的公钥和证书内的加密算法对数字签名进行解密，然后将证书内容使用SHA1算法进行hash，将两者结果对比），验证通过后客户端能确定这个证书是可信的。</li><li>CA的公钥如何安全传输是一个问题，因此多数浏览器开发商会在浏览器内部植入常用CA的公钥。</li></ol><p><img src="http://typora.lemonchan.top/image-20220305235402474.png" alt="image-20220305235402474"></p><h2 id="四、完整性保护"><a href="#四、完整性保护" class="headerlink" title="四、完整性保护"></a>四、完整性保护</h2><p>通过HTTPS发送的报文，其会携带名为MAC的报文摘要，能够提示报文是否遭到篡改</p><h2 id="五、HTTPS的安全通信机制"><a href="#五、HTTPS的安全通信机制" class="headerlink" title="五、HTTPS的安全通信机制"></a>五、HTTPS的安全通信机制</h2><ol><li>Client发送Client Hello报文开始SSL通信。报文中包含Client支持的<strong>SSL版本、加密组件列表（所使用的加密算法和密钥长度等）</strong></li><li>Server发送Server Hello报文响应Client，报文中同样包含Server支持的SSL版本和加密组件列表（<strong>从Client的Client Hello报文中筛选得出</strong>）</li><li>Server向Client发送Certificate报文，其中包含自己的<strong>公开密钥证书</strong></li><li>Server向Client发送Server Hello Done报文，表示SSL通信<strong>握手协商部分结束</strong></li><li>Client发送Client Key Exchange报文，其中包含了通信加密中使用的一种被称为Pre-master secret的随机<strong>密码串</strong>，该密码串<strong>已使用服务器的公钥进行加密</strong></li><li>Client发送Change Cipher Spec报文，告诉服务器今后的通信都用Pre-master secret（使用步骤2中的加密算法）进行对称加密。</li><li>Client发送Finished报文，该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。<strong>（该报文用步骤5中的随机密码串、步骤2中的加密方法进行加密）</strong></li><li>Server发送Change Cipher Spec报文。</li><li>Server发送Finished报文。</li><li>Client和Serve的Finished报文交换完毕，SSL连接建立完成，通信会收到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</li><li>应用层协议通信，即发送HTTP相应。</li><li>最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。</li></ol><p><img src="http://typora.lemonchan.top/image-20220306001438614.png" alt="image-20220306001438614"></p><p><img src="http://typora.lemonchan.top/image-20220306002632730.png" alt="image-20220306002632730"></p><p><strong>SSL和TLS的关系</strong>：TLS是以SSL为基准开发的，有时会统一称为SSL</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记-Linux常用命令</title>
      <link href="/posts/27065e75.html"/>
      <url>/posts/27065e75.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><ol><li><p><code>cd xx</code>：切换到目录<code>xx</code></p><ol><li><code>cd /</code>：切换到根目录</li><li><code>cd ~</code>：切换到当前用户目录</li><li><code>cd ../</code>：切换到上一层目录</li><li><code>cd -</code>：切换到上一操作所在目录</li></ol><p><img src="http://typora.lemonchan.top/image-20220305160402770-16464674663031.png" alt="image-20220305160402770"></p></li><li><p><code>mkdir [参数] [目录]</code>：创建一个目录</p><p><img src="http://typora.lemonchan.top/image-20220305161632460.png" alt="image-20220305161632460"></p></li><li><p><code>ls</code>：打印当前目录下的所有目录名&#x2F;文件名</p></li><li><p><code>ll</code>：等同于<code>ls -l</code>，打印当前目录下的所有目录&#x2F;文件详细信息</p><p><img src="http://typora.lemonchan.top/image-20220305160712165.png" alt="image-20220305160712165"></p></li><li><p><code>cp [参数] [文件名*n] [目的路径]</code>：复制文件或目录</p><p><img src="http://typora.lemonchan.top/image-20220305161433282.png" alt="image-20220305161433282"></p></li><li><p><code>mv [参数] [文件名] [目的路径]</code>：移动文件&#x2F;目录</p><p><img src="http://typora.lemonchan.top/image-20220305163219211.png" alt="image-20220305163219211"></p></li><li><p><code>pwd [参数]</code>：显示当前所在路径</p></li><li><p><code>tar [参数] [文件名]</code>：文件打包压缩&#x2F;解压</p><p><img src="http://typora.lemonchan.top/image-20220305183706369.png" alt="image-20220305183706369"></p><ol><li>常用压缩：<code>tar -zcvf [xxx.tar.gz] [待压缩文件]</code>：将待压缩文件打包成xxx.tar然后压缩成xxx.tar.gz。并显示运行过程</li><li>常用解压：<code>tar -xvf [xxx.tar.gz] -C [解压目录]</code>：将xxx.tar.gz解压到指定目录下。如果没有-C [解压目录]，则解压到xxx.tar.gz所在目录下。</li></ol></li><li><p><code>chmod [权限] [文件名]</code>：修改文件&#x2F;目录权限</p><ol><li><p>文件类型：</p><ul><li><code>d</code>：代表目录</li><li><code>-</code>：代表文件</li><li><code>l</code>：代表软连接</li></ul></li><li><p>权限：</p><ul><li><code>r</code>：可读，也可以用<code>4</code>表示，对目录来说是可以查看目录内文件。</li><li><code>w</code>：可写，也可以用<code>2</code>表示，对目录来说是可以修改目录内文件。</li><li><code>x</code>：可执行，也可以用<code>1</code>表示，对目录来说是可以cd进去。</li></ul></li><li><p>linux中的用户必须属于一个用户组，每个文件有所属用户、所属组、其他组的概念，需要对这3个概念对应的用户分别设置文件权限。</p><ul><li>文件所有者（u）：一般是文件创建者，也可以用<code>chown 用户名 文件名</code>命令修改</li><li>文件所在组（g）：初始是文件创建者所在组，也可以用<code>chgrp 组名 文件名</code>命令修改</li><li>其他组（o）：除了上述两种用户，对于一个文件来说，其他用户都属于其他组</li></ul></li><li><p>eg:<code>chmod u=rwx,g=rw,o=r aaa.txt</code>：文件所属者拥有读、写、执行权限，文件所属组的用户拥有读写权限，其他组的用户只拥有读的权限。</p></li></ol></li></ol><h2 id="文档编辑命令"><a href="#文档编辑命令" class="headerlink" title="文档编辑命令"></a>文档编辑命令</h2><ol><li><p><code>cat [参数] [文件名]</code>：显示文件所有内容，适用于内容少的文件，因为大量内容显示出来，只能看到最后一页的内容</p><p><img src="http://typora.lemonchan.top/image-20220305163939903.png" alt="image-20220305163939903"></p></li><li><p><code>more [参数] [文件]</code>：分页显示文件内容</p><p><img src="http://typora.lemonchan.top/image-20220305182851764.png" alt="image-20220305182851764"></p></li><li><p><code>tail [参数] [文件名]</code>：显示文件尾部的内容，默认显示最后10行，可以同时读取多个文件</p><p><img src="http://typora.lemonchan.top/image-20220305165421194.png" alt="image-20220305165421194"></p></li><li><p><code>less [参数] [文件名]</code>：显示文件内容，与more类似</p><p><img src="http://typora.lemonchan.top/image-20220305183253451.png" alt="image-20220305183253451"></p></li><li><p><code>vim [文件]</code>：编辑文件</p></li><li><p><code>echo [参数] [字符串]</code>：打印字符串或变量提取后的值</p><ol><li><code>echo $PATH</code>：打印<code>$PATH</code>存储的内容（因为传的是字符串变量）</li><li><code>echo &quot;String&quot;</code>：打印内容是<code>String</code>（因为传的是字符串）</li></ol><p><img src="http://typora.lemonchan.top/image-20220305164350174.png" alt="image-20220305164350174"></p></li><li><p><code>rm [参数] [文件]</code>：<del>用于删库跑路</del> 删除文件&#x2F;目录，可使用正则表达式</p><p><img src="http://typora.lemonchan.top/image-20220305165041686.png" alt="image-20220305165041686"></p></li><li></li><li><p><code>grep [参数] [模式] [目录]</code>：搜索指定目录下符合模式的文件名（也可用于管道搜索），当模式内部含有空格，需要用双引号引起来</p><p><img src="http://typora.lemonchan.top/image-20220305165715069.png" alt="image-20220305165715069"></p></li></ol><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ol><li><p><code>rpm [参数] [软件包]</code>：用于管理rpm软件包：安装、卸载、升级、查询、验证</p><p><img src="http://typora.lemonchan.top/image-20220305165918824.png" alt="image-20220305165918824"></p></li><li><p><code>find [参数] [查找路径] [查找范围]</code>：用于搜索指定路径下的满足要求的文件&#x2F;目录，是递归查找，会包括子目录内容</p><p><img src="http://typora.lemonchan.top/image-20220305170216953.png" alt="image-20220305170216953"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">find /etc -name <span class="string">&quot;*.conf&quot;</span> --查找/etc目录下结尾为.conf的文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find /etc -size +1M  --查找/etc目录下大于1M的文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">print</span> --查找当前用户主目录及其子目录下的所有文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">type</span> f -atime +7 --查找当前用户主目录及子目录下7天前被访问过的所有文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">type</span> f -amin +7 --查找当前用户主目录及子目录下7分钟前被访问过的所有文件</span></span><br></pre></td></tr></table></figure></li><li><p><code>uname [参数]</code>：打印系统信息</p><p><img src="http://typora.lemonchan.top/image-20220305182242657.png" alt="image-20220305182242657"></p></li><li><p><code>chkconfig --add [脚本名]</code>：添加开机启动脚本</p></li><li><p><code>chkconfig --list</code>：查看开机启动的脚本</p></li><li><p><code>ps [参数]</code>：查看进程</p><ol><li><code>ps -ef</code>显示所有进程，其信息包括<ul><li>所属用户（UID）</li><li>进程ID（PID）</li><li>父进程ID（PPID）</li><li>CPU使用率（C）</li><li>系统启动时间（STIME）</li><li>TTY（登入这的终端机位置）</li><li>用掉的CPU时间（TIME）</li><li>哪个指令启动的进程（CMD）</li></ul></li><li><code>ps -ef | grep xxx</code>显示进程名含有xxx的所有进程</li></ol></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ol><li><p><code>useradd [参数] [用户名]</code>：添加用户</p><p><img src="http://typora.lemonchan.top/image-20220305190212389.png" alt="image-20220305190212389"></p></li><li><p><code>userdel [参数] [用户名]</code>：删除用户账号</p><p><img src="http://typora.lemonchan.top/image-20220305190233651.png" alt="image-20220305190233651"></p></li><li><p><code>usermod [选项] [用户名]</code>：修改用户账户</p><p><img src="http://typora.lemonchan.top/image-20220305190335226.png" alt="image-20220305190335226"></p></li><li><p><code>passw [参数] [用户名]</code>：操作用户密码</p><p><img src="http://typora.lemonchan.top/image-20220305190506221.png" alt="image-20220305190506221"></p></li><li><p><code>groupadd [参数] [组名]</code>：添加用户组</p><p><img src="http://typora.lemonchan.top/image-20220305190624859.png" alt="image-20220305190624859"></p></li><li><p><code>groupdel [参数] [组名]</code>：删除用户组</p><p><img src="http://typora.lemonchan.top/image-20220305190720778.png" alt="image-20220305190720778"></p></li><li><p><code>groupmod [参数] [组名]</code>：修改用户组</p><p><img src="http://typora.lemonchan.top/image-20220305190924506.png" alt="image-20220305190924506"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.linuxcool.com/">Linux 命令大全</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-1584. 连接所有点的最小费用</title>
      <link href="/posts/e421b227.html"/>
      <url>/posts/e421b227.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/min-cost-to-connect-all-points">http://leetcode-cn.com/problems/min-cost-to-connect-all-points</a></p><p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi] </code>。</p><p>连接点<code>[xi, yi]</code>和点<code> [xj, yj]</code> 的费用为它们之间的 曼哈顿距离 ：<code>|xi - xj| + |yi - yj| </code>，其中<code>|val|</code>表示<code>val</code>的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p><blockquote><ul><li><code>1 &lt;= points.length &lt;= 1000</code></li><li><code>-106 &lt;= xi, yi &lt;= 106</code></li><li>所有点 <code>(xi, yi)</code> 两两不同。</li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/c.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]</span><br><span class="line">输出：20</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最小生成树题目，用prim和kruskal算法解题</p><p>prim(加点法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//prim算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=points.length;</span><br><span class="line">        <span class="comment">// 记录未加入节点与已加入的节点的最小距离,已加入的节点距离为0</span></span><br><span class="line">        <span class="type">int</span>[] minDistance=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(minDistance,Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">// 初始节点为0</span></span><br><span class="line">        <span class="type">int</span> newPoint=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把所有节点都加进去需要n-1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 记录未加入的节点与已加入节点的距离最小值以及节点编号</span></span><br><span class="line">            <span class="type">int</span> min=Integer.MAX_VALUE,minIndex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">// 节点已加入,continue</span></span><br><span class="line">                <span class="keyword">if</span>(minDistance[j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 因为加入了新节点,所以要用新节点与未加入的节点算一下距离,如果更小则更新minDistance</span></span><br><span class="line">                minDistance[j]=Math.min(minDistance[j],dis(points,newPoint,j));</span><br><span class="line">                <span class="comment">// 取minDistance的非0最小值</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;minDistance[j])&#123;</span><br><span class="line">                    minIndex=j;</span><br><span class="line">                    min=minDistance[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=min;</span><br><span class="line">            minDistance[minIndex]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 记录下新加入的节点的编号</span></span><br><span class="line">            newPoint=minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dis</span><span class="params">(<span class="type">int</span> [][]points ,<span class="type">int</span> point1,<span class="type">int</span> point2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(points[point1][<span class="number">0</span>]-points[point2][<span class="number">0</span>])+Math.abs(points[point1][<span class="number">1</span>]-points[point2][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kruskal(加边法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 并查集类,使用加权压缩路径并查集</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Union</span>&#123;</span><br><span class="line">        <span class="comment">// 记录每个分支含有的节点数</span></span><br><span class="line">        <span class="type">int</span> []cnts;</span><br><span class="line">        <span class="comment">// 记录父节点</span></span><br><span class="line">        <span class="type">int</span> []parents;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">            cnts=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            parents=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                parents[i]=i;</span><br><span class="line">                cnts[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            <span class="type">int</span> tempN=n,next=parents[n];</span><br><span class="line">            <span class="comment">// 寻找最终父节点</span></span><br><span class="line">            <span class="keyword">while</span>(n!=parents[n])&#123;</span><br><span class="line">                n=parents[n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 路径压缩</span></span><br><span class="line">            <span class="keyword">while</span>(tempN!=parents[tempN])&#123;</span><br><span class="line">                next=parents[tempN];</span><br><span class="line">                parents[tempN]=n;</span><br><span class="line">                tempN=next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并两个节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">            <span class="comment">// 分别找出父节点</span></span><br><span class="line">            <span class="type">int</span> pa=getParent(a);</span><br><span class="line">            <span class="type">int</span> pb=getParent(b);</span><br><span class="line">            <span class="comment">// 已经在一个集合中,无需合并</span></span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 将节点数少的子集合并到节点数多的集合中</span></span><br><span class="line">            <span class="keyword">if</span>(cnts[pa]&gt;=cnts[pb])&#123;</span><br><span class="line">                parents[pb]=pa;</span><br><span class="line">                cnts[pa]+=cnts[pb];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parents[pa]=pb;</span><br><span class="line">                cnts[pb]+=cnts[pa];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=points.length,index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 边的数量是(n-1)+(n-2)+...+(1)</span></span><br><span class="line">        <span class="type">int</span> [][]sides=<span class="keyword">new</span> <span class="title class_">int</span>[len*(len-<span class="number">1</span>)/<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 遍历点构建边集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                sides[index][<span class="number">0</span>]=i;</span><br><span class="line">                sides[index][<span class="number">1</span>]=j;</span><br><span class="line">                sides[index++][<span class="number">2</span>]=Math.abs(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>])+Math.abs(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 边集根据边的长度排序</span></span><br><span class="line">        Arrays.sort(sides,(o1,o2)-&gt;o1[<span class="number">2</span>]-o2[<span class="number">2</span>]);</span><br><span class="line">        Union u=<span class="keyword">new</span> <span class="title class_">Union</span>(len);</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录下已经使用的边</span></span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []side :sides)&#123;</span><br><span class="line">            <span class="comment">// 遍历边集,如果两个点原本属于不同集合,则利用该边将两个集合连接(union)起来</span></span><br><span class="line">            <span class="keyword">if</span>(u.union(side[<span class="number">0</span>],side[<span class="number">1</span>]))&#123;</span><br><span class="line">                res+=side[<span class="number">2</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// n-1条边刚好可以将所有节点连接起来</span></span><br><span class="line">            <span class="keyword">if</span>(cnt==len-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> prim </tag>
            
            <tag> Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-743. 网络延迟时间</title>
      <link href="/posts/10b4218e.html"/>
      <url>/posts/10b4218e.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/network-delay-time">http://leetcode-cn.com/problems/network-delay-time</a></p><p>有 <code>n </code>个网络节点，标记为 <code>1 </code>到<code> n</code>。</p><p>给你一个列表 <code>times</code>，表示信号经过 有向 边的传递时间。<code> times[i] = (ui, vi, wi)</code>，其中<code> ui</code> 是源节点，<code>vi</code> 是目标节点，<code>wi</code>是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回<code>-1</code>。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/931_example_1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dijkstra算法和floyd算法。分别求单源点的最短路径和多源点的最短路径。</p><p><strong>Dijkstra</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 邻接表存图</span></span><br><span class="line">    List&lt;<span class="type">int</span> []&gt;[]lists;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 记录这个点是否被用来当过中间点更新</span></span><br><span class="line">    <span class="type">boolean</span> []vis;</span><br><span class="line">    <span class="comment">// 记录所求点到每一个点的最短距离</span></span><br><span class="line">    <span class="type">int</span> []res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        lists=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[n+<span class="number">1</span>];</span><br><span class="line">        vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        res=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// -1代表不可达，初始状态只能到达自己</span></span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        res[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            lists[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] group:times)&#123;</span><br><span class="line">            lists[group[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;group[<span class="number">1</span>],group[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(k);</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 查找最大距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 有一个点不可达则返回-1</span></span><br><span class="line">            <span class="keyword">if</span>(res[i]==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            cnt=Math.max(cnt,res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迪杰斯特拉算法，二叉堆优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">// 用优先队列来存放当前备选中转节点,取距离最短的点为O(logN)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span> []&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((arr1,arr2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> arr1[<span class="number">1</span>]-arr2[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 初始只有自己本身,距离为0</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;k,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出距离最短的点.</span></span><br><span class="line">            <span class="type">int</span>[] midNode=queue.poll();</span><br><span class="line">            <span class="type">int</span> midIdx=midNode[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> midLen=midNode[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 因为所有入队的节点,都是通过已有节点中转进来的,而中转的节点必定比原来节点距离大,因此只要当过中转节点,那么它离原点距离必定最小</span></span><br><span class="line">            <span class="comment">//  已经当过中转节点,continue</span></span><br><span class="line">            <span class="keyword">if</span>(vis[midIdx]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 标记已当过中转节点</span></span><br><span class="line">            vis[midIdx]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 遍历以该中转节点为起点的所有边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> [] arr:lists[midIdx])&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[arr[<span class="number">0</span>]]==-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果该边的终点原本与k不可达,则更新</span></span><br><span class="line">                    res[arr[<span class="number">0</span>]]=arr[<span class="number">1</span>]+midLen;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>],res[arr[<span class="number">0</span>]]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">1</span>]+midLen&lt;res[arr[<span class="number">0</span>]])&#123;</span><br><span class="line">                    <span class="comment">// 如果该边的终点原本与k可达,但经过中转距离可以缩短,则更新</span></span><br><span class="line">                    res[arr[<span class="number">0</span>]]=arr[<span class="number">1</span>]+midLen;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>],res[arr[<span class="number">0</span>]]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Floyd</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 邻接矩阵存图</span></span><br><span class="line">    <span class="type">int</span> [][]map;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        map=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i) map[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> map[i][j]=map[j][i]=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把每条边映射到邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] group:times)&#123;</span><br><span class="line">            map[group[<span class="number">0</span>]][group[<span class="number">1</span>]]=group[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        floyd();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[k][i]==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            res=Math.max(map[k][i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点,以i作为中转节点,起点为j,终点为k,找最短路径</span></span><br><span class="line">        <span class="comment">//  i=1时,只能使用1作为中转</span></span><br><span class="line">        <span class="comment">//  i=2时,实际上一些节点已经替换成经过1中转了.因此此时是使用1和2作为中转</span></span><br><span class="line">        <span class="comment">//   以此类推......</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[j][k]==-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">// 原本不可达,经过中转可达,则更新</span></span><br><span class="line">                        <span class="keyword">if</span>(map[j][i]!=-<span class="number">1</span>&amp;&amp;map[i][k]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            map[j][k]=map[j][i]+map[i][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 原本可达,但经过中转后距离更小,更新</span></span><br><span class="line">                        <span class="keyword">if</span>(map[j][i]!=-<span class="number">1</span>&amp;&amp;map[i][k]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            map[j][k]=Math.min(map[j][i]+map[i][k],map[j][k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> floyd </tag>
            
            <tag> dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记-socket</title>
      <link href="/posts/13b55345.html"/>
      <url>/posts/13b55345.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>socket即<strong>套接字</strong>，是一个软件接口，进程通过Socket向网络发送报文和从网络接收报文，是一台计算机内应用层与传输层之间的接口，用于计算机进程之间的网络通信。</p><h1 id="二、socket的类型"><a href="#二、socket的类型" class="headerlink" title="二、socket的类型"></a>二、socket的类型</h1><h2 id="1、流格式套接字（SOCK-STREAM）"><a href="#1、流格式套接字（SOCK-STREAM）" class="headerlink" title="1、流格式套接字（SOCK_STREAM）"></a>1、流格式套接字（SOCK_STREAM）</h2><p>面向连接的套接字，使用了TCP协议</p><ul><li>数据在传输过程中不会消失；</li><li>数据是按照顺序传输的；</li><li>数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。即连续ARQ</li></ul><h2 id="2、数据报格式套接字（SOCK-DGRAM）"><a href="#2、数据报格式套接字（SOCK-DGRAM）" class="headerlink" title="2、数据报格式套接字（SOCK_DGRAM）"></a>2、数据报格式套接字（SOCK_DGRAM）</h2><p>无连接的套接字，使用了UDP协议，它有以下特征：</p><ul><li>强调快速传输而非传输顺序；</li><li>传输的数据可能丢失也可能损毁；</li><li>限制每次传输的数据大小；</li><li>数据的发送和接收是同步的（有的教程也称“存在数据边界”）。</li></ul><h1 id="三、常用的socket函数（以TCP介绍）"><a href="#三、常用的socket函数（以TCP介绍）" class="headerlink" title="三、常用的socket函数（以TCP介绍）"></a>三、常用的socket函数（以TCP介绍）</h1><h2 id="1、socket"><a href="#1、socket" class="headerlink" title="1、socket"></a>1、socket</h2><p><code>int socket(int family, int type, int protocol)</code>：创建套接字，创建成功返回非负文件描述符，出错返回-1</p><ul><li><code>family</code>：指明协议族，如IPV4、IPV6</li><li><code>type</code>：指明套接字类型，如SOCK_STREAM、SOCK_DGRAM</li><li><code>protocol</code>：指定传输协议，如UDP、TCP，也可省略让系统根据<code>family</code>和<code>type</code>决定</li></ul><h2 id="2、bind"><a href="#2、bind" class="headerlink" title="2、bind"></a>2、bind</h2><p><code>int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)</code>：将一个本地协议地址（由ip地址和端口号组成）与该套接字绑定。绑定成功返回0，否则返回-1.</p><ul><li><code>sockfd</code>：socket的id</li><li><code>myaddr</code>：指向协议的地址结构的指针，包括ip地址和端口号</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="3、listen"><a href="#3、listen" class="headerlink" title="3、listen"></a>3、listen</h2><p><code>int listen(int sockfd, int backlog)</code>：socket被创建出来，默认都是主动套接字，是要调用connect发起连接的。调用listen后，会把该未连接的套接字转变成被动套接字，指示内核应该接收指向该套接字的连接请求。启动监听成功返回0，否则返回-1.</p><ul><li><code>sockfd</code>：socket的id</li><li><code>backlog</code>：有多种定义，目的都是指定半连接队列和全连接队列的大小。</li></ul><h2 id="4、connect"><a href="#4、connect" class="headerlink" title="4、connect"></a>4、connect</h2><p><code>int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)</code> 用来与服务器建立连接的函数，成功返回0，否则-1。</p><ul><li><code>sockfd</code>：socket的id</li><li><code>servaddr</code>：指向套接字的地址结构的指针，包括服务器ip地址和端口号（即指定了服务器的套接字）</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="5、accept"><a href="#5、accept" class="headerlink" title="5、accept"></a>5、accept</h2><p><code>int accept(int sockfd, const struct sockaddr *cliaddr, socklen_t addrlen)</code>一般由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成的连接，accept成功后会返回一个新的socekt id，用于表示与该client的连接。</p><ul><li><code>sockfd</code>：socket的id</li><li><code>servaddr</code>：指向client的协议地址的指针，包括客户机ip地址和端口号（即指定了客户机的套接字）</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="6、fork和exec"><a href="#6、fork和exec" class="headerlink" title="6、fork和exec"></a>6、fork和exec</h2><p>用于服务并发连接。</p><p><code>fork()</code>用于创建一个子线程，子进程的代码段、堆栈段、数据段都完全复制于父进程，但是它是独立运行的。</p><p><code>exec()</code>相当于借尸还魂，代码段会被替换成新的，堆栈段、数据段会重新分配，也就是说除了PCB号，其他的都变了。</p><p>那么如何实现并发服务器程序呢？答案是使用<code>fork()</code>。当一个连接建立时，accept返回，服务器调用<code>fork</code>，然后由子进程服务客户（通过父进程建立连接的套接字），<strong>父进程则关闭该套接字</strong>并等待下一个连接（通过监听套接字）。</p><p>父进程关闭了套接字为什么子进程还可以用来传输数据呢？因为每个文件都有一个引用计数，他是当前打开着的引用该文件的描述符的个数，子进程还在使用该套接字，父进程并没有真正关闭，仅仅是释放了引用。</p><p><img src="http://typora.lemonchan.top/image-20220228230805600.png" alt="image-20220228230805600"></p><p><img src="http://typora.lemonchan.top/image-20220228230822733.png" alt="image-20220228230822733"></p><h2 id="7、close"><a href="#7、close" class="headerlink" title="7、close"></a>7、close</h2><p><code>int close(int scokfd)</code>：用于关闭套接字，默认行为是将该套接字标记位已关闭，立即返回到调用线程。该套接字不能再由调用进程使用，但是TCP仍会使用该套接字发送缓冲区的数据，发送完毕后才是正常的TCP连接中止序列（四次挥手）。</p><p><em>假如socket未进行四次挥手就关闭了，那么客户端发来报文，服务器会响应一个RST报文段。客户端的TCP收到RST报文后就知道该连接已不可达，但是应用层还不知道，当应用层再次发送报文的时候，TCP不会将数据发出，而且发一个SIGPIPE信号（用于终止程序）给应用层</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-863. 二叉树中所有距离为 K 的结点</title>
      <link href="/posts/a535a0e3.html"/>
      <url>/posts/a535a0e3.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree">http://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree</a></p><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点<code>target</code> ，和一个整数值<code> k</code> 。</p><p>返回到目标结点<code>target</code>距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/sketch0.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2</span><br><span class="line">输出：[7,4,1]</span><br><span class="line">解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1</span><br><span class="line"></span><br><span class="line">输入: root = [1], target = 1, k = 3</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题中所求的是距离target节点距离为k的所有节点，而每个节点只能往3个方向走：左节点、右节点、父节点。因此要扫描一遍树，记录下所有节点的父节点（实际上只需记录下<code>target</code>及其前方所有节点的父节点即可，因为只有这些节点需要网上扫描。但判断是否是target需要耗时，在本题中扫描整棵树效率更高）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录下每个节点的父节点</span></span><br><span class="line">    Map&lt;TreeNode,TreeNode&gt; parents=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        serach(root,<span class="literal">null</span>);</span><br><span class="line">        dfs(<span class="literal">null</span>,target,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serach</span><span class="params">(TreeNode root,TreeNode parent)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        parents.put(root,parent);</span><br><span class="line">        serach(root.left,root);</span><br><span class="line">        serach(root.right,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode last,TreeNode root,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ==0了，再走就没必要了，return</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是回头路就不要走</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=last)</span><br><span class="line">            dfs(root,root.left,k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=last)</span><br><span class="line">            dfs(root,root.right,k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(parents.get(root)!=last)</span><br><span class="line">            dfs(root,parents.get(root),k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-973. 最接近原点的 K 个点</title>
      <link href="/posts/2e849c9d.html"/>
      <url>/posts/2e849c9d.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin">https://leetcode-cn.com/problems/k-closest-points-to-origin</a></p><p>给定一个数组 points ，其中 <code>points[i] = [xi, yi]</code> 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点<code>(0,0)</code>最近的 <code>k </code>个点。</p><p>这里，平面上两点之间的距离是 欧几里德距离<code>（ √(x1 - x2)2 + (y1 - y2)2 ）</code>。</p><p>你可以<strong>按 任何顺序 返回答案</strong>。除了点坐标的顺序之外，答案 确保 是 唯一 的。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,3],[-2,2]], k = 1</span><br><span class="line">输出：[[-2,2]]</span><br><span class="line">解释： </span><br><span class="line">(1, 3) 和原点之间的距离为 sqrt(10)，</span><br><span class="line">(-2, 2) 和原点之间的距离为 sqrt(8)，</span><br><span class="line">由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。</span><br><span class="line">我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。</span><br><span class="line"></span><br><span class="line">输入：points = [[3,3],[5,-1],[-2,4]], k = 2</span><br><span class="line">输出：[[3,3],[-2,4]]</span><br><span class="line">（答案 [[-2,4],[3,3]] 也会被接受。）</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>堆排序，取k次堆顶即可。因为答案要求返回节点的x和y坐标，而排序标准是与原点距离，因此新建一个类存放x、y、len，排序过程中就不用反复计算len节省时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 建一个类来存放x，y和原点距离len</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">long</span> len;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">long</span> len)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.x=x;</span><br><span class="line">            <span class="built_in">this</span>.y=y;</span><br><span class="line">            <span class="built_in">this</span>.len=len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] kClosest(<span class="type">int</span>[][] points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 建堆</span></span><br><span class="line">        Node [] arr=<span class="keyword">new</span> <span class="title class_">Node</span> [points.length];</span><br><span class="line">        <span class="comment">// 把数据加入堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">long</span> len=points[i][<span class="number">0</span>]*points[i][<span class="number">0</span>]+points[i][<span class="number">1</span>]*points[i][<span class="number">1</span>];</span><br><span class="line">            arr[i]=<span class="keyword">new</span> <span class="title class_">Node</span>(points[i][<span class="number">0</span>],points[i][<span class="number">1</span>],len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化堆（从最后一个非叶子节点开始建队，逐渐前移）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sortHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> [][]res=<span class="keyword">new</span> <span class="title class_">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">// 堆顶为当前距离原点最近的点，取出并加入结果集</span></span><br><span class="line">            res[i]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>].x,arr[<span class="number">0</span>].y&#125;;</span><br><span class="line">            <span class="comment">// 把堆顶与堆末尾交换，移出堆</span></span><br><span class="line">            swap(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>-i);</span><br><span class="line">            <span class="comment">// 堆顶交换了，所以从堆顶位置整理堆</span></span><br><span class="line">            sortHeap(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入堆、整理的节点下标、堆的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortHeap</span><span class="params">(Node []arr,<span class="type">int</span> index,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 越界返回</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果存在右节点且右节点的值更小，则右节点称为可能与根节点交换的节点</span></span><br><span class="line">        <span class="keyword">if</span>(left+<span class="number">1</span>&lt;length&amp;&amp;arr[left].len&gt;arr[left+<span class="number">1</span>].len)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点值比左/右节点的最小值小，交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[index].len&gt;arr[left].len)&#123;</span><br><span class="line">            swap(arr,index,left);</span><br><span class="line">            <span class="comment">// 交换后要整理被交换的子节点</span></span><br><span class="line">            sortHeap(arr,left,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Node []arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Node temp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-55. 跳跃游戏</title>
      <link href="/posts/a738f689.html"/>
      <url>/posts/a738f689.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><blockquote><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心，记录下当前可以跳的最大步数，然后每次跳一步，步数－－。如果当前位置能跳的步数大于剩下能跳的步数，则在这个位置停下，然后重新记录能跳的最大步数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录下当前能往前走的最大长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果长度为0，则不能走到当前位置，return false</span></span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 每走一步长度--</span></span><br><span class="line">            len--;</span><br><span class="line">            <span class="comment">// 更新可走长度</span></span><br><span class="line">            len=Math.max(len,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-264. 丑数 II</title>
      <link href="/posts/a62a3dc0.html"/>
      <url>/posts/a62a3dc0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br><span class="line"></span><br><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol><li><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。即丑数只能由丑数×2、×3、×5得出。已知丑数集合<code>[1]</code>，分别可以算出<code>[1*2][1*3][1*5]</code>，取其中最小<code>2</code>的加入丑数集合得到<code>[1,2]</code>。</li><li>然后可以算出来丑数<code>[1*2,2*2][1*3,2*3][1*5,2*5]</code>，三组丑数中仅有<code>[1*2]</code>是重复的，因为<code>1*2</code>上一轮已经加入了丑数集合，因此本轮应该只算出丑数<code>[2*2][1*3,2*3][1*5,2*5]</code>，如何只算出这些呢？显而易见的是，2不能×丑数中的第一个数了。此时加入丑数集合的应该是<code>1*3</code>，得到<code>[1,2,3]</code></li><li>然后可以算出来丑数<code>[1*2,2*2,3*2][1*3,2*3,3*3][1*5,2*5,3*5]</code>，三组丑数中<code>[1*2][1*3]</code>是重复的，因为<code>1*2和1*3</code>之前已经加入了丑数集合，因此本轮应该只算出丑数<code>[3*2][2*3,3*3][1*5,2*5,3*5]</code>，如何只算出这些呢？显而易见的是，2和3都不能×丑数中的第一个数了。此时加入丑数集合的应该是<code>2*2</code>，得到<code>[1,2,3，4]</code></li><li>显而易见，剔除掉已经加入丑数集合的计算结果后，每次加入数组的都是算出的3组计算结果中最小的，而每组结果组内是递增的，因此我们只需要计算每组第一个未被加入丑数数组的的结果，取三者最小加入丑数集合即可。</li><li>所以我们应该维护3个指针，三个指针所指向的数分别×2、×3、×5，3者最小值就是下一个丑数。而如果计算出的下一个丑数是该指针的计算结果，则该指针需要++（因为不可重复）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 分别记录*2 *3 *5的数的下标</span></span><br><span class="line">        <span class="type">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>,idx=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;n)&#123;</span><br><span class="line">            <span class="comment">// 计算出三个指针指向丑数分别*2 *3 *5的结果</span></span><br><span class="line">            <span class="type">int</span> num2=arr[p2]*<span class="number">2</span>,num3=arr[p3]*<span class="number">3</span>,num5=arr[p5]*<span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 计算结果的最小值是下一个丑数</span></span><br><span class="line">            arr[idx]=Math.min(num2,Math.min(num3,num5));</span><br><span class="line">            <span class="comment">// 如果下一丑数是该指针的计算结果，则需要++。</span></span><br><span class="line">            <span class="comment">//  可能出现下一丑数是多个指针的计算结果的情况，则多个指针++</span></span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num2)&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num3)&#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num5)&#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-501. 二叉搜索树中的众数</title>
      <link href="/posts/c505a049.html"/>
      <url>/posts/c505a049.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><blockquote><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/image-20220226214928619.png" alt="image-20220226214928619"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,4,4,3,4,4,5,1,3]</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由题意可知，每一个节点的父节点和右节点，其值必定大于或等于当前节点值。因此中序遍历必定是非降序，即可计算出每个值出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        TreeNode last=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxCnt=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// Morris遍历，寻找左子树的最右节点</span></span><br><span class="line">            TreeNode leftRight=root.left;</span><br><span class="line">            <span class="keyword">while</span>(leftRight!=<span class="literal">null</span>&amp;&amp;leftRight.right!=<span class="literal">null</span>&amp;&amp;leftRight.right!=root)&#123;</span><br><span class="line">                leftRight=leftRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左子树最右节点为空（没有左子树），或者已经连接过了（即左子树已经遍历过）</span></span><br><span class="line">            <span class="comment">//  中序遍历，所以轮到当前节点被扫描到</span></span><br><span class="line">            <span class="keyword">if</span>(leftRight==<span class="literal">null</span>||leftRight.right==root)&#123;</span><br><span class="line">                <span class="comment">// 判断是否跟上一个扫描的节点值相同，如果相同cnt++，否则cnt设为1</span></span><br><span class="line">                <span class="keyword">if</span>(last!=<span class="literal">null</span>&amp;&amp;last.val==root.val)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果cnt&gt;maxCnt，则已经记录下的数值不是众数，clear结果集并更新maxCnt</span></span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;maxCnt)&#123;</span><br><span class="line">                    maxCnt=cnt;</span><br><span class="line">                    res.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前节点值的cnt与maxCnt一致，是暂时的众数，加入结果集</span></span><br><span class="line">                <span class="keyword">if</span>(cnt==maxCnt)&#123;</span><br><span class="line">                    res.add(root.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历右子树</span></span><br><span class="line">                last=root;</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 把左子树最右节点的right指向当前节点，然后遍历左子树</span></span><br><span class="line">                leftRight.right=root;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:res)&#123;</span><br><span class="line">            arr[cnt++]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> Morris遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-3. 无重复字符的最长子串</title>
      <link href="/posts/6c54b1f1.html"/>
      <url>/posts/6c54b1f1.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>滑动窗口，始终维护一个没有重复字符的窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录该字符上一次出现的位置（记录值是下标+1）</span></span><br><span class="line">        <span class="type">int</span> []visited=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">255</span>];</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">1</span>,res=<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> []chars=s.toCharArray();</span><br><span class="line">        <span class="comment">// 滑动窗口，begin是左边界（记录的是下标+1），i是右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="comment">// System.out.println(visited[chars[i]]);</span></span><br><span class="line">            <span class="comment">// 当前字符上一次出现位置在窗口内，则左边界要移动，移动到当前字符上一次出现位置+1</span></span><br><span class="line">            <span class="keyword">if</span>(visited[chars[i]]&gt;=begin)&#123;</span><br><span class="line">                res=Math.max(res,i-begin+<span class="number">1</span>);</span><br><span class="line">                begin=visited[chars[i]]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录位置</span></span><br><span class="line">            visited[chars[i]]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右边界出了数组的特判</span></span><br><span class="line">        res=Math.max(res,chars.length-begin+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-1642. 可以到达的最远建筑</title>
      <link href="/posts/f2bf78e0.html"/>
      <url>/posts/f2bf78e0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach">https://leetcode-cn.com/problems/furthest-building-you-can-reach</a></p><p>给你一个整数数组 <code>heights </code>，表示建筑物的高度。另有一些砖块 <code>bricks </code>和梯子<code>ladders</code>。</p><p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p><p>当从建筑物<code>i</code>移动到建筑物<code> i+1</code>（<strong>下标 从 0 开始</strong> ）时：</p><p>如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块<br>如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 <code>(h[i+1] - h[i]) </code>个砖块<br>如果以最佳方式使用给定的梯子和砖块，返回你可以到达的<strong>最远建筑物的下标</strong>（下标 从 0 开始 ）。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/q4.gif" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：从建筑物 0 出发，你可以按此方案完成旅程：</span><br><span class="line">- 不使用砖块或梯子到达建筑物 1 ，因为 4 &gt;= 2</span><br><span class="line">- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 &lt; 7</span><br><span class="line">- 不使用砖块或梯子到达建筑物 3 ，因为 7 &gt;= 6</span><br><span class="line">- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 &lt; 9</span><br><span class="line">无法越过建筑物 4 ，因为没有更多砖块或梯子。</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">输入：heights = [14,3,19,3], bricks = 17, ladders = 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>贪心，每次遇到难关先记录下如果用砖头的话，需要多少块。</p></li><li><p>如果此时有梯子，就用梯子。</p></li><li><p>如果此时没有梯子，则从前方记录下的每一关用梯子替换掉的砖头数中，取出用需要砖头数最少的位置。</p><ul><li>如果当前砖头数满足要求，则删除该记录（把该位置用砖头填上了，当前位置就可以用梯子）</li><li>如果当前砖头数量不满足要求，则无法到达，结束</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">furthestBuilding</span><span class="params">(<span class="type">int</span>[] heights, <span class="type">int</span> bricks, <span class="type">int</span> ladders)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;heights.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sub=heights[i]-heights[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(sub&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 把所需砖头树加入优先队列</span></span><br><span class="line">                queue.offer(sub);</span><br><span class="line">                <span class="comment">// 如果有梯子，先用梯子</span></span><br><span class="line">                <span class="keyword">if</span>(ladders&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ladders--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(queue.peek()&lt;=bricks)&#123;</span><br><span class="line">                     <span class="comment">// 如果没梯子了,就把之前用了梯子的一个地方，替换成砖头。要找砖头需求数最少的位置</span></span><br><span class="line">                    bricks-=queue.poll();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> i-<span class="number">1</span>;   <span class="comment">// 怎样都不能到当前位置，返回i-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heights.length-<span class="number">1</span>;    <span class="comment">//出了循环就能到达最后一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-简单（静态）工厂模式</title>
      <link href="/posts/e14d1dd7.html"/>
      <url>/posts/e14d1dd7.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>简单工厂模式（Simple Factory Pattern）又称静态工厂方法模式（Static Factory Method），属于<strong>创建型模式</strong>，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义了一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Factory：工厂角色，负责创建对象实例</li><li>Product：抽象类，是工厂生产的所有产品的基类&#x2F;接口</li><li>ConcreteProduct：具体类，有一个或多个，是工厂生产的产品类</li></ul><p><img src="http://typora.lemonchan.top/image-20220225103432166.png" alt="image-20220225103432166"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p>要求：某电视机厂专为各知名电视机品牌代工生产各类电视机，当需要海尔牌电视机时只需要在调用该工厂的工厂方法时传入参数<code>“Haier”</code>，需要海信电视机时只需要传入参数<code>“Hisense”</code>，<strong>工厂可以根据传入的不同参数返回不同品牌的电视机</strong>。现使用简单工厂模式来模拟该电视机工厂的生产过程。</p><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteProduct</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TV <span class="title function_">productTV</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.equalsIgnoreCase(<span class="string">&quot;Haier&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在生产Haier电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equalsIgnoreCase(<span class="string">&quot;Hisense&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在生产Hisense电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseTv</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            thorw <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;对不起，暂不能生产该品牌电视机!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li><p>将对象的创建和对象本身业务处理分离，降低系统耦合度，使两者都更加便于修改。</p></li><li><p>静态方法使用方便，不需要实例化工厂。</p></li><li><p>只需要传入参数即可创建对象，不需要知道实现细节。</p></li><li><p>可以把参数保存至<strong>XML配置文件</strong>中，修改时不需要修改Java源代码。</p></li></ul></li><li><p>缺点：</p><ul><li>工厂类集中了所有产品的创建逻辑，<strong>职责过重</strong>，一旦不能工作整个系统都会受影响。</li><li><strong>增加了系统中类的数量</strong>（增加了工厂类），增加系统复杂度和理解难度</li><li>系统拓展困难，一旦增加产品，就需要修改工厂类。</li><li>因为静态方法无法被继承，因此工厂类也无法形成基于继承的等级结构，工厂类不能得到很好地扩展。</li></ul></li><li><p>使用简单工厂模式的情况：</p><ul><li>工厂类负责创建的对象比较少，职责不会过重，逻辑不会过于复杂</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-149. 直线上最多的点数</title>
      <link href="/posts/229ddae5.html"/>
      <url>/posts/229ddae5.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p><blockquote><ul><li><code>1 &lt;= points.length &lt;= 300</code></li><li><code>points[i].length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li><li><code>points</code> 中的所有点 <strong>互不相同</strong></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><img src="http://typora.lemonchan.top/image-20220222214716400.png" alt="image-20220222214716400" style="zoom:50%;" /><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,1],[2,2],[3,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><img src="http://typora.lemonchan.top/image-20220222214733386.png" alt="image-20220222214733386" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>双重循环，遍历每一个点与其他定点所形成的直线的斜率，因为其一为定点，所以斜率相等即同一直线。用<code>HashMap&lt;Double,Integer&gt;</code>记录斜率对应点个数即可。</p><p>因为<code>double</code>存在精度丢失问题，可以使用<code>String</code>类型记录<code>&quot;Δy/Δx&quot;</code>作为key存入<code>HashMap&lt;String,Integer&gt;</code>（lc中本题使用Double也可通过）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储各个斜率对应的点的个数</span></span><br><span class="line">        Map&lt;Double,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有点，以该点为定点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 剩余的点数量不足以更新res，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;=points.length-i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 重置map</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="comment">// 确定定点后，遍历剩余的点，两点计算斜率，用map存储每一个斜率对应点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="comment">// 因为前面的点已经计算过其与其他各个点的斜率，即也计算了与当前点的斜率， 因此遍历从i+1开始</span></span><br><span class="line">                <span class="type">int</span> deltaX=points[j][<span class="number">0</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> deltaY=points[j][<span class="number">1</span>]-points[i][<span class="number">1</span>];</span><br><span class="line">                Double k=<span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 被除数为0，则结果为0。 但0有+0和-0两种情况，特判</span></span><br><span class="line">                <span class="keyword">if</span>(deltaY==<span class="number">0</span>)&#123;</span><br><span class="line">                    k=<span class="number">0D</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deltaX!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 除数不能为0，需要特判，刚好hashmap可以存放null key，所以设为null。</span></span><br><span class="line">                    k=(<span class="type">double</span>)deltaY/(<span class="type">double</span>)deltaX;</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="type">int</span> cnt=map.getOrDefault(k,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                res=Math.max(res,cnt);</span><br><span class="line">                map.put(k,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用String替换Double的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储各个斜率对应的点的个数</span></span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有点，以该点为定点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 剩余的点数量不足以更新res，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;=points.length-i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 重置map</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="comment">// 确定定点后，遍历剩余的点，两点计算斜率，用map存储每一个斜率对应点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="comment">// 因为前面的点已经计算过其与其他各个点的斜率，即也计算了与当前点的斜率， 因此遍历从i+1开始</span></span><br><span class="line">                <span class="type">int</span> deltaX=points[j][<span class="number">0</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> deltaY=points[j][<span class="number">1</span>]-points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 默认是除数为0状态</span></span><br><span class="line">                String k=<span class="string">&quot;max&quot;</span>;</span><br><span class="line">                <span class="comment">// 被除数为0，则结果为0。 但0有+0和-0两种情况，特判</span></span><br><span class="line">                <span class="keyword">if</span>(deltaY==<span class="number">0</span>)&#123;</span><br><span class="line">                    k=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deltaX!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 除数不为0才进行计算</span></span><br><span class="line">                    <span class="type">int</span> t=gcd(deltaX,deltaY);</span><br><span class="line">                    <span class="comment">// 除以最大公约数，化简分数</span></span><br><span class="line">                    deltaX/=t;</span><br><span class="line">                    deltaY/=t;</span><br><span class="line">                    k=deltaX+<span class="string">&quot;/&quot;</span>+deltaY;</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="type">int</span> cnt=map.getOrDefault(k,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                res=Math.max(res,cnt);</span><br><span class="line">                map.put(k,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-218. 天际线问题</title>
      <link href="/posts/7257d04d.html"/>
      <url>/posts/7257d04d.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。</p><p>每个建筑物的几何信息由数组 <code>buildings</code> 表示，其中三元组 <code>buildings[i] = [lefti, righti, heighti]</code> 表示：</p><p><code>lefti</code> 是第 <code>i</code> 座建筑物左边缘的 <code>x</code> 坐标。<br><code>righti</code> 是第 <code>i</code> 座建筑物右边缘的 <code>x</code> 坐标。<br><code>heighti </code>是第 <code>i</code> 座建筑物的高度。<br>你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。</p><p>天际线 应该表示为由 “关键点” 组成的列表，格式<code>[[x1,y1],[x2,y2],...]</code>，并按<code>x</code>坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如<code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code>是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p><blockquote><p><code>1 &lt;= buildings.length &lt;= 104</code><br><code>0 &lt;= lefti &lt; righti &lt;= 231 - 1</code><br><code>1 &lt;= heighti &lt;= 231 - 1</code><br><code>buildings</code>按<code>lefti</code>非递减排序</p></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/image-20220221113143326.png" alt="image-20220221113143326"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</span><br><span class="line">输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</span><br><span class="line">解释：</span><br><span class="line">图 A 显示输入的所有建筑物的位置和高度，</span><br><span class="line">图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings = [[0,2,3],[2,5,3]]</span><br><span class="line">输出：[[0,3],[5,0]]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>扫描线：把每个矩形转变成两条竖直边。题中所求的是，两个矩形相交位置为x坐标，两矩形高度更大者为y坐标。所以可以维护一个优先队列（大根堆），扫描线的过程中将每一条左边对应的高度入队列（矩形开始），如果遇到右边，则将对应的高度出队列（矩形结束）。因此优先队列的对头存储的始终是当前位置的最高矩形的高度，则该高度与当前位置x坐标就可以确定一个答案点（注意要忽略连续相同的高度）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getSkyline</span><span class="params">(<span class="type">int</span>[][] buildings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=buildings.length;</span><br><span class="line">        <span class="comment">//把每个矩形转变成两条竖线，记录下x坐标、高度、是矩形左边/右边 &#123;x,y,left/right&#125;</span></span><br><span class="line">        <span class="type">int</span> [][] lines=<span class="keyword">new</span> <span class="title class_">int</span>[n*<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []building:buildings)&#123;</span><br><span class="line">            <span class="comment">// 1代表左边，-1代表右边</span></span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;building[<span class="number">0</span>],building[<span class="number">2</span>],<span class="number">1</span>&#125;;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;building[<span class="number">1</span>],building[<span class="number">2</span>],-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对转换出来的竖线排序，按x坐标升序。</span></span><br><span class="line">        <span class="comment">//      如果x相同，则先排左边，再排右边。</span></span><br><span class="line">        <span class="comment">//          左边线按高度降序。 保证同一个位置，取的是最高的点</span></span><br><span class="line">        <span class="comment">//          右边线按高度升序。 保证此前最高的点，最晚出队列。</span></span><br><span class="line">                    <span class="comment">//  本质上是将高度不一，x坐标和宽度完全一致的矩形，看作是高度大的矩形包含高度小的矩形</span></span><br><span class="line">        Arrays.sort(lines,(line1,line2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(line1[<span class="number">0</span>]!=line2[<span class="number">0</span>]) <span class="keyword">return</span> line1[<span class="number">0</span>]-line2[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> line2[<span class="number">1</span>]*line2[<span class="number">2</span>]-line1[<span class="number">1</span>]*line1[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 优先队列记录此前最大高度</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeight=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((int1,int2)-&gt;int2-int1);</span><br><span class="line">        maxHeight.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 记录上一个输出的高度</span></span><br><span class="line">        <span class="type">int</span> lastHeight=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []line:lines)&#123;</span><br><span class="line">            <span class="type">int</span> x=line[<span class="number">0</span>],height=line[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 是右边界，则该高度的矩形结束一个，其对应的高度出队列</span></span><br><span class="line">            <span class="keyword">if</span>(line[<span class="number">2</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                maxHeight.remove(height);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 是左边界，其对应的高度入队列</span></span><br><span class="line">                maxHeight.offer(height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前队列中的最大值（结果高度）</span></span><br><span class="line">            <span class="type">int</span> curMaxHeight=maxHeight.peek();</span><br><span class="line">            <span class="comment">// 结果高度与上一次输出的高度不一致，输出</span></span><br><span class="line">            <span class="keyword">if</span>(curMaxHeight!=lastHeight)&#123;</span><br><span class="line">                List&lt;Integer&gt; tempList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                tempList.add(x);</span><br><span class="line">                tempList.add(curMaxHeight);</span><br><span class="line">                res.add(tempList);</span><br><span class="line">                <span class="comment">// 记录下高度</span></span><br><span class="line">                lastHeight=curMaxHeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://leetcode-cn.com/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/">【宫水三叶】扫描线算法基本思路 &amp; 优先队列维护当前最大高度</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> 扫描线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-391. 完美矩形</title>
      <link href="/posts/bb46c52a.html"/>
      <url>/posts/bb46c52a.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/perfect-rectangle">http://leetcode-cn.com/problems/perfect-rectangle</a></p><p>给你一个数组 rectangles ，其中 rectangles[i] &#x3D; [xi, yi, ai, bi] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (xi, yi) ，右上顶点是 (ai, bi) 。</p><p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。</p><blockquote><ul><li><code>1 &lt;= rectangles.length &lt;= 2 * 104</code></li><li><code>rectangles[i].length == 4</code></li><li><code>-105 &lt;= xi, yi, ai, bi &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/image-20220220230348305.png" alt="image-20220220230348305"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：5 个矩形一起可以精确地覆盖一个矩形区域。 </span><br></pre></td></tr></table></figure><p><img src="http://typora.lemonchan.top/image-20220220230620076.png" alt="image-20220220230620076"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：两个矩形之间有间隔，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><img src="http://typora.lemonchan.top/image-20220220230647964.png" alt="image-20220220230647964"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>把每一个矩形，看作是两条x坐标不一样，y的始末坐标完全一致的竖直线组成，分别是左边线和右边线，因此引入一个标志来标识这是矩形是左边线还是右边线。因此通过<code>&#123;x,yLow,yHigh,left/right&#125;</code>记录下每一个矩形。</p><p>对于一个完美矩形来说：</p><ul><li><p>非边界线：非边界线在完美矩形的内部，因此必定是多个小矩形的拼接处，那么对于每一条线，都有一条与其位置完全一样，但是属于不同小矩形的不同方向的线。即<code>x,yLow,yHigh</code>相等，<code>left/right</code>相反。</p><p><img src="http://typora.lemonchan.top/image-20220220231633077.png" alt="image-20220220231633077"></p></li><li><p>边界线（最左和最右的线）：在同一个x坐标下，只有一条连续的线</p><p><img src="http://typora.lemonchan.top/image-20220220231847774.png" alt="image-20220220231847774"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRectangleCover</span><span class="params">(<span class="type">int</span>[][] rectangles)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=rectangles.length;</span><br><span class="line">        <span class="comment">// 一个矩形可以转换成两条竖直边，每条边记录为&#123;x轴坐标，下方y轴坐标，上方y轴坐标，矩形左边还是右边（1/-1）&#125;</span></span><br><span class="line">        <span class="type">int</span> [][]lines=<span class="keyword">new</span> <span class="title class_">int</span>[n*<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把矩形转换成边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []points:rectangles)&#123;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">3</span>],<span class="number">1</span>&#125;;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;points[<span class="number">2</span>],points[<span class="number">1</span>],points[<span class="number">3</span>],-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据x坐标升序排序，x坐标相同，则按照下方y轴坐标升序排序</span></span><br><span class="line">        Arrays.sort(lines,(line1,line2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(line1[<span class="number">0</span>]!=line2[<span class="number">0</span>]) <span class="keyword">return</span> line1[<span class="number">0</span>]-line2[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> line1[<span class="number">1</span>]-line2[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 分别记录左右边，只记录同一x下的，只记录y坐标 &#123;下方y轴坐标，上方y轴坐标&#125;</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; leftList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; rightList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 每次取出x坐标相同的所有边，根据其属于矩形的左边还是右边进行分类（扫描边）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;)&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            leftList.clear();</span><br><span class="line">            rightList.clear();</span><br><span class="line">            <span class="comment">// 找出横坐标相同的边的范围,因为j初始等于i，所以至少执行一次，j&gt;i恒成立</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;<span class="number">2</span>*n&amp;&amp;lines[i][<span class="number">0</span>]==lines[j][<span class="number">0</span>]) j++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                <span class="type">int</span> []line=lines[k];</span><br><span class="line">                List&lt;<span class="type">int</span>[]&gt; tempList=line[<span class="number">3</span>]==<span class="number">1</span>?leftList:rightList;</span><br><span class="line">                <span class="comment">// 把当前遍历到的边，加入到list中</span></span><br><span class="line">                <span class="keyword">if</span>(tempList.isEmpty()) tempList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;line[<span class="number">1</span>],line[<span class="number">2</span>]&#125;);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 取出该list中，最靠近上方的边</span></span><br><span class="line">                    <span class="type">int</span> []pre=tempList.get(tempList.size()-<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 上一条边最高位置高于当前边最低位置，重叠（对于同一方向的边，有重叠则证明矩形重叠），返回false</span></span><br><span class="line">                    <span class="comment">//      （由于lines以根据边的最低位置升序排序，所以不需要判断当前边的最高位置是否大于上一条边的最低位置）</span></span><br><span class="line">                    <span class="keyword">if</span>(pre[<span class="number">1</span>]&gt;line[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 上一条边最高位置等于当前边最低位置，两条边紧邻，合并</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(pre[<span class="number">1</span>]==line[<span class="number">1</span>]) pre[<span class="number">1</span>]=line[<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span> tempList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;line[<span class="number">1</span>],line[<span class="number">2</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不是边缘，则判断是否每一条边都重合（left和right每条边始末都相等）</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j&lt;<span class="number">2</span>*n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(leftList.size()!=rightList.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;leftList.size();k++)&#123;</span><br><span class="line">                    <span class="type">int</span> []left=leftList.get(k);</span><br><span class="line">                    <span class="type">int</span> []right=rightList.get(k);</span><br><span class="line">                    <span class="keyword">if</span>(left[<span class="number">0</span>]!=right[<span class="number">0</span>]||left[<span class="number">1</span>]!=right[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 是边缘,判断是否连续且没有重叠</span></span><br><span class="line">                <span class="keyword">if</span>(leftList.size()+rightList.size()!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j肯定比i大，用来替代i++</span></span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://leetcode-cn.com/problems/perfect-rectangle/solution/gong-shui-san-xie-chang-gui-sao-miao-xia-p4q4/">【宫水三叶】常规扫描线题目</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> 扫描线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记-Spring框架</title>
      <link href="/posts/690c4485.html"/>
      <url>/posts/690c4485.html</url>
      
        <content type="html"><![CDATA[<h1 id="注解名称一、什么是Spring"><a href="#注解名称一、什么是Spring" class="headerlink" title="注解名称一、什么是Spring"></a><strong>注解名称</strong>一、什么是Spring</h1><p>Spring是一个轻量级的控制反转(IOC)和面向切面变成(AOP)的框架，可以用来整合其他框架</p><p>优点</p><ul><li>Spring是一个轻量级的，非入侵式的框架</li><li>Spring支持控制反转（IOC）和面向切面编程（AOP）</li><li>Spring支持事务管理，对框架的整合</li></ul><h1 id="二、Spring框架七大模块"><a href="#二、Spring框架七大模块" class="headerlink" title="二、Spring框架七大模块"></a>二、Spring框架七大模块</h1><p><img src="http://typora.lemonchan.top/image-20220215105840732.png" alt="image-20220215105840732"></p><ol><li>Core：<strong>核心容器</strong>。这是Spring框架最基础的部分，它提供了依赖注入（Dependency Injection）特征来实现容器对Bean的管理。这里最基本的概念是BeanFactory，它是任何Spring应用的核心。BeanFactory是工厂模式的一个实现，它使用IOC将应用配置和依赖说明从实际的应用代码中分离出来。</li><li>Context：<strong>应用上下文</strong>。核心模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。该模块还提供了一些面向服务支持这个模块扩展了BeanFactory的概念，增加了对国际化（I18N）消息、事件传播以及验证的支持。另外，这个模块还提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括对模版框架例如Velocity和FreeMarker集成的支持。</li><li>AOP：<strong>面向切面编程</strong>。Spring在它的AOP模块中提供了对面向切面编程的丰富支持。AOP允许通过分离应用的业务逻辑与系统级服务（例如安全和事务管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。<strong>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务</strong>。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li><li>ORM：<strong>对象&#x2F;关系映射集成模块</strong>。Spring 框架集成了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li>DAO：<strong>Spring DAO模块</strong>。Spring虽然集成了几个ORM产品，但也可以不选择这几款产品，因为Spring提供了JDBC和DAO模块。该模块对现有的JDBC技术进行了优化。你可以保持你的数据库访问代码干净简洁，并且可以防止因关闭数据库资源失败而引起的问题。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li>Web：<strong>Web上下文模块</strong>。建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。它也提供了Spring和其它Web框架的集成，比如Struts、WebWork。</li><li>Web MVC：<strong>Spring的MVC框架</strong>Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts2，但Spring的MVC框架使用IOC对控制逻辑和业务对象提供了完全的分离，容纳了大量视图技术，如JSP。</li></ol><h1 id="三、IOC（控制反转）"><a href="#三、IOC（控制反转）" class="headerlink" title="三、IOC（控制反转）"></a>三、IOC（控制反转）</h1><p><img src="http://typora.lemonchan.top/image-20220215114132804.png" alt="image-20220215114132804"></p><p>IOC就是<strong>对象的的创建移交给第三方</strong>，即在一个类当中不直接实例化另一个类的对象（例如：在service层中不直接new dao层对象，而是创建一个dao层接口的变量，通过这个接口变量调用dao层的各种方法实现业务逻辑。真正的dao层实例对象，是在程序运行过程中由容器提供并赋给接口变量的）。依赖注入（DI）是实 现IOC的一种方法。</p><h1 id="四、Spring使用IOC创建对象–依赖注入"><a href="#四、Spring使用IOC创建对象–依赖注入" class="headerlink" title="四、Spring使用IOC创建对象–依赖注入"></a>四、Spring使用IOC创建对象–依赖注入</h1><ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象的所有属性由容器注入</li></ul><h2 id="1、set方法注入"><a href="#1、set方法注入" class="headerlink" title="1、set方法注入"></a>1、set方法注入</h2><h3 id="1-1-复杂类型"><a href="#1-1-复杂类型" class="headerlink" title="1.1 复杂类型"></a>1.1 复杂类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-bean测试对象"><a href="#1-2-bean测试对象" class="headerlink" title="1.2 bean测试对象"></a>1.2 bean测试对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="comment">/*省略get set方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-applicationContext-xml"><a href="#1-3-applicationContext-xml" class="headerlink" title="1.3 applicationContext.xml"></a>1.3 applicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;广东省佛山市南海区华南师范大学南海校区&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--普通值注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--bean注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--Array注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>深入理解Java虚拟机<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Effective Java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>unix环境高级编程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--list注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打游戏<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打代码<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--map注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;440000000011112039&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;校园卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;201833330000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;银行卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2341212342134123423&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--set注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>NBA2K<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>地平线4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--null注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--properties注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;url&quot;</span>&gt;</span>www.lemonchan.top<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>Lemon Chan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;telephone&quot;</span>&gt;</span>13131313131<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-测试类"><a href="#1-4-测试类" class="headerlink" title="1.4 测试类"></a>1.4 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    System.out.println(context.getBean(<span class="string">&quot;student&quot;</span>));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Student&#123;</span></span><br><span class="line"><span class="comment">    *   name=&#x27;张三&#x27;,</span></span><br><span class="line"><span class="comment">    *   address=Address&#123;address=&#x27;广东省佛山市南海区华南师范大学南海校区&#x27;&#125;, </span></span><br><span class="line"><span class="comment">    *   books=[深入理解Java虚拟机, Effective Java, unix环境高级编程], </span></span><br><span class="line"><span class="comment">    *   hobbies=[打游戏, 看书, 打代码], </span></span><br><span class="line"><span class="comment">    *   card=&#123;</span></span><br><span class="line"><span class="comment">    *       身份证=440000000011112039, </span></span><br><span class="line"><span class="comment">    *       校园卡=201833330000, </span></span><br><span class="line"><span class="comment">    *       银行卡=2341212342134123423</span></span><br><span class="line"><span class="comment">    *   &#125;, </span></span><br><span class="line"><span class="comment">    *   games=[NBA2K, 地平线4], wife=&#x27;null&#x27;, </span></span><br><span class="line"><span class="comment">    *   info=&#123;telephone=13131313131, </span></span><br><span class="line"><span class="comment">    *       url=www.lemonchan.top, </span></span><br><span class="line"><span class="comment">    *       username=Lemon Chan</span></span><br><span class="line"><span class="comment">    *   &#125;</span></span><br><span class="line"><span class="comment">    * &#125;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、构造器注入"><a href="#2、构造器注入" class="headerlink" title="2、构造器注入"></a>2、构造器注入</h2><h3 id="2-1、无参构造方法创建"><a href="#2-1、无参构造方法创建" class="headerlink" title="2.1、无参构造方法创建"></a>2.1、无参构造方法创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2、构造方法参数下标构造"><a href="#2-2、构造方法参数下标构造" class="headerlink" title="2.2、构造方法参数下标构造"></a>2.2、构造方法参数下标构造</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3、参数类型构造（不建议使用）"><a href="#2-3、参数类型构造（不建议使用）" class="headerlink" title="2.3、参数类型构造（不建议使用）"></a>2.3、参数类型构造（不建议使用）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4、参数名构造"><a href="#2-4、参数名构造" class="headerlink" title="2.4、参数名构造"></a>2.4、参数名构造</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bb&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件加载时，Spring容器就会实例化bean，而默认情况下通过ApplicationContext获取到的同一id的bean对象，都是同一个对象（即一个id对应一个bean对象）。</p><h2 id="3、拓展方式注入"><a href="#3、拓展方式注入" class="headerlink" title="3、拓展方式注入"></a>3、拓展方式注入</h2><ul><li>两种拓展注入方式只能注入普通值和bean对象</li></ul><h3 id="3-1、p命名空间"><a href="#3-1、p命名空间" class="headerlink" title="3.1、p命名空间"></a>3.1、p命名空间</h3><ul><li><code>p:key=&quot;value&quot;</code>实现了了<code>&lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt;</code>的功能</li><li><code>p:key-ref=&quot;value&quot;</code>实现了了<code>&lt;property name=&quot;key&quot; ref=&quot;value&quot;/&gt;</code>的功能</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--beans标签需要加上的属性--&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Address&quot;</span> <span class="attr">p:address</span>=<span class="string">&quot;广东省佛山市南海区华南师范大学南海校区&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">p:address-ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2、c命名空间"><a href="#3-2、c命名空间" class="headerlink" title="3.2、c命名空间"></a>3.2、c命名空间</h3><ul><li><code>c:key=&quot;value&quot;</code>实现了了<code>&lt;constructor-arg name=&quot;key&quot; value=&quot;value&quot;/&gt;</code>的功能</li><li><code>c:key-ref=&quot;value&quot;</code>实现了了<code>&lt;constructor-arg name=&quot;key&quot; ref=&quot;value&quot;/&gt;</code>的功能</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--beans标签需要加上的属性--&gt;</span></span><br><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">c:aa</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">c:bb-ref</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">c:_0</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">c:_1-ref</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="五、Spring常用配置"><a href="#五、Spring常用配置" class="headerlink" title="五、Spring常用配置"></a>五、Spring常用配置</h1><h2 id="1、bean"><a href="#1、bean" class="headerlink" title="1、bean"></a>1、bean</h2><ul><li>id：bean的唯一标识符</li><li>class：bean对象对应的全限类名</li><li>name：与alias类似，给bean对象取别名，而且<strong>可以同时有多个别名</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2 hello3&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、alias"><a href="#2、alias" class="headerlink" title="2、alias"></a>2、alias</h2><p>配置了alias后，可以通过alias获取bean对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;aliasHello&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name：bean的id</li><li>alias：bean的别名</li></ul><h2 id="3、import"><a href="#3、import" class="headerlink" title="3、import"></a>3、import</h2><p>将多个配置文件导入合并到当前xml文件中。多用于团队开发</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;helloWord&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="六、bean的作用域"><a href="#六、bean的作用域" class="headerlink" title="六、bean的作用域"></a>六、bean的作用域</h1><h2 id="1、singleton–单例模式"><a href="#1、singleton–单例模式" class="headerlink" title="1、singleton–单例模式"></a>1、singleton–单例模式</h2><p>Spring的bean对象作用域默认是singleton。每次从容器中getBean() 都是同一个对象</p><p><img src="http://typora.lemonchan.top/image-20220215235010967.png" alt="image-20220215235010967"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、prototype"><a href="#2、prototype" class="headerlink" title="2、prototype"></a>2、prototype</h2><p>每次从容器中getBean() 都是不同对象</p><p><img src="http://typora.lemonchan.top/image-20220215235316311.png" alt="image-20220215235316311"></p><h2 id="3、request、session、application、websocket用于web开发中"><a href="#3、request、session、application、websocket用于web开发中" class="headerlink" title="3、request、session、application、websocket用于web开发中"></a>3、request、session、application、websocket用于web开发中</h2><h1 id="七、Bean的自动装配"><a href="#七、Bean的自动装配" class="headerlink" title="七、Bean的自动装配"></a>七、Bean的自动装配</h1><h2 id="1、byName自动装配"><a href="#1、byName自动装配" class="headerlink" title="1、byName自动装配"></a>1、byName自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--会在容器上下文中查找，找到与自己对象的set方法后面的变量名对应的beanId进行自动装配</span></span><br><span class="line"><span class="comment">例如：Person类有一个setDog方法，则会找到beanId未dog的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">要求容器上下文中所有bean的id唯一，且id要与set方法后面的变量名一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;张三&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、byType自动装配"><a href="#2、byType自动装配" class="headerlink" title="2、byType自动装配"></a>2、byType自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--会在容器上下文中查找，找到与自己对象属性的类型对应的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">例如：Person对象有一个Dog类型的属性，则会找到class=“Dog”的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">要求容器上下文中只有一个该类型的bean对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;张三&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、注解实现自动装配"><a href="#3、注解实现自动装配" class="headerlink" title="3、注解实现自动装配"></a>3、注解实现自动装配</h2><p>准备工作</p><ol><li>导入约束：xmlns:context</li><li>配置注解支持标签：<code>&lt;context:annotation-config/&gt;</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@Autowired</strong><br>直接在属性上使用即可，不需要set方法。也可以在set方法上使用<br>使用Autowired的前提是这个自动装配的属性在IOC容器中存在，**@Autowired先使用byType方式注入，如果存在多个相同类型bean，则根据id注入**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required= false )</span> <span class="comment">// 说明这个对象可以为null，即找不到bean注入也报错</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value= &quot;dog222&quot;)</span><span class="comment">// 使用@Qualifier注解配合使用，指定beanId进行注入（Type和Name都满足才能注入）</span></span><br><span class="line"><span class="keyword">private</span> Dog dog; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用byName，找不到则使用byType，可以通过参数指定type和name</span></span><br><span class="line"><span class="meta">@Resource(type = Cat.class,name = &quot;cat123&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><h1 id="八、使用注解开发"><a href="#八、使用注解开发" class="headerlink" title="八、使用注解开发"></a>八、使用注解开发</h1><ul><li>使用注解开发前，需要导入Spring-AOP包</li><li>开启注解包扫描，指定要扫描的包<code>&lt;context:component-scan base-package=&quot;com.lemon.pojo&quot;/&gt;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span> <span class="comment">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot; scope=&quot;singleton&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span><span class="comment">//等价于&lt;property name=&quot;name&quot; value=&quot;lemon&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Component的衍生注解：功能与@Component一致，都是将某个类装装配成bean。</p><ul><li>@Component–用于pojo</li><li>@Reposity–用于dao层</li><li>@Service–用于service层</li><li>@Controller–用于controller层</li></ul><p>总结：</p><ul><li>xml更加万能，适用于各种场合，维护简单</li><li>注解更加方便，不是自己的类使用不了，维护更复杂</li><li>常用实践：<ul><li>使用xml管理bean</li><li>使用注解完成属性注入（@Value）</li></ul></li></ul><h1 id="九、AppConfig"><a href="#九、AppConfig" class="headerlink" title="九、AppConfig"></a>九、AppConfig</h1><p>完全使用Java配置Spring（无xml），实质上是用Java类来替代xml文件。配置类需要用@Configuration声明。</p><p>xml配置后用<code>ClassPathXmlApplicationContext(&quot;path&quot;)</code>获取IOC容器，**@Configuration声明的配置类用<code>AnnotationConfigApplicationContext(Class&lt;?&gt;)</code>获取IOC容器**。</p><p>使用@Import(Class&lt;?&gt; [])注解来引入其他的配置类</p><p>使用@ImportResource(String [])注解来引入xml配置文件</p><p><strong>使用@Configuration声明配置类时有两种方法生成（注册）Bean</strong></p><ol><li><p>在配置类中定义一个方法，使用@Bean注解。方法返回值对应class，方法名对应beanId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">// 等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在需要注册的类上使用@Component注解，在配置类上使用@ComponentScan(“包”)开启包扫描（也可以用@ComponentScans(value&#x3D;”@ComponentScan数组”) 开启多个包扫描）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//等价于&lt;context:component-scan base-package=&quot;com.lemon.pojo&quot;/&gt;</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lemon.pojo&quot;)</span></span><br><span class="line"><span class="comment">//与上面等价 @ComponentScans(value=&#123;@ComponentScan(&quot;com.lemon.pojo&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果上述两种方法都使用，会创建两个Bean对象</p></li></ol><h1 id="十、代理模式"><a href="#十、代理模式" class="headerlink" title="十、代理模式"></a>十、代理模式</h1><p>代理模式即在不修改原有代码的基础上对原有功能进行增强。符合开闭原则。</p><h2 id="1、静态代理"><a href="#1、静态代理" class="headerlink" title="1、静态代理"></a>1、静态代理</h2><p>角色分析：</p><ul><li>抽象角色：一般使用接口或抽象类来解决，真实角色与代理角色都继承（实现）抽象角色。</li><li>真实角色：<strong>被代理</strong>的角色</li><li>代理角色：<strong>代理</strong>真实角色的角色，代理真实角色后，一般会做一些附属操作（比如权限检验）</li><li>客户：<strong>访问</strong>代理角色的角色</li></ul><p>优点：</p><ul><li>使真实角色的操作更加纯粹，不用去关注一些公共业务。（比如权限检验）</li><li>公共业务交给了代理角色，解耦。</li><li>公共业务发生拓展的时候，方便集中管理。（比如增加一个权限角色）</li></ul><p>缺点：</p><ul><li>一个真实角色就会产生一个代理角色，代码量翻倍，开发效率变低</li></ul><h2 id="2、动态代理"><a href="#2、动态代理" class="headerlink" title="2、动态代理"></a>2、动态代理</h2><ul><li>动态代理的角色与静态代理一致</li><li>动态代理的代理类是动态生成的，不是直接写好的</li><li>动态代理实现方法主要分为三类：<ul><li>基于接口的动态代理：JDK动态代理</li><li>基于类的动态代理：cglib</li><li>基于Java字节码：Javassist</li></ul></li></ul><h3 id="2-1、JDK的动态代理实现"><a href="#2-1、JDK的动态代理实现" class="headerlink" title="2.1、JDK的动态代理实现"></a>2.1、JDK的动态代理实现</h3><h4 id="2-1-1、Proxy类"><a href="#2-1-1、Proxy类" class="headerlink" title="2.1.1、Proxy类"></a>2.1.1、Proxy类</h4><p><img src="http://typora.lemonchan.top/image-20220216160801622.png" alt="image-20220216160801622"></p><p>用静态方法来获取代理类</p><h4 id="2-1-2、InvocationHandler接口"><a href="#2-1-2、InvocationHandler接口" class="headerlink" title="2.1.2、InvocationHandler接口"></a>2.1.2、InvocationHandler接口</h4><p>实现该接口的类称为处理机类，必须实现invoke方法。</p><p>使用该<code>处理机类的实例对象ih</code>生成<code>代理对象A</code>，A调用的任何方法，实质上都是通过反射获取到Method对象，然后交由给ih的invoke方法执行。</p><p>生成代理对象的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * classLoader:真实对象的类加载器</span></span><br><span class="line"><span class="comment"> * interfaces:需要代理的接口（真实对象中只有这些接口对应的方法才会被代理，生成的代理对象中只有这些接口对应的方法）</span></span><br><span class="line"><span class="comment"> * invocationHandler: 处理机对象，实现代理增加功能的关键！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Proxy.newProxyInstance(classLoader,<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]interfaces,invocationHandler);</span><br></pre></td></tr></table></figure><p><strong>特别注意</strong>：生成的代理对象<code>A</code>是接口对象，只有<code>interfaces</code>接口对应的方法</p><h4 id="2-1-3、demo"><a href="#2-1-3、demo" class="headerlink" title="2.1.3、demo"></a>2.1.3、demo</h4><ol><li><p>自定义InvocationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个处理机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">getUserService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceInvocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceInvocationHandler</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        check();</span><br><span class="line">        Object res=method.invoke(userService,args);</span><br><span class="line">        log(method.getName());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行权限检验&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;日志：执行了&quot;</span>+msg+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String arg)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insert业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;update业务,参数为：&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;select业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>client应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//        真实对象</span></span><br><span class="line">        UserServiceImpl userService=<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="comment">//        调用处理器，实现invoke方法，通过该调用处理器生成的代理对象，其调用方法都会使用这个invoke方法进行调用</span></span><br><span class="line">        UserServiceInvocationHandler invocationHandler=<span class="keyword">new</span> <span class="title class_">UserServiceInvocationHandler</span>(userService);</span><br><span class="line"><span class="comment">//        通过Proxy的静态方法，使用invocationHandler生成动态代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取代理对象</span></span><br><span class="line"><span class="comment">         * 真实对象的类加载器、代理对象代理的接口、处理机对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        UserService userService2= (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;UserService.class&#125;,invocationHandler);</span><br><span class="line"><span class="comment">//        通过代理对象调用方法</span></span><br><span class="line">        userService2.update(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* userService2.update(&quot;123&quot;); 等价于下面两行代码*/</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> invocationHandler.getUserService().getClass().getDeclaredMethod(<span class="string">&quot;update&quot;</span>, <span class="string">&quot;123&quot;</span>.getClass());</span><br><span class="line">        invocationHandler.invoke(userService2,method,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;123&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*newMethod()方法不是接口方法，因此userService2中没有该方法！*/</span></span><br><span class="line">        userService.newMethod();</span><br><span class="line"><span class="comment">//        userService2.newMethod(); //不存在该方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>项目结构</p><p><img src="http://typora.lemonchan.top/image-20220221091953436.png" alt="image-20220221091953436"></p></li></ol><h3 id="2-2、动态代理的好处"><a href="#2-2、动态代理的好处" class="headerlink" title="2.2、动态代理的好处"></a>2.2、动态代理的好处</h3><ul><li>使真实角色的操作更加纯粹，不用去关注一些公共业务。（比如权限检验）</li><li>公共业务交给了代理角色，解耦。</li><li>公共业务发生拓展的时候，方便集中管理。（比如增加一个权限角色）</li><li>一个动态代理类代理的是一个&#x2F;多个接口，一般就是对应一类业务。</li><li>一个动态代理类可以代理多个类，只要是实现了同一接口</li></ul><h1 id="十一、AOP"><a href="#十一、AOP" class="headerlink" title="十一、AOP"></a>十一、AOP</h1><h2 id="1、什么是AOP"><a href="#1、什么是AOP" class="headerlink" title="1、什么是AOP"></a>1、什么是AOP</h2><p> AOP即面向切面编程（Aspect Oriented Program） 。使用面向对象编程，降低了代码的复杂程度，使类可重用，但也增加了代码的重复性。例如：每个类都需要做日志，那按面向对象的设计方法，需要在两个类的方法中都加入日志的内容。也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<strong>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong></p><p><img src="http://typora.lemonchan.top/image-20220216225246039.png" alt="image-20220216224738230"></p><h2 id="2、AOP在Spring中的作用"><a href="#2、AOP在Spring中的作用" class="headerlink" title="2、AOP在Spring中的作用"></a>2、AOP在Spring中的作用</h2><p><strong>提供声明式事务；允许用户自定义切面</strong></p><ul><li>横切关注点：影响应用多处的功能（日志、权限检验等）</li><li>通知（Adivce）：切面要完成的工作</li><li>连接点（JoinPoint）：应用程序执行过程中能插入切面的点（方法执行时，抛出错误时、方法返回时）</li><li>切点（PointCut）：定义通知被应用的位置（哪些方法需要织入切面）</li><li>切面（ASPECT）：通知和切点的集合</li><li>引入（Intorduction）：允许在现有的实现类中添加自定义的方法和属性。</li><li>目标（Target）：被通知的对象（动态代理中的真实对象）</li><li>代理（Proxy）：想目标对象应用通知后创建的对象（动态代理中的代理对象）</li><li>织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。Spring AOP框架默认采用动态代理织入，而AspectJ（基于Java语言的AOP框架）采用编译器织入和类装载期织入。</li></ul><p><img src="http://typora.lemonchan.top/image-20220216224738230.png" alt="image-20220216225246039"></p><p>SpringAOP中，通过Advice定义不同连接点的通知</p><table><thead><tr><th>通知类型</th><th>连接点</th><th>实现接口(org.springframework.aop.*)</th></tr></thead><tbody><tr><td>前置通知</td><td>方法前</td><td>MethonBeforeAdvice</td></tr><tr><td>后置通知</td><td>方法后</td><td>AfterReturningAdvice</td></tr><tr><td>环绕通知</td><td>方法前后</td><td>MethodInterceptor</td></tr><tr><td>异常抛出通知</td><td>方法抛出异常</td><td>ThrowAdvice</td></tr><tr><td>引介通知</td><td>类中增加新的方法属性</td><td>IntroductionInterceptor</td></tr></tbody></table><h2 id="3、使用Spring实现AOP"><a href="#3、使用Spring实现AOP" class="headerlink" title="3、使用Spring实现AOP"></a>3、使用Spring实现AOP</h2><h3 id="3-1、使用Spring的API接口"><a href="#3-1、使用Spring的API接口" class="headerlink" title="3.1、使用Spring的API接口"></a>3.1、使用Spring的API接口</h3><ol><li><p>自定义一个类，实现<code>AfterReturningAdive</code>接口（可以实现多个接口），即定义了一个<strong>连接点</strong>为方法返回时的<strong>通知</strong>，<code>afterReturning()</code>方法是通知的具体内容。并通过<code>@Component</code>注解将该切面注册到Spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterLog</span> <span class="keyword">implements</span> <span class="title class_">AfterReturningAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+method.getName()+<span class="string">&quot;方法，返回结果为&quot;</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml配置文件中配置AOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AOP，需要导入命名空间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点：在些方法执行 expression=&quot;execution(要执行的位置 方法修饰词 包名.类名 方法名 方法参数)&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行环绕增加</span></span><br><span class="line"><span class="comment">_ advice-ref:Spring容器中的切面beanID  pointcut-ref：已配置的切入点</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2、自定义类实现AOP"><a href="#3-2、自定义类实现AOP" class="headerlink" title="3.2、自定义类实现AOP"></a>3.2、自定义类实现AOP</h3><ol><li><p>自定义一个切面类，无需实现任何接口。在类中定义若干个方法作为<strong>通知</strong>。并通过<code>@Component</code>注解将该切面注册到Spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;diy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyPointCut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========方法执行前========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========方法执行后========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml配置文件中配置AOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--把beanID为diy的bean对象作为切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--切入点：在哪些方法执行  expression=&quot;execution(要执行的位置  方法修饰词 包名.类名.方法名(方法参数))&quot;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义连接点，before、after、...   method=该连接点用哪个通知（切面类中的方法） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>两种方法异同：</strong></p><ul><li>方法一在切面类中就已经规定好连接点，特定的方法名对应不同连接点。</li><li>方法二在xml配置文件中定义连接点，方法名与连接点之间无关。</li></ul><h3 id="3-3、注解实现"><a href="#3-3、注解实现" class="headerlink" title="3.3、注解实现"></a>3.3、注解实现</h3><ol><li><p>自定义一个切面类，不实现任何的接口。用<code>@Aspect</code>标记这是一个切面类。然后使用<code>@Component</code>将该切面类注册到Spring容器中。在类中定义若干个方法作为<strong>通知</strong>，并使用<code>@Before、@Around</code>等标记方法进行连接点和切点的定义。</p><p><strong>注意</strong>：一个方法只能有一个连接点-切入点注解生效，生效的是连接点最前的注解。例如在同一个方法同时使用了<code>@After @Before</code>，则生效的是<code>Before</code>，因为<code>@Before</code>是切点（方法执行）前执行，而<code>@After</code>是切点（方法执行）后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 把这个自定义切面注册到Spring容器中</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationPointCut</span> &#123;</span><br><span class="line">    <span class="comment">//  同时配置连接点（Before、After、...） 和切入点（execution()）</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======方法执行前=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  使用已定义的切点进行配置</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut1()&quot;)</span></span><br><span class="line">    <span class="comment">//  在环绕增强中，我们可以给定一个ProceedingJoinPoint参数，用来获取被 应用通知 的点（如：方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed(); <span class="comment">//        执行方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml配置文件中开启aop注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!--开启AOP注解  </span></span><br><span class="line"><span class="comment">--proxy-target-class=&quot;false&quot;  采用JDK方式实现动态代理/AOP  </span></span><br><span class="line"><span class="comment">--proxy-target-class=&quot;true&quot;   采用cglib的方式实现动态代理/AOP--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>常用AOP注解</p><table><thead><tr><th><strong>注解名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>@Aspect</td><td>用于定义一个切面，注解在切面类上</td></tr><tr><td>@Pointcut</td><td>用于定义切入点表达式。在使用时，需要定义一个切入点方法。该方法是一个返回值void，且方法体为空的普通方法，方法名()即切点名</td></tr><tr><td>@Before</td><td>用于定义前置通知。在使用时，通常为其指value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@AfterReturning</td><td>用于定义后置返回通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@Around</td><td>用于定义环绕通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@AfterThrowing</td><td>用于定义异常通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式。另外，还有一个throwing属性用于访问目标方法抛出的异常，该属性值与异常通知方法中同名的形参一致</td></tr><tr><td>@Aftter</td><td>用于定义后置（最终）通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr></tbody></table></li></ol><h1 id="十二、整合MyBatis"><a href="#十二、整合MyBatis" class="headerlink" title="十二、整合MyBatis"></a>十二、整合MyBatis</h1><blockquote><p>待补充</p></blockquote><h1 id="十三、声明式事务"><a href="#十三、声明式事务" class="headerlink" title="十三、声明式事务"></a>十三、声明式事务</h1><blockquote><p>待补充</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://www.bilibili.com/video/BV1WE411d7Dv">【狂神说Java】Spring5最新完整教程IDEA版通俗易懂</a></p><p><a href="http://blog.csdn.net/qq_33082731/article/details/75066956">Spring的七大模块，以及每个模块的作用</a></p><p><a href="http://zhuanlan.zhihu.com/p/40784174">Java编程—Spring框架七大模块</a></p><p><a href="http://baike.baidu.com/item/spring%E6%A1%86%E6%9E%B6/2853288?fr=aladdin">Spring框架-百度百科</a></p><p><a href="http://docs.spring.io/spring-framework/docs/current/reference/html/core.html">Spring官方文档</a></p><p><a href="http://www.iteye.com/blog/hejiajunsh-1776569">JavaWeb过滤器.监听器.拦截器-原理&amp;区别-个人总结</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-200. 岛屿数量</title>
      <link href="/posts/5ad2b77.html"/>
      <url>/posts/5ad2b77.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></p><p>给你一个由<code> &#39;1&#39;</code>（陆地）和<code> &#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><blockquote><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>两种思路：</p><ul><li>使用并查集把所有为<code>1</code>的节点连接起来，用<code>parent</code>数组记录，最后遍历<code>parent</code>数组查询有多少个<code>parent[i]=[i]</code></li><li>dfs&#x2F;bfs遍历所有<code>1</code>节点，把遍历到的节点修改成<code>0</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> []parent=<span class="keyword">new</span> <span class="title class_">int</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>) parent[i*grid[<span class="number">0</span>].length+j]=i*grid[<span class="number">0</span>].length+j;</span><br><span class="line">               <span class="keyword">else</span> parent[i*grid[<span class="number">0</span>].length+j]=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 上</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;grid[i-<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> now=getParent(parent,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="type">int</span> up=getParent(parent,(i-<span class="number">1</span>)*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="keyword">if</span>(now!=up)&#123;</span><br><span class="line">                        parent[now]=up;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>&amp;&amp;grid[i][j-<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> now=getParent(parent,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="type">int</span> left=getParent(parent,i*grid[<span class="number">0</span>].length+j-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(now!=left)&#123;</span><br><span class="line">                        parent[now]=left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;parent.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i]==i) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> []parent,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[index]!=index)&#123;</span><br><span class="line">            parent[index]=getParent(parent,parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs和dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[i].length;j++)&#123;</span><br><span class="line">                <span class="comment">/*bfs*/</span></span><br><span class="line">                <span class="comment">// if(grid[i][j]==&#x27;1&#x27;) bfs(grid,i,j);</span></span><br><span class="line">                <span class="comment">/*dfs*/</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span> [][]grid,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;=grid.length||col&lt;<span class="number">0</span>||col&gt;=grid[<span class="number">0</span>].length||grid[row][col]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> [] arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        grid[row][col]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            dfs(grid,row+arr[i-<span class="number">1</span>],col+arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="type">int</span> cols=grid[<span class="number">0</span>].length;</span><br><span class="line">        Deque&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(row*cols+col);</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> index=queue.poll();</span><br><span class="line">            row=index/cols;</span><br><span class="line">            col=index%cols;</span><br><span class="line">            <span class="keyword">if</span>(grid[row][col]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            grid[row][col]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line">            <span class="keyword">if</span>(row&gt;<span class="number">0</span>&amp;&amp;grid[row-<span class="number">1</span>][col]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index-cols);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span>(col&gt;<span class="number">0</span>&amp;&amp;grid[row][col-<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">if</span>(row&lt;grid.length-<span class="number">1</span>&amp;&amp;grid[row+<span class="number">1</span>][col]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index+cols);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(col&lt;cols-<span class="number">1</span>&amp;&amp;grid[row][col+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index+<span class="number">1</span>);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-8. 字符串转换整数 (atoi)</title>
      <link href="/posts/263d0e65.html"/>
      <url>/posts/263d0e65.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi">https://leetcode-cn.com/problems/string-to-integer-atoi</a></p><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li><li>返回整数作为最终结果。</li></ol><blockquote><ul><li><p>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</p></li><li><p>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</p></li><li><p><code>0 &lt;= s.length &lt;= 200</code></p></li><li><p><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</p></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>模拟题，多设计样例进行边界测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除前导空格</span></span><br><span class="line">        s=s.trim();</span><br><span class="line">        <span class="comment">// 转换成char数组遍历更快</span></span><br><span class="line">        <span class="type">char</span> []chars=s.toCharArray();</span><br><span class="line">        <span class="comment">// 去除前导空格后为空串，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(chars.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录正负</span></span><br><span class="line">        <span class="type">int</span> direction=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 判断第一位是否是正负号，如果是负号则修改direction</span></span><br><span class="line">        <span class="keyword">if</span>(chars[i]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            direction=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历计算连续值（前导0在计算过程中会自动去除）</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;chars.length)&#123;</span><br><span class="line">            <span class="comment">// 遇到非数字字节跳出遍历</span></span><br><span class="line">            <span class="keyword">if</span>(chars[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;chars[i]&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                res=res*<span class="number">10</span>+(<span class="type">int</span>)(chars[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超过int类型就跳出（根据正负号分别进行判断）</span></span><br><span class="line">            <span class="keyword">if</span>(direction==<span class="number">1</span>&amp;&amp;res&gt;=Integer.MAX_VALUE)&#123;</span><br><span class="line">                res=Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==-<span class="number">1</span>&amp;&amp;res&gt;Integer.MAX_VALUE)&#123;</span><br><span class="line">                res=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) res*direction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-215. 数组中的第K个最大元素.md</title>
      <link href="/posts/b783d239.html"/>
      <url>/posts/b783d239.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><blockquote><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要找到第k大的元素，就要找到k-1个比他大的元素。可以用堆排序、快排变式来快速解题</p><ul><li>快排变式：降序快排，快排调用<code>partition()</code>方法得到分割点坐标<code>mid</code>后，跟<code>k</code>进行比较，如果等于<code>k-1</code>，则<code>nums[mid]</code>就是结果，如果<code>mid&gt;k-1</code>则对<code>[begin,mid-1]</code>进行快排，否则对<code>[mid+1,end]</code>进行快排。运用了剪枝思想，把不需要排序的部分剪掉。</li><li>堆排序：构建一个<code>大小为k</code>的小根堆，存放最大的<code>k</code>个元素，先把<code>nums[0]~nums[k-1]</code>放入堆中，然后从<code>nums[k]</code>开始遍历，如果遍历到的元素比堆顶大，则其替换掉堆顶，并重新整理堆。遍历完成以后，堆顶元素则是堆的<code>k</code>个元素中最小的一个，刚好是第<code>k</code>大的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写堆排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 存放堆的数组，左节点=父节点*2+1,右节点=父节点*2+2</span></span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">// 原数组前k个元素入堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            res[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建小根堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(k-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            heapSort(res,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历元素，入堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;res[<span class="number">0</span>])&#123;</span><br><span class="line">                res[<span class="number">0</span>]=nums[i];</span><br><span class="line">                heapSort(res,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> []arr,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">// 左节点不存在，则不需要调整当前节点位置</span></span><br><span class="line">        <span class="keyword">if</span>(index*<span class="number">2</span>+<span class="number">1</span>&gt;=arr.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右节点存在且右节点更小，则当前节点与右节点比较（left++后就是右节点下标）</span></span><br><span class="line">        <span class="keyword">if</span>(left+<span class="number">1</span>&lt;arr.length&amp;&amp;arr[left]&gt;arr[left+<span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&lt;arr[index])&#123;</span><br><span class="line">            <span class="comment">// 交换并对交换后的子节点堆化</span></span><br><span class="line">            <span class="type">int</span> temp=arr[left];</span><br><span class="line">            arr[left]=arr[index];</span><br><span class="line">            arr[index]=temp;</span><br><span class="line">            heapSort(arr,left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用优先队列完成堆排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; priorityQueue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            priorityQueue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;priorityQueue.peek())&#123;</span><br><span class="line">                priorityQueue.poll();</span><br><span class="line">                priorityQueue.offer(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priorityQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排+剪枝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findK(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findK</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> begin,<span class="type">int</span> end,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=partition(nums,begin,end);</span><br><span class="line">        <span class="keyword">if</span>(mid==k-<span class="number">1</span>) <span class="keyword">return</span> nums[mid];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;k) <span class="keyword">return</span> findK(nums,mid+<span class="number">1</span>,end,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> findK(nums,begin,mid-<span class="number">1</span>,k);     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> target=nums[begin];</span><br><span class="line">        <span class="type">int</span> i=begin+<span class="number">1</span>,j=end;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j&amp;&amp;nums[i]&gt;=target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j&amp;&amp;nums[j]&lt;target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;j) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,begin,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link href="/posts/c60dd476.html"/>
      <url>/posts/c60dd476.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a></p><p>给你二叉树的根节点 root 和一个整数目标和 <code>targetSum </code>，<strong>找出所有 从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/image-20220214204233529.png" alt="image-20220214204233529"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p><img src="https://typora.lemonchan.top/image-20220214204305011.png" alt="image-20220214204305011"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dfs+回溯。前序遍历树，记录路径节点和，判断节点是否为叶子节点，如果是，则继续判断路径和是否&#x3D;target</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tempList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        dfs(root,<span class="number">0</span>,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> sum,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="comment">// 空节点返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        <span class="comment">// 修改路径</span></span><br><span class="line">        tempList.add(root.val);</span><br><span class="line">        <span class="comment">// 到达了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 存储到结果中，要新建一个List存放</span></span><br><span class="line">            <span class="keyword">if</span>(sum==target) res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(tempList));</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs</span></span><br><span class="line">        dfs(root.left,sum,target);</span><br><span class="line">        dfs(root.right,sum,target);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-881. 救生艇</title>
      <link href="/posts/7c2a7986.html"/>
      <url>/posts/7c2a7986.html</url>
      
        <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><a href="https://leetcode-cn.com/problems/boats-to-save-people">https://leetcode-cn.com/problems/boats-to-save-people</a></p><p>给定数组 <code>people </code>。<code>people[i]</code>表示第 <code>i </code>个人的体重 ，船的数量不限，每艘船可以承载的最大重量为<code> limit</code>。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。</p><p>返回 承载所有人所需的最小船数 。</p><blockquote><ul><li><code>1 &lt;= people.length &lt;= 5 * 104</code></li><li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 104</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [1,2], limit = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：1 艘船载 (1, 2)</span><br><span class="line"></span><br><span class="line">输入：people = [3,2,2,1], limit = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：3 艘船分别载 (1, 2), (2) 和 (3)</span><br><span class="line"></span><br><span class="line">输入：people = [3,5,3,4], limit = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：4 艘船分别载 (3), (3), (4), (5)</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为<code>people[i]&lt;=limit</code>，该船最多只能坐两人，至少能坐一人，贪心思想，每次先把重量最大的人放上船，然后找重量最小的人，看能不能也放上船。</p><p>将<code>people</code>排序后，用两个指针分别指向当前重量最小和重量最大的人，双指针扫描。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>[] people, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="comment">// 本题limit较小，可以使用桶排序，时间复杂度降为O(n)</span></span><br><span class="line">        Arrays.sort(people);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=people.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(people[i]+people[j--]&lt;=limit)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-452. 用最少数量的箭引爆气球</title>
      <link href="/posts/80e00419.html"/>
      <url>/posts/80e00419.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为<code> xstart，xend</code>， 且满足 <code> xstart ≤ x ≤ xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组<code>points</code>，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br><span class="line"></span><br><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：points = [[1,2]]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：points = [[2,3],[2,3]]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：points = [[2,3],[1,3],[5,8],[6,10],[9,10]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>气球被击中的条件是<code>气球起始坐标≤击打坐标≤气球终止坐标</code>，要想一次性击打多个气球，则击打点应当是气球边界位置（起始坐标或终止坐标）。</p><ul><li>假如取起始坐标 <code>x</code> 为击打点，则<code>starX≤ x ≤ endX</code>的气球都可以被击破<ul><li>选<code>起始坐标</code>为击打点，则每次击打都应该选取<code>起始坐标</code>最大的气球，因此对<code>points</code>按<code>points[0]</code>进行降序排序。</li><li>排序之后开始遍历，<code>points[i][0]&gt;=points[i+1][0]</code>恒成立，因此<code>starX≤ x</code>必定满足，只需要判断<code>x ≤ endX</code>即可，如果成立，则重叠，可以一支箭射穿</li></ul></li><li>假如取终止坐标 <code>x</code> 为击打点，则<code>starX≤ x ≤ endX</code>的气球都可以被击破<ul><li>选<code>终止坐标</code>为击打点，则每次击打都应该选取<code>终止坐标</code>最大的气球，因此对<code>points</code>按<code>points[0</code>]进行升序排序。</li><li>排序之后开始遍历，<code>points[i][1]&lt;=points[i+1][1]</code>恒成立，因此<code>x ≤ endX</code>必定满足，只需要判断<code>starX≤ x</code>即可，如果成立，则重叠，可以一支箭射穿</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取终止坐标为击打点的解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 贪心</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">// 对气球进行排序，按终点坐标增序排序。</span></span><br><span class="line">        <span class="comment">//  如果终点坐标一样,则不用管（因为终点坐标一样，一枪肯定能全打爆，只要有一个气球不能和前面区间合并，都只会新增一支箭，不影响结果）</span></span><br><span class="line">        <span class="comment">//      例如：[5,8],[6,10],[9,10]  和  [5,8],[9,10],[6,10]   res都是2，区别是前者[[5,8,[6,10]] 和[9,10] 后者是[5,8],[[9,10],[6,10]]</span></span><br><span class="line">        Arrays.sort(points,(point1,point2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> point1[<span class="number">1</span>]&lt;point2[<span class="number">1</span>]?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 记录上一个区间的箭击打坐标</span></span><br><span class="line">        <span class="type">int</span> end=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 只要遍历到的气球起始坐标&lt;= 上一个区间的击打坐标，则可以合并一箭击打。否则要再射一箭，击打坐标为当前气球的终点坐标</span></span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]&gt;end)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                end=points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-1904. 你完成的完整对局数</title>
      <link href="/posts/ac5912c2.html"/>
      <url>/posts/ac5912c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>微软2022春招实习后端笔试原题</p><p><a href="https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played">https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played</a></p><p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 <code>HH:00、HH:15、HH:30 和 HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00 到 23 </code>的整数表示。游戏中使用<code> 24 小时制</code>的时钟 ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p><p>给你两个字符串 <code>startTime</code> 和<code>finishTime</code>，均符合 “HH:MM” 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。</p><p>例如，如果 <code>startTime = &quot;05:20&quot;</code> 且 <code>finishTime = &quot;05:59&quot;</code> ，这意味着你仅仅完成从<code> 05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15 到 05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45 到 06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。<br>如果<code> finishTime 早于 startTime</code> ，这表示你玩了个通宵（<a href="https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played%EF%BC%89%E3%80%82">https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played）。</a></p><p>假设你是从 <code>startTime </code>进入游戏，并在<code>finishTime</code>退出游戏，请计算并返回你完成的 完整对局的对局数 。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：startTime = &quot;12:01&quot;, finishTime = &quot;12:44&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：你完成了从 12:15 到 12:30 的一个完整对局。</span><br><span class="line">你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。</span><br><span class="line">你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。</span><br><span class="line"></span><br><span class="line">输入：startTime = &quot;20:00&quot;, finishTime = &quot;06:00&quot;</span><br><span class="line">输出：40</span><br><span class="line">解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。</span><br><span class="line">16 + 24 = 40</span><br><span class="line"></span><br><span class="line">输入：startTime = &quot;00:00&quot;, finishTime = &quot;23:59&quot;</span><br><span class="line">输出：95</span><br><span class="line">解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>没什么好说的….纯纯的模拟，笔试的时候太粗心了对通宵情况只判断了hour没判断min…..第一次笔试交点学费吧！后面再加油！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfRounds</span><span class="params">(String loginTime, String logoutTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 分离hour和min</span></span><br><span class="line">        <span class="type">int</span> hourA=Integer.parseInt(loginTime.substring(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> minA=Integer.parseInt(loginTime.substring(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">        <span class="type">int</span> hourB=Integer.parseInt(logoutTime.substring(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> minB=Integer.parseInt(logoutTime.substring(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 退出时间比登录时间小，两种情况：hour小、hour相等min小。 要对退出时间的hour+24</span></span><br><span class="line">        <span class="keyword">if</span>(hourB&lt;hourA||(hourA==hourB&amp;&amp;minA&gt;minB)) hourB+=<span class="number">24</span>;</span><br><span class="line">        <span class="comment">// 向上取整登录时间</span></span><br><span class="line">        <span class="keyword">if</span>(minA%<span class="number">15</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            minA=(minA/<span class="number">15</span>+<span class="number">1</span>)*<span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下取整退出时间</span></span><br><span class="line">        <span class="keyword">if</span>(minB%<span class="number">15</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            minB=(minB/<span class="number">15</span>)*<span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hour不相同，则分别计算登录和退出两个hour中可以玩的次数，再用中间的hour数*4</span></span><br><span class="line">        <span class="keyword">if</span>(hourB!=hourA)&#123;</span><br><span class="line">            res=(<span class="number">60</span>-minA)/<span class="number">15</span>;</span><br><span class="line">            res+=minB/<span class="number">15</span>;</span><br><span class="line">            res+=(hourB-hourA-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res=(minB-minA)/<span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&gt;=<span class="number">0</span>?res:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-124(变式). 二叉树中的最大路径和</title>
      <link href="/posts/f3bed3dc.html"/>
      <url>/posts/f3bed3dc.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>微软2022春招实习后端笔试题，是leetcode中二叉树最大路径和的变式。</p><p><a href="http://leetcode-cn.com/problems/binary-tree-maximum-path-sum">http://leetcode-cn.com/problems/binary-tree-maximum-path-sum</a></p><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>本题中树为<strong>多叉树</strong>，树的<strong>节点内容只有’a’和’b’<strong>两种，请设计一个函数，返回</strong>相邻节点内容不同的最长序列长度</strong>。</p><p>即：求得是abababab这样的最长路径。</p><p><strong>输入：</strong>（String S，int[] A）</p><p><code>S</code>由<code>&#39;a&#39;和&#39;b&#39;</code>组成，<code>S[i]</code>代表是序号为<code>i</code>的节点值</p><p><code>A[i]</code>记录的是序号为<code>i</code>的节点的双亲结点序号，例如<code>A[3]=2</code>表示序号为3的节点，其双亲节点的下标为2，<code>A[0]=-1</code>,因为0是根节点</p><p>​    <strong>注意</strong>：除了序号0为根节点以外，其他节点序号与节点出现顺序无关</p><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p><img src="http://typora.lemonchan.top/image-20220215210030400.png" alt="image-20220215210030400"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：S=&quot;ababa&quot;  A=[-1,0,3,0,0]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><img src="http://typora.lemonchan.top/image-20220215210134740.png" alt="image-20220215210134740"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：S=&quot;abbab&quot;  A=[-1,0,0,0,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><img src="http://typora.lemonchan.top/image-20220215210258154.png" alt="image-20220215210258154"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：S=&quot;aabb&quot;  A=[-1,2,0,1]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><strong>此题解正确性有待探究</strong>，如有大佬发现错误劳烦在评论区留言！非常感谢！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// 记录结果</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution</span><span class="params">(String S, <span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code in Java SE 8</span></span><br><span class="line">        <span class="type">char</span> [] chars=S.toCharArray();</span><br><span class="line">        <span class="comment">// 构建数组记录每一个节点的子节点序号</span></span><br><span class="line">        List&lt;Integer&gt;[] sons=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[chars.length];</span><br><span class="line">        <span class="comment">// 初始化子节点数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sons[A[i]]==<span class="literal">null</span>) sons[A[i]]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            sons[A[i]].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从根节点开始dfs</span></span><br><span class="line">        dfs(chars,<span class="number">0</span>,sons);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chars 记录每个节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前dfs的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sons 记录每个节点的子节点序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回以当前节点为起点，其满足条件的最长序列长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[]chars,<span class="type">int</span> index,List&lt;Integer&gt;[] sons)</span>&#123;</span><br><span class="line">        <span class="comment">// 越界判断</span></span><br><span class="line">        <span class="keyword">if</span>(index&gt;=chars.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分别记录子节点为a、b时的最大长度和第二大长度</span></span><br><span class="line">        <span class="type">int</span> maxA=<span class="number">0</span>,maxB=<span class="number">0</span>,secondA=<span class="number">0</span>,secondB=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 有子节点才遍历</span></span><br><span class="line">        <span class="keyword">if</span>(sons[index]!=<span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 遍历子节点List</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> sonIndex:sons[index])&#123;</span><br><span class="line">                <span class="comment">// 获取以子节点为起点，满足要求的最长序列长度</span></span><br><span class="line">                temp=dfs(chars,sonIndex,sons);</span><br><span class="line">                <span class="comment">// 子节点是a则尝试更新maxA和secondA，否则尝试更新B</span></span><br><span class="line">                <span class="keyword">if</span>(sonIndex&lt;chars.length&amp;&amp;chars[sonIndex]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(maxA&lt;temp)&#123;</span><br><span class="line">                        secondA=maxA;</span><br><span class="line">                        maxA=temp;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(secondA&lt;temp)&#123;</span><br><span class="line">                        secondA=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sonIndex&lt;chars.length&amp;&amp;chars[sonIndex]==<span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(maxB&lt;temp)&#123;</span><br><span class="line">                        secondB=maxB;</span><br><span class="line">                        maxB=temp;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(secondB&lt;temp)&#123;</span><br><span class="line">                        secondB=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 最长长度可能不包含当前节点</span></span><br><span class="line">        res=Math.max(res,Math.max(maxA,maxB));</span><br><span class="line">        <span class="keyword">if</span>(chars[index]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 当前节点为a，则其最多可以连接两个B节点，最长长度可能是maxB+secondB+1</span></span><br><span class="line">            res=Math.max(res,maxB+secondB+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> maxB+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res=Math.max(res,maxA+secondA+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> maxA+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> 树 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-210. 课程表 II</title>
      <link href="/posts/aa54495b.html"/>
      <url>/posts/aa54495b.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">https://leetcode-cn.com/problems/course-schedule-ii/</a></p><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中<code>prerequisites[i] = [ai, bi]</code>，表示在选修课程 <code>ai</code> 前 必须 先选修 <code>bi</code> 。</p><p>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。<br>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。</p><blockquote><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>所有<code>[ai, bi]</code> 互不相同</li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>拓扑排序，dfs和bfs均可。</p><ul><li>记录下每个课程的先修课程数，每次修读都要挑选先修课程数为0的课程。</li><li>每次修读一门课程，要同时减少他的<strong>后置课程</strong>的<strong>先修课程数</strong></li><li>bfs：用一个队列存放要修读的课程，遍历队列进行修读，同时修改后置课程的先修课程数，后置课程的先修课程数修改后如果为0，则入队列等待遍历。</li><li>dfs：挑选先修课程数为0的课程为入口进行修读，同时修改后置课程的先修课程数，后置课程的先修课程数修改后如果为0，则直接修读该后置课程</li></ul><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 记录每门课程的后置课程</span></span><br><span class="line">        List&lt;Integer&gt;[] next=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[numCourses];</span><br><span class="line">        <span class="comment">// 记录每一门课程的先修课程数</span></span><br><span class="line">        <span class="type">int</span> []in=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 初始化next和in</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> [] group:prerequisites)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next[group[<span class="number">1</span>]]==<span class="literal">null</span>) next[group[<span class="number">1</span>]]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            next[group[<span class="number">1</span>]].add(group[<span class="number">0</span>]);</span><br><span class="line">            in[group[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 存放先修课程数为0（没有先修，或者先修已经修完）的课程号</span></span><br><span class="line">        Deque&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化queue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 广搜</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> i=queue.poll();</span><br><span class="line">            <span class="comment">// 后置课程的先修课程数-1</span></span><br><span class="line">            <span class="keyword">if</span>(next[i]!=<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k:next[i])&#123;</span><br><span class="line">                    in[k]--;</span><br><span class="line">                    <span class="comment">// 如果后置课程的先修课程数变为0,则入队列</span></span><br><span class="line">                    <span class="keyword">if</span>(in[k]==<span class="number">0</span>) queue.offer(k);</span><br><span class="line">                &#125;</span><br><span class="line">            res[index++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果结果数组长度与课程数一致,则可以修读,否则不可以</span></span><br><span class="line">        <span class="keyword">return</span> index==numCourses?res:<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> []res;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 记录每门课程的后置课程</span></span><br><span class="line">        List&lt;Integer&gt;[] next=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[numCourses];</span><br><span class="line">        <span class="comment">// 记录每一门课程的先修课程数</span></span><br><span class="line">        <span class="type">int</span> []in=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 记录是否已访问过,避免成环,剪枝</span></span><br><span class="line">        <span class="type">int</span> []visited=<span class="keyword">new</span> <span class="title class_">int</span> [numCourses];</span><br><span class="line">        res=<span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 初始化next和in</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> [] group:prerequisites)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next[group[<span class="number">1</span>]]==<span class="literal">null</span>) next[group[<span class="number">1</span>]]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            next[group[<span class="number">1</span>]].add(group[<span class="number">0</span>]);</span><br><span class="line">            in[group[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 深搜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(visited,next,in,i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果结果数组长度与课程数一致,则可以修读,否则不可以</span></span><br><span class="line">        <span class="keyword">return</span> index==numCourses?res:<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> []visited,List&lt;Integer&gt;[] next,<span class="type">int</span> []in,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">        <span class="comment">// 成环了</span></span><br><span class="line">        <span class="keyword">if</span>(visited[now]==-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这门课程已经修过了</span></span><br><span class="line">        <span class="keyword">if</span>(visited[now]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 记录正在访问</span></span><br><span class="line">        visited[now]=-<span class="number">1</span>;</span><br><span class="line">        res[index++]=now;</span><br><span class="line">        <span class="comment">// 更新in数组</span></span><br><span class="line">        <span class="keyword">if</span>(next[now]!=<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:next[now])&#123;</span><br><span class="line">            in[i]--;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(visited,next,in,i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录已访问完(课程已修读)</span></span><br><span class="line">        visited[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-334. 递增的三元子序列</title>
      <link href="/posts/9e648a77.html"/>
      <url>/posts/9e648a77.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">https://leetcode-cn.com/problems/increasing-triplet-subsequence/</a></p><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><blockquote><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：任何 i &lt; j &lt; k 的三元组都满足题意</span><br><span class="line"></span><br><span class="line">输入：nums = [5,4,3,2,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在满足题意的三元组</span><br><span class="line"></span><br><span class="line">输入：nums = [2,1,5,0,4,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>维护两个变量<code>min,second</code>，分别记录当前遍历位置前方，可以作为三元组前两个变量的值。因此<code>second</code>总是比<code>min</code>大</p><p>遍历过程中：</p><ul><li>如果<code>nums[i]&gt;second</code>，则存在三元组.</li><li>如果<code>nums[i]&lt;min</code>，则更新<code>min</code>（这样后面更小的<code>second</code>才能够更新）</li><li>如果<code>min&lt;nums[i]&lt;second</code>，则更新<code>second</code>（因为<code>second</code>必须比<code>min</code>大，<code>second</code>越小，越容易找到三元组的第三个数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 定两个，找第三个。规定second必定比min大</span></span><br><span class="line">        <span class="type">int</span> min=nums[<span class="number">0</span>],second=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果nums[i]&gt; second，则成立，返回true</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果nums[i]&lt;min,则更新最小min（不会影响second）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;min)</span><br><span class="line">                min=nums[i];</span><br><span class="line">            <span class="comment">// second只有满足second&gt;nums[i]&gt;min时才会更新（因为要保证second前方要有一个比他小的）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;min&amp;&amp;nums[i]&lt;second)</span><br><span class="line">                second=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-160. 相交链表</title>
      <link href="/posts/66312216.html"/>
      <url>/posts/66312216.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/intersection-of-two-linked-lists/">http://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="http://typora.lemonchan.top/160_statement.png" alt="img"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/160_example_1-16444660728094.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://typora.lemonchan.top/160_example_3-16444660771726.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据题意，有交点的两个链表，从交点开始后，其节点就一致。那么最后一个节点也必定一样。</p><p>因此只需要遍历两个链表并记录两个链表的长度差，判断两个链表最后一个节点是否相等。</p><ul><li>不相等则不相交，返回<code>null</code></li><li>相等则相交，要去寻找相交节点。<ul><li>因为从相交节点开始，两个链表的后续节点完全一致，因此从相交节点到尾节点长度一致。</li><li>先把长度更长的链表先遍历，让剩下的部分与另一链表长度一致，然后同时遍历两个链表，直至找到相等的节点。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">// 分别计算两个链表长度差值</span></span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode pointA=headA,pointB=headB;</span><br><span class="line">        <span class="keyword">while</span>(pointA.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            pointA=pointA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pointB.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            len--;</span><br><span class="line">            pointB=pointB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终点不一样，肯定没有交点</span></span><br><span class="line">        <span class="keyword">if</span>(pointA!=pointB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//  差值&gt;0，证明A更长，A要先走</span></span><br><span class="line">        <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            headA=headA.next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  差值&lt;0，证明B更长，B要先走</span></span><br><span class="line">        <span class="keyword">while</span>(len&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headA!=headB)&#123;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">            headA=headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-162. 寻找峰值</title>
      <link href="/posts/7f53fb9c.html"/>
      <url>/posts/7f53fb9c.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/find-peak-element/">https://leetcode-cn.com/problems/find-peak-element/</a></p><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞ </code>。</p><p>你必须实现时间复杂度为<code> O(log n)</code> 的算法来解决此问题。</p><blockquote><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li>&#96;&#96;-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1&#96;</li><li>对于所有有效的<code> i</code> 都有 <code>nums[i] != nums[i + 1]</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：3 是峰值元素，你的函数应该返回其索引 2。</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,1,3,5,6,4]</span><br><span class="line">输出：1 或 5 </span><br><span class="line">解释：你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>注意题目的提示：<code>nums[-1]=nums[n]=-∞</code>，因此必定存在峰值。而峰值是大于左右相邻元素，则到达峰值前必定要爬坡（经历递增序列），到达峰值之后必定会经历下坡（经历递减序列）。</p><p>因此可以用二分查找：</p><ul><li>如果&#96;&#96;mid&#96;大于左右，则找到峰值。</li><li>如果<code>left&lt;mid&lt;right</code>则仍在爬坡，峰值在右边（左边界右移）。</li><li>如果<code>left&gt;mid&gt;right</code>则峰值已过，正在下坡，峰值在左边（右边界左移）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 先爬坡，到达峰值，再下坡</span></span><br><span class="line">    <span class="comment">// 因此如果已经是下坡路，则证明峰值已过，右边界左移</span></span><br><span class="line">    <span class="comment">//     如果是上坡路，则证明峰值还未到，左边界右移</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> sign=getSign(nums,mid);</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign==<span class="number">2</span>)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *<span class="doctag">@return</span> 1:已找到、2:左边界移动、3:右边界移动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSign</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果同时是左右边界，则必定是峰值</span></span><br><span class="line">            <span class="keyword">if</span>(index==nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果大于右边的元素，则是峰值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[index]&gt;nums[index+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果小于右边元素，则峰值必定在右边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果大于左边的元素，则是峰值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[index]&gt;nums[index-<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果小于左边元素，则峰值必定在左边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果大于左边和右边的元素，则是峰值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[index]&gt;nums[index-<span class="number">1</span>]&amp;&amp;nums[index]&gt;nums[index+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 递增，上坡，则峰值在右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[index]&gt;nums[index-<span class="number">1</span>]&amp;&amp;nums[index+<span class="number">1</span>]&gt;nums[index]) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 递减，下坡，则峰值在左边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-23. 合并K个升序链表</title>
      <link href="/posts/c34f7f3e.html"/>
      <url>/posts/c34f7f3e.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><blockquote><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li>&#96;&#96;-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4&#96;</li><li><code>lists[i] </code>按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过<code> 10^4</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol><li>归并排序：自底向上、自顶向下</li><li>优先队列：把所有链表头放入优先队列中，然后每次取队列头加到结果链表中，如果取出的节点next不为空，则把next入队列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 自底向上归并排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="literal">null</span>||lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// len是现存链表数量</span></span><br><span class="line">        <span class="type">int</span> len=lists.length;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// index记录合并后的链表下标</span></span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                ListNode head1=lists[i];</span><br><span class="line">                <span class="comment">// 有下一个链表，则将两个链表合并，合并后用head1变量指向</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;len-<span class="number">1</span>)&#123;</span><br><span class="line">                    ListNode head2=lists[i+<span class="number">1</span>];</span><br><span class="line">                    i++;</span><br><span class="line">                    head1=merge(head1,head2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 合并后的链表覆盖原数组中的链表</span></span><br><span class="line">                lists[index++]=head1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新现存链表数</span></span><br><span class="line">            len=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 合并两个有序链表的方法</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1,ListNode head2)</span>&#123;</span><br><span class="line">        ListNode resHead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(),point=resHead,next;</span><br><span class="line">        <span class="keyword">while</span>(head1!=<span class="literal">null</span>&amp;&amp;head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;head2.val)&#123;</span><br><span class="line">                point.next=head1;</span><br><span class="line">                head1=head1.next;</span><br><span class="line">                point=point.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                point.next=head2;</span><br><span class="line">                head2=head2.next;</span><br><span class="line">                point=point.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head1!=<span class="literal">null</span>) point.next=head1;</span><br><span class="line">        <span class="keyword">if</span>(head2!=<span class="literal">null</span>) point.next=head2;</span><br><span class="line">        <span class="keyword">return</span> resHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// lamda表达式传入排序比较方法构建优先队列</span></span><br><span class="line">        Queue&lt;ListNode&gt; priorityQueue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((node1,node2)-&gt;node1.val&lt;node2.val?-<span class="number">1</span>:node1.val==node2.val?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 链表头非空则入队</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode node:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            priorityQueue.offer(node);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode resHead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(),point=resHead;</span><br><span class="line">        <span class="keyword">while</span>(!priorityQueue.isEmpty())&#123;</span><br><span class="line">            ListNode node=priorityQueue.poll();</span><br><span class="line">            point.next=node;</span><br><span class="line">            point=point.next;</span><br><span class="line">            <span class="comment">// 该链表还有后续节点，后续节点入队</span></span><br><span class="line">            <span class="keyword">if</span>(node.next!=<span class="literal">null</span>) priorityQueue.offer(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-124. 二叉树中的最大路径和</title>
      <link href="/posts/cdc64f07.html"/>
      <url>/posts/cdc64f07.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p><p>路径 被定义为一条从树中任意节点出发，沿<strong>父节点-子节点连接</strong>，<strong>达到任意节点</strong>的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><blockquote><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br><span class="line"></span><br><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>路径有多种样式：root、left+root+right、left+root、root+right</p><p>由题意可知，只有最上面的root节点才能同时连接左右节点，因此采用dfs进行搜索，每次深搜返回的是以当前节点为根节点往下进行搜索的最大和（root、root+left、root+right）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        max=root.val;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=dfs(root.left);</span><br><span class="line">        <span class="type">int</span> right=dfs(root.right);</span><br><span class="line">        max=Math.max(max,</span><br><span class="line">                     Math.max(Math.max(root.val+left+right,root.val),</span><br><span class="line">                              Math.max(root.val+left,root.val+right)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(left,right)+root.val,root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-42. 接雨水</title>
      <link href="/posts/da82793c.html"/>
      <url>/posts/da82793c.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water">https://leetcode-cn.com/problems/trapping-rain-water</a></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/image-20220207125543653.png" alt="image-20220207125543653"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先要明确每个坑能装多少雨水的决定因素：其左边和右边的最大高度，取二者之小值减去当前坑的高度，就得到了当前坑装的雨水数。</p><p>双指针从两端开始遍历，如果leftMax&lt;&#x3D;rightMax，则计算左边，否则计算右边。</p><ul><li>计算left是从左往右遍历，因此对于left来所，leftMax不会再更新，而rightMax只会变大&#x2F;不变，因此leftMax&lt;&#x3D;rightMax时，此时的leftMax必定是左右最大高度之小值，因此可以用leftMax来计算left装的雨水数</li><li>计算right是从右往左遍历，因此对于right来所，rightMax不会再更新，而leftMax只会变大&#x2F;不变，因此leftMax&gt;rightMax时，此时的rightMax必定是左右最大高度之小值，因此可以用rightMax来计算right装的雨水数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">// 左右两个边界肯定存不了水，所以从1和len-2开始遍历</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>,right=height.length-<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 分别记录left及其左边的最大值，right及其右边的最大值</span></span><br><span class="line">        <span class="type">int</span> leftMax=height[<span class="number">0</span>],rightMax=height[right+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">// left及其左边的最大值小于right及其右边的最大值，则left可以用leftMax计算得出可装雨水数</span></span><br><span class="line">            <span class="keyword">if</span>(leftMax&lt;=rightMax)&#123;</span><br><span class="line">                leftMax=Math.max(leftMax,height[left]);</span><br><span class="line">                res+=leftMax-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rightMax=Math.max(rightMax,height[right]);</span><br><span class="line">                res+=rightMax-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> hard </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-1206. 设计跳表</title>
      <link href="/posts/7200ccba.html"/>
      <url>/posts/7200ccba.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/design-skiplist/">http://leetcode-cn.com/problems/design-skiplist/</a></p><p>不使用任何库函数，设计一个跳表。</p><p>跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90]，然后增加 80、45 到跳表中，以下图的方式操作：</p><p><img src="http://typora.lemonchan.top/1506_skiplist.gif" alt="img"></p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>在本题中，你的设计应该要包含这些函数：</p><ul><li><p>bool search(int target) : 返回target是否存在于跳表中。</p></li><li><p>void add(int num): 插入一个元素到跳表。</p></li><li><p>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。</p></li></ul><p>了解更多 : <a href="http://en.wikipedia.org/wiki/Skip_list">http://en.wikipedia.org/wiki/Skip_list</a></p><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><blockquote><ul><li><code>0 &lt;= num, target &lt;= 20000</code></li><li>最多调用 <code>50000</code> 次 <code>search</code>, <code>add</code>, 以及 <code>erase</code>操作。</li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Skiplist skiplist = new Skiplist();</span><br><span class="line"></span><br><span class="line">skiplist.add(1);</span><br><span class="line">skiplist.add(2);</span><br><span class="line">skiplist.add(3);</span><br><span class="line">skiplist.search(0);   // 返回 false</span><br><span class="line">skiplist.add(4);</span><br><span class="line">skiplist.search(1);   // 返回 true</span><br><span class="line">skiplist.erase(0);    // 返回 false，0 不在跳表中</span><br><span class="line">skiplist.erase(1);    // 返回 true</span><br><span class="line">skiplist.search(1);   // 返回 false，1 已被擦除</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>跳表实质上就是多层链表，最底层存放所有的节点，其他层链表只存放部分节点，在上层的基础上检索下层，用于提高检索速度。要解决的主要问题是：<strong>如何确定插入节点时该节点的层数</strong></p><p>参照redis的跳表实现，层数用一个方法来随机生成，其中最大允许层数为32，随即层数生成因子为1&#x2F;4。</p><ul><li>插入：从当前顶层开始查询插入位置，然后逐层插入。每层开始查询的节点是上一层查询的结果节点（因为越往底层走节点越全，所有插入位置一定是与上层一致或在上层后方）。如果新节点层数超过了原有的层数，则在新的层级中直接将新节点连接到头节点后方。</li><li>删除：从当前顶层开始查询，逐层删除。每层开始查询的节点是上一层查询的结果节点。</li><li>查询：从当前顶层开始查询，查到结果就返回true，否则查询下一层</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line">    <span class="comment">// 节点类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Integer val;    <span class="comment">// 记录节点值</span></span><br><span class="line">        Node[] next;    <span class="comment">// 记录节点在跳表不同层级的下一节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Integer val,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val=val;</span><br><span class="line">            <span class="built_in">this</span>.next=<span class="keyword">new</span> <span class="title class_">Node</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> MAX_LEVEL=<span class="number">32</span>;  <span class="comment">// 跳表最大层数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> P_FACTOR=<span class="number">0.25</span>;  <span class="comment">// 随机层级生成因子</span></span><br><span class="line">    <span class="type">int</span> now_level=<span class="number">1</span>;</span><br><span class="line">    Node head=<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,MAX_LEVEL); <span class="comment">// 头节点，val为null，跳表层级为最大层数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Skiplist</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 从头节点、最高层开始查询</span></span><br><span class="line">        Node preNode=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=now_level-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 找到该层最后一个小于target的节点，下次查找从上一次查找的结果处开始</span></span><br><span class="line">            preNode=getCloseNode(i,preNode,target);</span><br><span class="line">            <span class="comment">// 找到了，返回true</span></span><br><span class="line">            <span class="keyword">if</span>(preNode.next[i]!=<span class="literal">null</span>&amp;&amp;preNode.next[i].val==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 从头节点开始查询</span></span><br><span class="line">        Node preNode=head;</span><br><span class="line">        <span class="comment">// 随机生成跳表层级</span></span><br><span class="line">        <span class="type">int</span> level=getRandomLevel();</span><br><span class="line">        <span class="comment">// 新建节点</span></span><br><span class="line">        Node newNode=<span class="keyword">new</span> <span class="title class_">Node</span>(num,level);</span><br><span class="line">        <span class="comment">// 从原有最高层级开始寻找插入点（在最后一个小于num的节点后插入）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=now_level-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 找到在该层插入点的前驱节点</span></span><br><span class="line">            preNode=getCloseNode(i,preNode,num);</span><br><span class="line">            <span class="comment">// 如果当前层高于新节点的层数，则continue</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=level) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果该层插入点为空，则直接插入</span></span><br><span class="line">            <span class="keyword">if</span>(preNode.next[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                preNode.next[i]=newNode;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果该层插入点不为空，则将插入点放到新建节点后，把新建节点插入</span></span><br><span class="line">                newNode.next[i]=preNode.next[i];</span><br><span class="line">                preNode.next[i]=newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果新建节点层级高于原有层级，则在多出的层级中，将新建节点直接插在头节点后。更新当前层级</span></span><br><span class="line">        <span class="keyword">if</span>(now_level&lt;level)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=now_level;i&lt;level;i++)&#123;</span><br><span class="line">                head.next[i]=newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            now_level=level;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">erase</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 从头节点开始查询</span></span><br><span class="line">        Node preNode=head;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=now_level-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 找到该层最后一个小于num的节点，下次查找从上一次查找的结果处开始</span></span><br><span class="line">            preNode=getCloseNode(i,preNode,num);</span><br><span class="line">            <span class="comment">// 下一节点是唯一可能等于num的</span></span><br><span class="line">            <span class="keyword">if</span>(preNode.next[i]!=<span class="literal">null</span>&amp;&amp;preNode.next[i].val==num)&#123;</span><br><span class="line">                preNode.next[i]=preNode.next[i].next[i];</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 每一层最多只能删除一个节点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 传入等级、头节点、value，返回该等级中最后一个小于value的节点 */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getCloseNode</span><span class="params">(<span class="type">int</span> level,Node head,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head.next[level]!=<span class="literal">null</span>&amp;&amp;head.next[level].val&lt;value)&#123;</span><br><span class="line">            head=head.next[level];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成层级的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRandomLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> level=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(Math.random()&lt;P_FACTOR&amp;&amp;level&lt;MAX_LEVEL)</span><br><span class="line">            level++;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记-类的加载过程</title>
      <link href="/posts/31b21dec.html"/>
      <url>/posts/31b21dec.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、类的生命周期"><a href="#一、类的生命周期" class="headerlink" title="一、类的生命周期"></a>一、类的生命周期</h2><p>一个类的完整生命周期如下：</p><p><img src="http://typora.lemonchan.top/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png" alt="img"></p><h2 id="二、类加载过程"><a href="#二、类加载过程" class="headerlink" title="二、类加载过程"></a>二、类加载过程</h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="http://typora.lemonchan.top/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="img"></p><h3 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h3><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 <code>ZIP</code> 包中读取（日后出现的 <code>JAR</code>、<code>EAR</code>、<code>WAR</code> 格式的基础）、其他文件生成（典型应用就是 <code>JSP</code>）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p><p><strong>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</strong></p><h3 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h3><p><img src="http://typora.lemonchan.top/image-20220206182218321.png" alt="image-20220206182218321"></p><h3 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量（静态变量）则会随着 Class 对象一起存放在 Java 堆中。<strong>特别注意：Class对象是在堆中，方法区中存放的是类的元数据（类的全类名、变量名、方法代码等）</strong></li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ol><p><strong>基本数据类型的零值</strong> ：</p><p><img src="http://typora.lemonchan.top/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p><h3 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h3><p>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p><blockquote><p>说明： <code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p></blockquote><p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了<strong>有且只有 6 种情况</strong>下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li><p>当遇到 </p><p><code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code>这 4 条直接码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</p><ul><li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</p></li><li><p>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</p></li><li><p><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</p></li><li><p>当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ol><h3 id="6、卸载"><a href="#6、卸载" class="headerlink" title="6、卸载"></a>6、卸载</h3><p>卸载类即该类的 Class 对象被 GC。</p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，jdk 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://javaguide.cn/home/">《JavaGuide面试指南》</a></p><p><a href="http://blog.csdn.net/Xu_JL1997/article/details/89433916">《JDK 1.8 下的 java.lang.Class 对象和 static 成员变量在堆还是方法区？》</a></p><p>《深入理解 Java 虚拟机第三版》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-93. 复原 IP 地址</title>
      <link href="/posts/4431ee11.html"/>
      <url>/posts/4431ee11.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/restore-ip-addresses">https://leetcode-cn.com/problems/restore-ip-addresses</a></p><p>​    <strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><ul><li>例如：”0.1.2.201” 和 “192.168.1.1” 是 <strong>有效</strong> IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#64;&#49;&#x2e;&#49;">&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#64;&#49;&#x2e;&#49;</a>“ 是 无效 IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s </code>，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 s 中插入 <code>&#39;.&#39;</code> 来形成。你不能重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><blockquote><ul><li><code>0 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br><span class="line"></span><br><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br><span class="line"></span><br><span class="line">输入：s = &quot;1111&quot;</span><br><span class="line">输出：[&quot;1.1.1.1&quot;]</span><br><span class="line"></span><br><span class="line">输入：s = &quot;010010&quot;</span><br><span class="line">输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</span><br><span class="line"></span><br><span class="line">输入：s = &quot;101023&quot;</span><br><span class="line">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span> []chars=s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(),chars,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num,StringBuilder tempStr,<span class="type">char</span>[]chars,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">// num即已组合长度，如果长度=4，则证明ip地址的组数够了，如果刚好所有数字用完，则加入到结果中</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">4</span>&amp;&amp;index==chars.length)&#123;</span><br><span class="line">            tempStr.deleteCharAt(tempStr.length()-<span class="number">1</span>);</span><br><span class="line">            res.add(tempStr.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组合长度够了或者所有数字已用完，则违规，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">4</span>||index&gt;=chars.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 每组ip的长度为1~3，遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=<span class="number">3</span>&amp;&amp;index+len&lt;=chars.length;len++)&#123;</span><br><span class="line">            String add=<span class="keyword">new</span> <span class="title class_">String</span>(chars,index,len);</span><br><span class="line">            <span class="comment">// 0只可以单独存在，如果组中第一个数为0，则长度不能为2、3</span></span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>&amp;&amp;chars[index]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 长度为3时要判断大小是否超过255</span></span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">3</span>&amp;&amp;Integer.valueOf(add)&gt;<span class="number">255</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 记录旧的StringBuilder</span></span><br><span class="line">            StringBuilder old=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(tempStr);</span><br><span class="line">            tempStr.append(add);</span><br><span class="line">            tempStr.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="comment">// dfs</span></span><br><span class="line">            dfs(num+<span class="number">1</span>,tempStr,chars,index+len);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            tempStr=old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-1493.删掉一个元素以后全为 1 的最长子数组</title>
      <link href="/posts/ce7701e3.html"/>
      <url>/posts/ce7701e3.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/">https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/</a></p><p>给你一个二进制数组<code>nums</code>，你需要从中删掉一个元素。</p><p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p><p>如果不存在这样的子数组，请返回 0 。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,0,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。</span><br><span class="line"></span><br><span class="line">输入：nums = [0,1,1,1,0,1,1,0,1]</span><br><span class="line">输出：5</span><br><span class="line">解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。</span><br><span class="line"></span><br><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：你必须要删除一个元素。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>两种方法，分别是滑动窗口和递推</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 法一 递推</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录以i结尾的最长连续1长度</span></span><br><span class="line">        <span class="type">int</span> []cnts=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 是1，长度++</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                len++;</span><br><span class="line">                <span class="comment">// 到达数组末尾或者下一位是0，则中断，记录长度</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;=nums.length-<span class="number">1</span>||nums[i+<span class="number">1</span>]!=<span class="number">1</span>)</span><br><span class="line">                    cnts[i]=len;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 是0，长度重置为0</span></span><br><span class="line">                len=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnts.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 为0，则不是结尾，continue</span></span><br><span class="line">            <span class="keyword">if</span>(cnts[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 取删掉一个后，前面连接的最长子数组的结尾下标</span></span><br><span class="line">            <span class="type">int</span> last=i-cnts[i]-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 下标&lt;0则为0,否则取cnts内容</span></span><br><span class="line">            <span class="type">int</span> val=last&gt;=<span class="number">0</span>?cnts[last]:<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 对比结果</span></span><br><span class="line">            res=Math.max(res,cnts[i]+val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果如果和数组长度一致,则需要去掉其中一个1</span></span><br><span class="line">        <span class="keyword">if</span>(res==nums.length) res--;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 法二 递推优化空间复杂度为(O(1))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// shortRes记录以当前位置为结尾的最长1的长度,longRes记录以当前位置为结尾的(中间可以去掉一个0的)最长1的长度</span></span><br><span class="line">        <span class="type">int</span> shortRes=<span class="number">0</span>,longRes=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 是1，两个长度++</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                shortRes++;</span><br><span class="line">                longRes++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 是0，short置为0,longRes=shortRes(当前位置的0去掉)</span></span><br><span class="line">                longRes=shortRes;</span><br><span class="line">                shortRes=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res,longRes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果如果和数组长度一致,则需要去掉其中一个1</span></span><br><span class="line">        <span class="keyword">if</span>(res==nums.length) res--;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 法三 滑动窗口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// i是左边界,j是右边界, count记录了当前窗口中的0的个数</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右边界每轮都会移动,而只有当窗口中0的个数&gt;1的时候才会移动,所以窗口只会增大/不变</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==<span class="number">0</span>) count++;</span><br><span class="line">            <span class="comment">// 如果窗口中的0个数大于1,则左边界需要移动</span></span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(nums[i-<span class="number">1</span>]==<span class="number">0</span>) count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果是窗口大小-1(减去窗口内的那个0)</span></span><br><span class="line">        <span class="keyword">return</span> j-i-<span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-138.复制带随机指针的链表</title>
      <link href="/posts/194da822.html"/>
      <url>/posts/194da822.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer">https://leetcode-cn.com/problems/copy-list-with-random-pointer</a></p><p>​    给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>​    构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>​    例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>​    <strong>返回复制链表的头节点。</strong></p><p>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：</p><ul><li><p>val：一个表示 Node.val 的整数。</p></li><li><p>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null</p></li></ul><p>你的代码 只 接受原链表的头节点 head 作为传入参数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line"></span><br><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br><span class="line"></span><br><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>使用<code>HashMap&lt;Node,Node&gt;</code>存放新旧节点之间的映射，用于完成Random指针的深拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">// 存放新旧节点映射&lt;oldNode,newNode&gt;</span></span><br><span class="line">        Map&lt;Node,Node&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// null映射也是null</span></span><br><span class="line">        map.put(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// p1是新链表的遍历指针，p2是原链表的遍历指针</span></span><br><span class="line">        Node newHead=<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>),p1=newHead,p2=head;</span><br><span class="line">        <span class="comment">// 尾插法先生成链表</span></span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p1.next=<span class="keyword">new</span> <span class="title class_">Node</span>(p2.val);</span><br><span class="line">            p1=p1.next;</span><br><span class="line">            <span class="comment">// 记录新旧节点的映射关系</span></span><br><span class="line">            map.put(p2,p1);</span><br><span class="line">            p2=p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置遍历指针</span></span><br><span class="line">        p2=head;</span><br><span class="line">        p1=newHead.next;</span><br><span class="line">        <span class="comment">// 遍历设置random节点</span></span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 获取旧节点的random节点，通过map获取对应random的新节点</span></span><br><span class="line">            p1.random=map.get(p2.random);</span><br><span class="line">            p1=p1.next;</span><br><span class="line">            p2=p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 链表 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记-jvm垃圾回收</title>
      <link href="/posts/cf4fe7c3.html"/>
      <url>/posts/cf4fe7c3.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、JVM内存分配与回收策略"><a href="#一、JVM内存分配与回收策略" class="headerlink" title="一、JVM内存分配与回收策略"></a>一、JVM内存分配与回收策略</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。</p><p><img src="http://typora.lemonchan.top/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.fac41c8a-16440815378277.png" alt="img"></p><p>如图所示，Eden区、From&#x2F;To Survivor区都是新生代，Old Memory是老年代。为什么要进行粉黛呢？</p><p><strong>答：</strong>在新生代中，每次收集都会有大量对象死去，所以可以选择”<strong>标记-复制</strong>“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。因此<strong>新生代分为三个区域</strong>，其中Survivor区有两个，<strong>有一个Survivor区始终为空。老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><h3 id="1、对象优先在Eden区分配"><a href="#1、对象优先在Eden区分配" class="headerlink" title="1、对象优先在Eden区分配"></a>1、对象优先在Eden区分配</h3><p>目前主流的垃圾收集器都会<strong>采用分代回收算法</strong>，因此需要将堆内存<strong>分为新生代和老年代</strong>，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><h3 id="2、大对象直接进入老年代"><a href="#2、大对象直接进入老年代" class="headerlink" title="2、大对象直接进入老年代"></a>2、大对象直接进入老年代</h3><p>为了避免为大对象分配内存时由于<strong>分配担保机制</strong>带来的复制而降低效率。大对象（字符串、数组）直接在老年代进行内存分配。</p><h3 id="3、长期存活的对象将进入老年代"><a href="#3、长期存活的对象将进入老年代" class="headerlink" title="3、长期存活的对象将进入老年代"></a>3、长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能<strong>识别哪些对象应放在新生代，哪些对象应放在老年代</strong>中。为了做到这一点，虚拟机给每个对象一个对象<strong>年龄（Age）计数器</strong>。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中<strong>每熬过一次 MinorGC,年龄就增加 1 岁</strong>，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="4、动态对象年龄判定"><a href="#4、动态对象年龄判定" class="headerlink" title="4、动态对象年龄判定"></a>4、动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄结算代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="comment">// 计算阈值 </span></span><br><span class="line"><span class="type">size_t</span> <span class="variable">desired_survivor_size</span> <span class="operator">=</span> (size_t)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">uint</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">  <span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">  total += sizes[age];</span><br><span class="line">  <span class="keyword">if</span> (total &gt; desired_survivor_size) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  age++;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设定新阈值</span></span><br><span class="line"><span class="type">uint</span> <span class="variable">result</span> <span class="operator">=</span> age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="5、分代收集理论"><a href="#5、分代收集理论" class="headerlink" title="5、分代收集理论"></a>5、分代收集理论</h3><p>不仅是堆，方法区也会发生GC</p><h4 id="5-1对于MinorGC和FullGC等名词定义"><a href="#5-1对于MinorGC和FullGC等名词定义" class="headerlink" title="5.1对于MinorGC和FullGC等名词定义"></a>5.1对于MinorGC和FullGC等名词定义</h4><ul><li>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。目前只有G1收集器有这种行为</li></ul></li><li>整堆收集（Full GC）：对整个Java堆和方法区进行垃圾收集</li></ul><h3 id="6、空间分配担保"><a href="#6、空间分配担保" class="headerlink" title="6、空间分配担保"></a>6、空间分配担保</h3><p><strong>保证老年代的最大可用连续空间能存放下所有新生代的对象</strong>，具体策略如下：</p><blockquote><p>​    在发生 <strong>Minor GC</strong> 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><p>​    “冒险”指的是新生代的进入老年代的对象数量不确定，此时只能根据以往经验判断此次GC新生代进入老年代的对象占用内存大小，来判断是否需要FullGC。</p><p>​    JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。（即默认冒险）</p></blockquote><h2 id="二、判断对象死亡"><a href="#二、判断对象死亡" class="headerlink" title="二、判断对象死亡"></a>二、判断对象死亡</h2><h3 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line"><span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line">objA = <span class="literal">null</span>;</span><br><span class="line">objB = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点（<em>GC Roots有很多个</em>），从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p>可作为 GC Roots 的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="3、关于引用"><a href="#3、关于引用" class="headerlink" title="3、关于引用"></a>3、关于引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><h4 id="3-1．强引用（StrongReference）"><a href="#3-1．强引用（StrongReference）" class="headerlink" title="3.1．强引用（StrongReference）"></a><strong>3.1．强引用（StrongReference）</strong></h4><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o=<span class="keyword">new</span> <span class="title class_">Object</span>();   <span class="comment">//  强引用</span></span><br></pre></td></tr></table></figure><h4 id="3-2．软引用（SoftReference）"><a href="#3-2．软引用（SoftReference）" class="headerlink" title="3.2．软引用（SoftReference）"></a><strong>3.2．软引用（SoftReference）</strong></h4><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p>JDK1.2之后提供了SoftReference类来实现软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);                                     <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);     <span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure><h4 id="3-3．弱引用（WeakReference）"><a href="#3-3．弱引用（WeakReference）" class="headerlink" title="3.3．弱引用（WeakReference）"></a><strong>3.3．弱引用（WeakReference）</strong></h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p>JDK1.2之后提供了WeakReference类来实现软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);<span class="comment">// 弱引用</span></span><br><span class="line">str=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="3-4．虚引用（PhantomReference）"><a href="#3-4．虚引用（PhantomReference）" class="headerlink" title="3.4．虚引用（PhantomReference）"></a><strong>3.4．虚引用（PhantomReference）</strong></h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。JDK1.2之后提供了PhantomReference类来实现软引用。</p><p><img src="http://typora.lemonchan.top/image-20220206010656510.png" alt="image-20220206010656510"></p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong></p><h3 id="4、不可达对象并非“非死不可”"><a href="#4、不可达对象并非“非死不可”" class="headerlink" title="4、不可达对象并非“非死不可”"></a>4、不可达对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被<strong>第一次标记</strong>并且进行一次<strong>筛选</strong>，筛选的条件是此对象<strong>是否有必要执行 <code>finalize</code> 方法</strong>。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><blockquote><p>finalize方法是对象被回收时执行的方法，JDK9后被标记为过时方法</p></blockquote><h3 id="5、如何判断一个常量是废弃常量？（常量池GC）"><a href="#5、如何判断一个常量是废弃常量？（常量池GC）" class="headerlink" title="5、如何判断一个常量是废弃常量？（常量池GC）"></a>5、如何判断一个常量是废弃常量？（常量池GC）</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="6、如何判断一个类是无用的类？（方法区GC）"><a href="#6、如何判断一个类是无用的类？（方法区GC）" class="headerlink" title="6、如何判断一个类是无用的类？（方法区GC）"></a>6、如何判断一个类是无用的类？（方法区GC）</h3><p>类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p><u>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</u></p><h2 id="三、垃圾收集算法"><a href="#三、垃圾收集算法" class="headerlink" title="三、垃圾收集算法"></a>三、垃圾收集算法</h2><h3 id="1、标记-清除-算法"><a href="#1、标记-清除-算法" class="headerlink" title="1、标记-清除 算法"></a>1、标记-清除 算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：<strong>效率问题、空间问题（标记清除后会产生大量不连续的碎片）</strong></p><p><img src="http://typora.lemonchan.top/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.65bd8fdd-16440811634063.jpeg" alt="img"></p><h3 id="2、标记-复制-算法"><a href="#2、标记-复制-算法" class="headerlink" title="2、标记-复制 算法"></a>2、标记-复制 算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 </p><p><img src="http://typora.lemonchan.top/90984624.fed0b8a5.png" alt="img"></p><h3 id="3、标记-整理-算法"><a href="#3、标记-整理-算法" class="headerlink" title="3、标记-整理 算法"></a>3、标记-整理 算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="http://typora.lemonchan.top/94057049.6e404020.png" alt="标记-整理算法 "></p><h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><h3 id="1、Serial-收集器"><a href="#1、Serial-收集器" class="headerlink" title="1、Serial 收集器"></a>1、Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>采用标记-复制算法，一般用于新生代</strong></p><img src="http://typora.lemonchan.top/image-20220206012241633.png" alt="image-20220206012241633" style="zoom:50%;" /><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="2、ParNew-收集器"><a href="#2、ParNew-收集器" class="headerlink" title="2、ParNew 收集器"></a>2、ParNew 收集器</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本</strong>，除了<strong>使用多线程进行垃圾收集</strong>外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>使用标记复制算法，一般用于新生代</strong></p><p><img src="http://typora.lemonchan.top/image-20220206012348030.png" alt="image-20220206012348030"></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><h3 id="3、Parallel-Scavenge-收集器"><a href="#3、Parallel-Scavenge-收集器" class="headerlink" title="3、Parallel Scavenge 收集器"></a>3、Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>采用标记-复制算法，一般用于新生代</strong></p><p><img src="http://typora.lemonchan.top/image-20220206012436426.png" alt="image-20220206012436426"></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 java -XX:+PrintCommandLineFlags -version 命令查看</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version &quot;1.8.0_211&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="4、Serial-Old-收集器"><a href="#4、Serial-Old-收集器" class="headerlink" title="4、Serial Old 收集器"></a>4、Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本，使用标记-整理算法</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="5、Parallel-Old-收集器"><a href="#5、Parallel-Old-收集器" class="headerlink" title="5、Parallel Old 收集器"></a>5、Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法</strong>。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="6、CMS-收集器"><a href="#6、CMS-收集器" class="headerlink" title="6、CMS 收集器"></a>6、CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</p></li><li><p><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p><p><img src="http://typora.lemonchan.top/image-20220206123655386.png" alt="image-20220206123655386"></p></li></ul><p>CMS用于老年代收集，但在初始标记阶段会扫描新生代获取roots对象。</p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="7、G1-收集器"><a href="#7、G1-收集器" class="headerlink" title="7、G1 收集器"></a>7、G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>G1收集器可用面向堆内存任何部分来组成会收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，<strong>回收收益最大</strong>，这就是G1收集器的<strong>Mixed GC</strong>模式。</p><p>G1虽然也是基于分代收集理论设计，但是G1的<strong>分代不是固定</strong>的，它<strong>把连续的Java堆划分为多个大小相等的区域（Region），每一个Region都可以扮演新生代的Eden、Survivor和老年代</strong>。（使用参数<code>-XX: G1HeapRegionSize</code>指定Region大小，取值范围为1~32MB，为2的N次幂）G1收集器对扮演不同代的Region采取不同策略去处理。Region中还有一类特殊的<strong>Humongous区域（大多数时候被视为老年代）</strong>，专门用于存储大对象（超过Region容量一半的对象），对于超过整个Region容量的超级大对象，会被存放在N个连续的Humongous Region中。</p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内（使用参数<code>-XX: MaxGCPauseMillis</code>指定收集停顿时间），优先处理回收价值最大的Region。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong>：标记GC Roots能直接关联到的对象，需要短暂停顿线程，而且是借用进行Minor GC的时候同步完成，实际上没有额外的停顿。</li><li><strong>并发标记</strong>：从GC Root开始进行可达性分析，找出要回收的对象，虽然耗时很长，但可以与用户程序并发执行。</li><li><strong>最终标记</strong>：修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>筛选回收</strong>：<em>暂停用户线程，由多条收集器线程并发执行</em>。对各Region的回收价值和成本进行排序，根据用户期望的停顿时间进行回收，把<strong>被回收的Region中的那部分存活对象</strong>复制到空的Region中，再清理掉整个旧的Region全部空间。</li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><p><img src="http://typora.lemonchan.top/image-20220302231805786.png" alt="image-20220302231805786"></p><h3 id="8、ZGC-收集器"><a href="#8、ZGC-收集器" class="headerlink" title="#8、ZGC 收集器"></a><a href="#_4-8-zgc-%E6%94%B6%E9%9B%86%E5%99%A8">#</a>8、ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>详情可以看 ： <a href="http://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://javaguide.cn/home/">《JavaGuide面试指南》</a></p><p><a href="http://www.cnblogs.com/sunfie/p/5156370.html">《JVM学习之强引用、弱引用、软引用、虚引用》</a></p><p>《深入理解Java虚拟机 第三版》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-1049. 最后一块石头的重量 II</title>
      <link href="/posts/a932a26b.html"/>
      <url>/posts/a932a26b.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii">https://leetcode-cn.com/problems/last-stone-weight-ii</a></p><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p><blockquote><ul><li>1 &lt;&#x3D; stones.length &lt;&#x3D; 30</li><li>1 &lt;&#x3D; stones[i] &lt;&#x3D; 100</li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br><span class="line"></span><br><span class="line">输入：stones = [31,26,33,21,40]</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">输入：stones = [1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>转换成01背包问题。</p><p>明确一个问题：<strong>设置两个区域，分别是+和 –</strong> 。每次取一组石头(a,b)，规定a&gt;&#x3D;b，a放在区域+，b放在区域 – 。<strong>如果两者相减产生一个新石头（a-b），若这个新石头被挪到区域+，则依然是(a-b)。若被挪到区域 – ，则变成了(b-a)，即把a和b交换区域</strong>。</p><p>​        因此<strong>实际上不会出现新石头</strong>。只需要将所有石头分成两个区域，然后用两个区域相减就得到结果。</p><p>​        SUM&#x3D;A+B    RES&#x3D;A-B&#x3D;SUM-B-B</p><p>​        要想RES最小，则B要最接近SUM&#x2F;2。因此可以转化成求大小为SUM&#x2F;2可以存放多少个石头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:stones)&#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出背包大小</span></span><br><span class="line">        <span class="type">int</span> half=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 用两个数组，分别存放当前dp数组和上一个dp数组</span></span><br><span class="line">        <span class="type">int</span> []old=<span class="keyword">new</span> <span class="title class_">int</span>[half+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> []dp=<span class="keyword">new</span> <span class="title class_">int</span>[half+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 当前背包最大可以放入前i个石头中的重量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=half;j++)&#123; </span><br><span class="line">                dp[j]=old[j];</span><br><span class="line">                <span class="keyword">if</span>(stones[i]&lt;=j) dp[j]=Math.max(dp[j],old[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span>[] temp=old;</span><br><span class="line">            old=dp;</span><br><span class="line">            dp=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum-old[half]-old[half];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记-75.颜色分类</title>
      <link href="/posts/cd844bc9.html"/>
      <url>/posts/cd844bc9.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br><span class="line"></span><br><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在原数组的左右两端设置双指针，左边指针记录红色，右边指针记录蓝色。把红色蓝色放在正确的位置上，则白色也会在正确位置上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 遍历到红色，而且当前遍历点比红色可插入点大，则交换位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>&amp;&amp;i&gt;left)&#123;</span><br><span class="line">                swap(nums,left,i);</span><br><span class="line">                <span class="comment">// 交换后当前位置需要继续判断，i--</span></span><br><span class="line">                i--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">2</span>&amp;&amp;right&gt;i)&#123;</span><br><span class="line">               <span class="comment">// 遍历到蓝色，而且当前遍历点比蓝色可插入点小，则交换位置</span></span><br><span class="line">                swap(nums,right,i);</span><br><span class="line">                <span class="comment">// 交换后当前位置需要继续判断，i--</span></span><br><span class="line">                i--;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记-Java内存区域</title>
      <link href="/posts/34b7e518.html"/>
      <url>/posts/34b7e518.html</url>
      
        <content type="html"><![CDATA[<p>本文参考JavaGuide的Java面试指南精简所写，加入自己个人理解。仅用于个人学习整理。如无特别说明，都是以HotSpot为例。</p><h2 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h2><p><img src="http://typora.lemonchan.top/image-20220204143954772.png" alt="image-20220204143954772"></p><h3 id="1、堆"><a href="#1、堆" class="headerlink" title="1、堆"></a>1、堆</h3><ol><li><p>是JVM管理的内存中最大的一块，是各个线程共享的内存区域，随虚拟机的启动而创建。几乎所有的实例对象都在此分配内存。</p></li><li><p>堆是发生GC的内存区域，99％的GC都发生在堆中。</p></li><li><p>堆既可以被实现成固定大小，也可以是可扩展的。当内存不足以完成分配，堆扩展也失败时会抛出OOMError</p></li><li><p>堆中的分代：由于现代的垃圾回收器大部分是基于分代收集理论设计的，因此需要对堆进行分代来搭配工作，<u><strong>但并不是所有的虚拟机中堆都是分代的</strong></u>。经典分代如下：</p><p><img src="http://typora.lemonchan.top/image-20220204145136632.png" alt="image-20220204145136632"></p><ol><li>新生代：分为三个区域—&gt;一个Eden 区，两个Survivor区（From和To）</li><li>老年代：当对象在新生代经历了一定次数的GC仍存活时，进入老年代</li><li>永久代（在jdk1.8以后被移除）</li><li>关于分代的意义详见常见的GC算法</li></ol></li></ol><h3 id="2、方法区"><a href="#2、方法区" class="headerlink" title="2、方法区"></a>2、方法区</h3><ol><li>方法区跟堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量（放在方法区的常量池中）、静态变量（JDK1.7以后静态变量存放在堆的Class对象中）、方法信息、即时编译器（JIT）编译后的代码缓存等元数据。也称为“非堆”（Non-Heap）。</li><li>方法区与永久代、元空间的关系：<ol><li>JDK1.8以前，HotSpot使用永久代来实现方法区，与堆共用一套GC算法。</li><li>JDK1.8以后，HotSpot与其他的虚拟机一样，用元空间（元空间位于直接内存中）实现方法区。</li></ol></li><li>方法区与Class对象：<ol><li>方法区中存放的是直接从<code>.class</code>文件中读取的元数据，而Class对象是加载完成的产品</li><li><u><strong>注意：Class对象是在堆中不是在方法区中！！！</strong></u></li></ol></li></ol><h3 id="3、虚拟机栈"><a href="#3、虚拟机栈" class="headerlink" title="3、虚拟机栈"></a>3、虚拟机栈</h3><ol><li>是线程私有的、描述的是Java方法执行的线程内存模型，栈中存放的是一个个栈帧。</li><li>每个方法被调用的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息。我们常说的<strong>栈内存</strong>指的就是栈帧中的<strong>局部变量表</strong>，以局部变量槽（32位）为基本存储空间，用于存储编译期可知的基本数据类型和引用类型（32位），<strong>局部变量表使用的局部变量槽数量在编译时已确定。</strong></li><li>方法执行完毕后（包括return、抛出异常），该栈帧弹出。</li><li>若栈可以扩展，则扩展时如果内存不足，会抛出OutOfMemoryError。</li><li>当栈的深度大于虚拟机所允许的深度，就会抛出StackOverflowError。</li></ol><h3 id="4、本地方法栈"><a href="#4、本地方法栈" class="headerlink" title="4、本地方法栈"></a>4、本地方法栈</h3><ol><li>是线程私有的，类似于虚拟机栈，但是其是为了执行本地（Native）方法而服务的，每次调用本地方法都会生成一个栈帧压入本地方法栈中。<ul><li>本地方法即使用非Java语言实现的方法，在本地方法库中实现。</li></ul></li><li>若栈可以扩展，则扩展时如果内存不足，会抛出OutOfMemoryError。</li><li>当栈的深度大于虚拟机所允许的深度，就会抛出StackOverflowError。</li></ol><h3 id="5、程序计数器"><a href="#5、程序计数器" class="headerlink" title="5、程序计数器"></a>5、程序计数器</h3><ol><li>是线程私有的，用于记录该线程下一条执行的字节码的位置。通过改变程序计数器的值可以实现顺序执行、分支、循环、跳转、异常处理、线程恢复等功能。</li><li>存在意义：实现代码的流程控制、在线程切换时保存当前线程的执行状态，待线程被切换回来时能迅速恢复运行。</li></ol><h3 id="6、运行时常量池"><a href="#6、运行时常量池" class="headerlink" title="6、运行时常量池"></a>6、运行时常量池</h3><ol><li>是线程共享的，是方法区的一部分。用于存放编译期生成的各种字面量与符号引用，在类加载后存放到运行时常量池中。</li><li>运行期间也可以将新的常量放入到常量池中，比如String类的Interm()方法。</li><li><u><strong>注意：</strong></u>在JDK1.7以后，字符串常量池与运行时常量池分离，字符串常量池并入了堆内存中，而运行时常量池仍在方法区中。</li></ol><h3 id="7、字符串常量池"><a href="#7、字符串常量池" class="headerlink" title="7、字符串常量池"></a>7、字符串常量池</h3><ol><li><p>编译期可以确定值得字符串（即字符串常量）、由字符串常量拼接而成得字符串<u><strong>（由于编译器的优化，把多个字符串常量折叠成一个）</strong></u>，JVM会将其存入字符串常量池</p></li><li><p>字符串用final关键字声明后，编译器会当作常量处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>通过new String()创建的字符串，都会在堆当中新建一个对象。</p></li><li><p>使用String.interm()方法，可以将String对象存入字符串常量池中：</p><ol><li>如果字符串常量池中已存在该String对象对应的字符串，则返回常量池中该字符串的引用。</li><li>如果不存在，则在字符串常量池中新建一个相同内容的String对象，并返回引用（1.7及以前）。jdk1.8以后，字符串常量池在堆中，因此可以直接将堆中该对象的引用存入常量池用，避免不必要的开销。</li></ol></li><li><p>思考题：String s1&#x3D;new String(“abc”);创建了几个对象？</p><p> 答：创建1个或2个对象。    </p><ol><li>如果字符串常量池中没有该字符串，则会在堆空间创建一个对象，在字符串常量池创建一个对象</li><li>如果字符串常量池中有该字符串，则只会在堆空间创建一个对象</li></ol></li></ol><h3 id="8、直接内存"><a href="#8、直接内存" class="headerlink" title="8、直接内存"></a>8、直接内存</h3><p> 直接内存不属于虚拟机运行时的数据区域，不受Java堆的限制，但受物理内存大小和处理器寻址空间的限制。</p><h2 id="二、HotSpot中的对象"><a href="#二、HotSpot中的对象" class="headerlink" title="二、HotSpot中的对象"></a>二、HotSpot中的对象</h2><h3 id="1、对象的创建"><a href="#1、对象的创建" class="headerlink" title="1、对象的创建"></a>1、对象的创建</h3><p> <img src="http://typora.lemonchan.top/image-20220204152409278.png" alt="image-20220204152409278"></p><ol><li>检查类是否已加载：检查是否能在常量池中找到该类的符号引用，并检查该符号引用对应的类是否已加载，如果没有，则先执行类加载。</li><li>给对象实例分配内存：根据该类的Class对象获取新生对象所需的内存大小，然后从Java堆中申请相应大小的内存。<ol><li><strong>内存分配的两种方式</strong>：<ol><li><strong>指针碰撞</strong>：空闲内存和已使用内存之间有一个分界值指针，内存分配时只需将该指针向空闲内存方向移动相应的位置即可</li><li><strong>空闲列表</strong>：用表来记录空闲内存块，内存分配时找到一块足够大的块来分配给实例，然后更新列表</li></ol></li><li><strong>内存分配的并发问题：</strong><ol><li><strong>CAS+失败重试</strong>：用CAS来保证操作的原子性，不会出现一块内存同时分配给两个对象。失败重试保证了在内存充足的情况下分配成功。</li><li><strong>TLAB</strong>：为每一个线程预先在Eden区分配一块内存，称为TLAB，该线程创建对象时，首先将TLAB中的内存分配，当TLAB不足时再使用CAS+失败重试来进行内存分配。</li></ol></li></ol></li><li>将分配到的内存初始化为0：保证了对象的实例字段在Java代码中不赋初值也可以直接使用。</li><li>生成对象头：记录该对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</li><li>初始化对象：按照程序员的意愿初始化对象</li></ol><h3 id="2、对象的数据格式"><a href="#2、对象的数据格式" class="headerlink" title="2、对象的数据格式"></a>2、对象的数据格式</h3><ol><li>分为3块区域：<strong>对象头、实例数据、对齐填充</strong></li><li>对象头：<ul><li>对象自身的运行时数据（哈希码、GC分代年龄等）</li><li>类型指针：指向类元数据（Class对象）</li></ul></li><li>实例数据：存储对象真正的有效信息，如：对象的方法、成员变量</li><li>对齐填充：起占位作用。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须为8字节的整数倍。</li></ol><h3 id="3、对象的访问定位"><a href="#3、对象的访问定位" class="headerlink" title="3、对象的访问定位"></a>3、对象的访问定位</h3><p> 对象的访问方式由虚拟机实现而定，主要有两种</p><ol><li><p>句柄：Java堆中将可能划分出一块内存来作为句柄池，reference类型中存储的是对象的句柄地址，而句柄中存储对象实例数据（成员变量）与类型数据（静态成员变量）各自具体的地址信息。好处是稳定句柄地址，对象移动时（发生GC）只需要修改句柄中的实例数据指针即可，不需要修改reference，但访问时需要两次访问。</p><p><img src="http://typora.lemonchan.top/image-20220204155319377.png" alt="image-20220204155319377"></p></li><li><p>直接指针：reference类型中存储的是对象在堆中的地址。访问时只需要一次访问，速度更快，但是要考虑如何放置类型数据的相关信息。<img src="http://typora.lemonchan.top/image-20220204155646017.png" alt="image-20220204155646017"></p></li></ol><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><blockquote><p><a href="http://javaguide.cn/home/">《JavaGuide面试指南》</a></p><p>《深入理解Java虚拟机 第三版》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
