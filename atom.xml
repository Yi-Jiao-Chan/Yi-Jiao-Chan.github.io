<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柠檬的个人博客</title>
  <icon>https://www.gravatar.com/avatar/ce19897a92677092dba1f768f6eeb22e</icon>
  
  <link href="http://yi-jiao-chan.github.io/atom.xml" rel="self"/>
  
  <link href="http://yi-jiao-chan.github.io/"/>
  <updated>2022-04-12T15:55:02.639Z</updated>
  <id>http://yi-jiao-chan.github.io/</id>
  
  <author>
    <name>Lemon Chan</name>
    <email>yi_jiao_chan@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java学习笔记-SSM整合</title>
    <link href="http://yi-jiao-chan.github.io/posts/32ce1542.html"/>
    <id>http://yi-jiao-chan.github.io/posts/32ce1542.html</id>
    <published>2022-04-12T15:22:00.000Z</published>
    <updated>2022-04-12T15:55:02.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h2><p><strong>mybatis-spring.xml：把mybatis整合进spring</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1.引入数据库配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--2.配置数据源：数据源有非常多，可以使用第三方的，也可用Spring的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--3.配置sqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置mybatis配置文件所在位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此处实际上可以设置所有mybatis-config.xml中的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--4.配置mapper扫描器，扫描所有被@Mapper标记的接口，根据对应的xml文件，生成mapper并装配成bean，id为接口名的首字母小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--扫描的包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.lemon.dao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置sqlSessionFactory的name，用于存在多个Factory时的byName装配，可省略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--5.创建事务管理器并配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--6.为事务管理器注册 “注解” 驱动   在需要事务管理的方法上使用@Transactional--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--7.开启dao层注解包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lemon.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>mybatis-config.xml：mybatis的配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lemon.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置映射器，用于将编写有SQL代码XML映射文件引入到MyBatis中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lemon.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring整合Spring-MVC"><a href="#Spring整合Spring-MVC" class="headerlink" title="Spring整合Spring-MVC"></a>Spring整合Spring-MVC</h2><p><strong>springmvc-servlet.xml：springmvc的配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--1.开启mvc的注解配置，自动装配了HandlerMapping和HandlerAdapter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--2.配置默认Servlet，用于处理静态资源--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在 WEB 容器启动的时候会在上下文中定义一个 DefaultServletHttpRequestHandler，</span></span><br><span class="line"><span class="comment">    它会对DispatcherServlet的请求进行处理。</span></span><br><span class="line"><span class="comment">        1.如果该请求已经作了映射，那么会接着交给后台对应的处理程序。</span></span><br><span class="line"><span class="comment">        2.如果没有作映射，就交给 WEB 应用服务器默认的 Servlet 处理，从而找到对应的静态资源。</span></span><br><span class="line"><span class="comment">        3.再找不到资源，404报错。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--3.配置视图解析器并设置前缀后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>web.xml：web应用的配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--1.注册Dispatcherservlet，拦截所有请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.配置CharacterEncodingFilter，拦截所有请求，把编码设为UTF-8--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><p><strong>applicationContext.xml：spring的配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1.引入mybatis和springmvc中spring部分的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;mybatis-spring.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;springmvc-servlet.xml&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--2.开启bean注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--3.设置要扫描的包，注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lemon.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lemon.service&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lemon.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring整合Mybatis&quot;&gt;&lt;a href=&quot;#Spring整合Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Spring整合Mybatis&quot;&gt;&lt;/a&gt;Spring整合Mybatis&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;mybatis-sp</summary>
      
    
    
    
    <category term="leetcode" scheme="http://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="http://yi-jiao-chan.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-组合模式</title>
    <link href="http://yi-jiao-chan.github.io/posts/470033c3.html"/>
    <id>http://yi-jiao-chan.github.io/posts/470033c3.html</id>
    <published>2022-04-11T05:02:00.000Z</published>
    <updated>2022-04-11T05:02:29.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><ul><li>组合模式：组合多个对象形成树形结构以表示”部分-整体“的结构层次。组合模式对单个对象（即叶子对象）和组合对象（容器对象）的使用具有一致性。</li><li>对象结构型模式</li><li>将对象组织到树形结构中，可以用来描述整体与部分的关系</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Component：抽象构件</li><li>Left：叶子构件（例子：文件）</li><li>Composite：容器构件（例子：文件夹）</li></ul><p><strong>透明组合模式实现：</strong></p><p><img src="http://typora.lemonchan.top/image-20220411124549322.png" alt="image-20220411124549322"></p><p>抽象构件声明了所有用于管理成员对象的方法，叶子构件和容器构件所提供的方法一致，客户端可以一致地对待所有对象。但实际上叶子构件和容器构件在本质上是有区别的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加子文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Component c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除子文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Component c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第i个子文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; childes;</span><br><span class="line">    Composite()&#123;</span><br><span class="line">        childes=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*递归调用子文件的处理方法*/</span></span><br><span class="line">        <span class="keyword">for</span>(Component c:childes)&#123;</span><br><span class="line">            c.operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        childes.add(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> childes.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(childes.size()&lt;=i) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> childes.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*处理的业务逻辑*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>安全组合模式实现：</strong></p><p><img src="http://typora.lemonchan.top/image-20220411124600301.png" alt="image-20220411124600301"></p><p>安全组合模式中，<strong>抽象构件只有当前对象的处理方法</strong>，没有生命任何用于管理成员对象的方法，而是<strong>在容器构件类中声明并实现</strong>，叶子对象则无法调用到这些方法。缺点是不够透明，<strong>客户端不能直接针对抽象构件类进行编程，必须区别地对待叶子构件和容器构件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; childes;</span><br><span class="line">    Composite()&#123;</span><br><span class="line">        childes=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*递归调用子文件的处理方法*/</span></span><br><span class="line">        <span class="keyword">for</span>(Component c:childes)&#123;</span><br><span class="line">            c.operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        childes.add(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> childes.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(childes.size()&lt;=i) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> childes.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*处理的业务逻辑*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p>在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行“吃”方法，实际上就是吃其中的水果。使用组合模式模拟该场景。</p><p><img src="http://typora.lemonchan.top/image-20220411125727377.png" alt="image-20220411125727377"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat apple!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span> <span class="keyword">extends</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat Banana!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pear</span> <span class="keyword">extends</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat Pear!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plate</span> <span class="keyword">extends</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MyElement&gt; childes;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Plate</span><span class="params">()</span>&#123;</span><br><span class="line">        childes=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(MyElement e:childes)&#123;</span><br><span class="line">            e.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MyElement element)</span>&#123;</span><br><span class="line">        childes.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MyElement element)</span>&#123;</span><br><span class="line">        childes.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，<strong>让客户端忽略了层次的差异，方便对整个层次结构进行控制</strong></li><li><strong>客户端可以一致地使用一个组合结构或其中单个对象</strong>，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li><li>增加新的容器构件和叶子构件都很方便，符合开闭原则</li><li>为树形结构的面向对象实现提供了一种灵活的解决方案</li></ul></li><li><p>缺点：</p><ul><li>在增加新构件时很难对容器中的构件类型进行限制</li></ul></li><li><p>使用场景：</p><ul><li>在具有整体和部分的层次结构中，希望通过一种方式<strong>忽略整体与部分的差异，客户端可以一致地对待它们</strong></li><li>在一个使用面向对象语言开发的系统中需要处理一个<strong>树形结构</strong></li><li>在一个系统中能够<strong>分离出叶子对象和容器对象</strong>，而且它们的<strong>类型不固定</strong>，需要增加一些新的类型</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;组合模式：组合多个对象形成树形结构以表示”部分-整体“的结构层次。组合模式对单个对象（即叶子对象）和组合对象（容</summary>
      
    
    
    
    <category term="编程思想" scheme="http://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-桥接模式</title>
    <link href="http://yi-jiao-chan.github.io/posts/ceb5cc8d.html"/>
    <id>http://yi-jiao-chan.github.io/posts/ceb5cc8d.html</id>
    <published>2022-04-11T03:02:00.000Z</published>
    <updated>2022-04-11T05:02:29.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><ul><li><strong>桥接模式将抽象部分与它的实现部分分离</strong>，使得它们都可以独立地变化，属于<strong>对象结构性模式</strong>。又称为柄体模式或接口模式</li><li>用抽象关联取代了多层继承</li><li>将类之间的静态继承关系转换成动态的对象组合关系</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Abstraction：抽象类</li><li>RefinedAbstraction：扩充抽象类</li><li>Implementor：实现类接口</li><li>ConcreteImplementor：具体实现类</li></ul><p><img src="http://typora.lemonchan.top/image-20220411101505338.png" alt="image-20220411101505338"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p>现需要提供<strong>大中小3种型号的画笔</strong>，能够<strong>绘制5种不同颜色</strong>，如果使用蜡笔，我们需要准备3*5&#x3D;15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5&#x3D;8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。</p><p><img src="http://typora.lemonchan.top/image-20220411101737698.png" alt="image-20220411101737698"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现类接口*/</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bePaint</span><span class="params">(String penType, String content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体实现类*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Red</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bePaint</span><span class="params">(String penType, String content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span> + penType + <span class="string">&quot;毛笔蘸取&quot;</span> + <span class="string">&quot;红色墨水书写内容：&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Green</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bePaint</span><span class="params">(String penType, String content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span> + penType + <span class="string">&quot;毛笔蘸取&quot;</span> + <span class="string">&quot;绿色墨水书写内容：&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bePaint</span><span class="params">(String penType, String content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span> + penType + <span class="string">&quot;毛笔蘸取&quot;</span> + <span class="string">&quot;蓝色墨水书写内容：&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">White</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bePaint</span><span class="params">(String penType, String content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span> + penType + <span class="string">&quot;毛笔蘸取&quot;</span> + <span class="string">&quot;白色墨水书写内容：&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Black</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bePaint</span><span class="params">(String penType, String content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span> + penType + <span class="string">&quot;黑色墨水书写内容：&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*抽象类*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pen</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(String content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*抽象扩充类*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallPen</span> <span class="keyword">extends</span> <span class="title class_">Pen</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmallPen</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        color.bePaint(<span class="string">&quot;小号毛笔&quot;</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MiddlePen</span> <span class="keyword">extends</span> <span class="title class_">Pen</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MiddlePen</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        color.bePaint(<span class="string">&quot;中号毛笔&quot;</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigPen</span> <span class="keyword">extends</span> <span class="title class_">Pen</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BigPen</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        color.bePaint(<span class="string">&quot;大号毛笔&quot;</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li>分离抽象接口及其实现部分，取代了多层继承方案，减少了子类个数</li></ul></li><li><p>提高系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统</p></li><li><p>缺点：</p><ul><li>增加系统设计难度，由于关联关系建立在抽象层，<strong>要求开发者一开就要针对抽象层进行设计与编程</strong></li><li>正确识别出系统中两个独立变化的维度并不是一件容易的事情</li></ul></li><li><p>使用场景：</p><ul><li>需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间简历静态的继承关系</li><li><strong>抽象部分和实现部分可以以继承的方式独立扩展</strong>而互不影响</li><li><strong>一类存在两个（或多个）独立变化的维度</strong>，而且这两个（或多个）维度都需要独立地进行扩展</li><li>不希望使用继承或因为多层继承而导致系统类的个数急剧增加的系统</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;桥接模式将抽象部分与它的实现部分分离&lt;/strong&gt;，使得它们都可以独立地变化，属于&lt;stro</summary>
      
    
    
    
    <category term="编程思想" scheme="http://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://yi-jiao-chan.github.io/posts/210c1e9b.html"/>
    <id>http://yi-jiao-chan.github.io/posts/210c1e9b.html</id>
    <published>2022-04-11T02:20:00.000Z</published>
    <updated>2022-04-11T05:02:29.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>适配器模式属于<strong>结构型模式</strong>，结构型模式描述了如何<strong>将类或者对象结合在一起</strong>形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。结构型模式又分为类结构型模式和对象结构型模式：</p><ul><li><strong>类结构性模式</strong>：关心类的组合，由多个类可以组合成一个更大的系统，一般只存在继承关系和实现（接口）关系</li><li><strong>对象结构性模式</strong>：关心类和对象的组合，通过关联关系在一个类中定义另一个类的实例对象，然后通过该实例对象调用另一个类的方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分的结构型模式都是对象结构性模式。</li></ul><blockquote><p>合成复用原则( Composite Reuse Principle, CRP )又叫组合&#x2F;聚合复用原则( CARP)。 它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏代换原则。合成复用原则同里氏代换原则相辅相成的，两者都是<a href="https://so.csdn.net/so/search?q=%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99&spm=1001.2101.3001.7020">开闭原则</a>的具体实现规范。</p></blockquote><ul><li>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式<strong>使接口不兼容的那些类可以一起工作。</strong></li><li>适配器模式<strong>既可以作为类结构型模式，也可以作为对象结构型模式</strong></li><li>定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Target：目标抽象类（客户希望的接口）</li><li>Adapter：适配器类（适配Target和Adaptee）</li><li>Adaptee：适配者类（已有的实现类）</li></ul><p><strong>类结构型模式实现：</strong></p><p><img src="http://typora.lemonchan.top/image-20220411094215570.png" alt="image-20220411094215570"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="comment">// 通过继承和实现接口来获得Adaptee中的内容和Target的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>&#123;</span><br><span class="line">        spuer.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象结构性模式实现：</strong></p><p><img src="http://typora.lemonchan.top/image-20220411094712018.png" alt="image-20220411094712018"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="comment">// 继承获得Target的接口，组合获得Adaptee的实现</span></span><br><span class="line">    Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p>现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法<code>cry()</code>、机器人移动方法<code>move()</code>等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑，使用适配器模式进行系统设计。</p><p><img src="http://typora.lemonchan.top/image-20220411095037761.png" alt="image-20220411095037761"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wang</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗四条腿跑跑跑！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">DogAdapter</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;机器人模仿狗叫喊：&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.wang();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;机器人模仿狗移动：&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li><li>增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li><li>灵活性和扩展性非常好</li><li><strong>类适配器模式：置换一些适配者的方法很方便</strong></li><li><strong>对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类</strong></li></ul></li><li><p>缺点：</p><ul><li>类适配器：一次最多只能适配一个适配者类、适配者类不能为最终类、目标抽象类只能是接口</li><li>对象适配器：适配器中置换适配者类的某些方法比较麻烦</li></ul></li><li><p>使用场景：</p><ul><li>系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码</li><li>创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;适配器模式属于&lt;strong&gt;结构型模式&lt;/strong&gt;，结构型模式描述了如何&lt;strong&gt;将类或者对象结合在一起&lt;/s</summary>
      
    
    
    
    <category term="编程思想" scheme="http://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://yi-jiao-chan.github.io/posts/69e7b86f.html"/>
    <id>http://yi-jiao-chan.github.io/posts/69e7b86f.html</id>
    <published>2022-03-24T07:51:00.000Z</published>
    <updated>2022-03-24T08:36:48.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>确保一个类<strong>只有一个实例</strong>，且在类的内部<strong>自行进行实例化</strong>并<strong>向整个系统提供这个实例</strong>，是一种<strong>对象创建型模式</strong></p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Singleton：单例类</li></ul><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p><code>Singleton</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="comment">// 双重检验避免同一时刻加锁然后重复初始化</span></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>懒汉式：实现了懒加载，需要用到该实例的时候才进行初始化，但要避免多线程同时初始化，需要进行双重检测和加锁，系统性能受一定影响。</p><p>饿汉式：无需考虑多线程同时访问的问题，调用速度更快，但是由于类加载时就进行了初始化，因此系统资源的利用率稍低，系统加载速度稍慢。</p><ul><li><p>优点：</p><ul><li>提供了<strong>对唯一实例的受控访问</strong></li><li>可以<strong>节约系统资源，提高系统的性能</strong></li><li>允许看一遍数目的实例<strong>（多例类）</strong></li></ul></li><li><p>缺点：</p><ul><li>扩展困难（缺少抽象层）</li><li>单例类的职责过重</li><li>由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失</li></ul></li><li><p>使用场景：</p><ul><li>系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象</li></ul></li><li><p>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;确保一个类&lt;strong&gt;只有一个实例&lt;/strong&gt;，且在类的内部&lt;strong&gt;自行进行实例化&lt;/strong&gt;并&lt;s</summary>
      
    
    
    
    <category term="编程思想" scheme="http://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="http://yi-jiao-chan.github.io/posts/92a38b2.html"/>
    <id>http://yi-jiao-chan.github.io/posts/92a38b2.html</id>
    <published>2022-03-24T07:27:00.000Z</published>
    <updated>2022-03-26T10:11:14.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>使用了原型模式的类，可以通过<strong>复制该类的实例化对象，来创建新的对象。</strong></p><p>原型模式允许一个原型对象创建一个或多个同类型的其他对象，而无需知道任何创建的细节。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Client：客户类</li><li>Prototype：抽象原型类</li><li>ConcretePrototype：具体原型者</li></ul><p><img src="http://typora.lemonchan.top/image-20220324153149241.png" alt="image-20220324153149241"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p><code>Prototype</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> implement Cloneable&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"><span class="keyword">protected</span> String date;</span><br><span class="line"><span class="keyword">protected</span> String content;</span><br><span class="line">    <span class="comment">// 省略Setter、Getter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Prototype <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="keyword">return</span> (Prototype) <span class="built_in">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcretePrototype</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> extend Prototype&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span>&#123;</span><br><span class="line">Prototype cloneObj=<span class="keyword">new</span> <span class="title class_">WeeklyLog</span>();</span><br><span class="line">cloneObj.setContent(<span class="keyword">new</span> <span class="title class_">String</span>(content));</span><br><span class="line">cloneObj.setDate(<span class="keyword">new</span> <span class="title class_">String</span>(date));</span><br><span class="line">cloneObj.setName(<span class="keyword">new</span> <span class="title class_">String</span>(name));</span><br><span class="line">System.out.println(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Client</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prototype</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line">Prototype clonePro=pro.clone();</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>java中Object类实现了clone方法，是浅拷贝的方式（对于成员变量，如果是基本数据类型，则进行值拷贝，如果是引用数据类型，则直接把原来的引用值拷贝一份，即<strong>拷贝后对象的该成员变量与原来对象的该成员变量在内存中是同一个对象</strong>）</p><ul><li><p>优点：</p><ul><li>简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率，无需工厂</li><li>扩展性较好</li><li>可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作</li></ul></li><li><p>缺点：</p><ul><li>需要为每一个类配备一个克隆方法，该克隆方法位于类的内部，当对已有类进行改造时，需要修改源代码，违背了开闭原则。</li><li>实现深克隆需要编写较为复杂的代码，如果对象之间存在剁成嵌套关系时，需要对每层对象都实现深克隆，实现麻烦</li></ul></li><li><p>使用场景：</p><ul><li>创建新对象的成本较大</li></ul></li><li><p>新对象与旧对象仅有小部分差别</p><ul><li>系统需要保存对象的状态</li></ul></li><li><p>避免使用分层次的工厂类来创建分层次的对象</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;使用了原型模式的类，可以通过&lt;strong&gt;复制该类的实例化对象，来创建新的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原型模式</summary>
      
    
    
    
    <category term="编程思想" scheme="http://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="http://yi-jiao-chan.github.io/posts/2a48474d.html"/>
    <id>http://yi-jiao-chan.github.io/posts/2a48474d.html</id>
    <published>2022-03-24T03:44:00.000Z</published>
    <updated>2022-03-26T10:11:09.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>一步一步<strong>创建一个复杂的对象</strong>，允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户<strong>不需要知道内部的具体构建细节（比如成员遍历的赋值顺序）</strong>。建造者模式属于<strong>对象创建型模型</strong>。</p><p><em>建造者模式是使用一个建造者，用多个方法实现对象中各部分的构建。用一个指挥者以一定的顺序来调用建造者的方法，最后生成一个对象。</em></p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Product：产品类</li><li>Builder：抽象建造者</li><li>ConcreteBuilder：具体建造者</li><li>Director：指挥者</li></ul><p><img src="http://typora.lemonchan.top/image-20220324115550702.png" alt="image-20220324115550702"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object A;</span><br><span class="line">    <span class="keyword">private</span> Object B;</span><br><span class="line">    <span class="keyword">private</span> Object C;</span><br><span class="line">    <span class="comment">// 省略ABC的getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Builder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Product product=<span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildC</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteBuilder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> extend Builder&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 构造产品的变量A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 构造产品的变量B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildC</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">// 构造产品的变量C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Director</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.builder=builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuilder</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.builder=builer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">builder.buildA();</span><br><span class="line">        builder.buildC();</span><br><span class="line">builder.buildB();</span><br><span class="line"><span class="keyword">return</span> builder.getResult();</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>Client</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Builder builder=<span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>();</span><br><span class="line">Director director=<span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">Product product=director.construct();</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li>客户端<strong>不必知道产品内部组成的细节</strong>，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li><strong>每一个具体建造者都相对独立</strong>，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则</li><li>可以更加精细<strong>控制产品的创建过程</strong></li></ul></li><li><p>缺点：</p><ul><li>不同建造者所创建的产品<strong>具有较多的共同点</strong>（是同一个类），其组成部分相似，如果产品之间的差异性很大，则不适用建造者模式</li><li>如果产品的<strong>内部变化复杂</strong>，可能会需要定义很多具体建造类来<strong>实现这种变化</strong>，会使得系统变得很庞大，增加了系统的理解难度和运行成本。</li></ul></li><li><p>使用场景：</p><ul><li>需要生成的产品具有<strong>复杂的内部结构</strong>，通常包含多个成员变量</li></ul></li><li><p>需要生成的产品对象的属性相互依赖，<strong>需要指定产品内部组成的生成顺序</strong></p><ul><li>对象的创建过程独立于创建该对象的类。即：对象是建造者创建的，但是创建过程是由指挥者控制的。</li></ul></li><li><p>隔离复杂对象的创建和使用，使得相同的创建过程可以创建不同的产品（同一个指挥者但是不同建造者）。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;p&gt;一步一步&lt;strong&gt;创建一个复</summary>
      
    
    
    
    <category term="编程思想" scheme="http://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-抽象工厂模式</title>
    <link href="http://yi-jiao-chan.github.io/posts/5a86ebac.html"/>
    <id>http://yi-jiao-chan.github.io/posts/5a86ebac.html</id>
    <published>2022-03-24T02:25:00.000Z</published>
    <updated>2022-03-26T10:10:48.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列<strong>相关</strong>或<strong>相互依赖的对象</strong>的接口，而无需执行它们具体的类，属于对象创建型模式。<br>与工厂方法模式的区别是：抽象工厂模式中，一个工厂负责生产多个产品。而工厂方法模式一个工厂只负责生产一个产品</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Product：抽象产品类，是工厂生产的所有产品的基类&#x2F;接口</li><li>Factory：抽象工厂类，是所有工厂的父类，定义工厂的接口</li><li>ConcreteProduct：具体产品类</li><li>ConcreteFactory：具体工厂类</li></ul><p><img src="http://typora.lemonchan.top/image-20220324104545067.png" alt="image-20220324104545067"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AirConditioner</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeTemperature</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteProduct</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierAC</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeTemperature</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier空调正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseAC</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeTemperature</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense空调正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Tv <span class="title function_">productTv</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> AirConditioner <span class="title function_">productAC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierFactory</span> extend Factory&#123;</span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">productTv</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Haier电视！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> AirConditioner <span class="title function_">ProductAC</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Haier空调！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierAC</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseFactory</span> extend Factory&#123;</span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">productTv</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Hisense电视！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> AirConditioner <span class="title function_">ProductAC</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Hisense空调！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseAC</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>优点：<ul><li>隔离了具体类的生成，使得客户端不需要知道什么被创建</li><li>当一个产品族（同一工厂生茶你的不同品种的产品）的多个对象被设计成一起工作时，保证客户端时钟只使用一个产品族中的对象</li><li>增加新的产品族很方便（增加新的品牌，只需要增加对应的产品和工厂），无需修改原有系统，符合开闭原则</li></ul></li><li>缺点：<ul><li>增加新的产品很不方便，需要修改工厂基类，修改每一个工厂，违背开闭原则。</li></ul></li><li>使用场景：<ul><li>系统不应当依赖于产品类实例如何被创建、组合和表达的细节</li><li>系统中有多个产品族，且每次只是用一个产品族</li><li>同个产品族的产品将一起使用</li><li>产品族的结构稳定（即设计完成后，不会修改产品族的组成，只会增删产品族）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列&lt;strong&gt;相关&lt;/strong&gt;或</summary>
      
    
    
    
    <category term="编程思想" scheme="http://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂方法模式</title>
    <link href="http://yi-jiao-chan.github.io/posts/89a20157.html"/>
    <id>http://yi-jiao-chan.github.io/posts/89a20157.html</id>
    <published>2022-03-24T02:00:00.000Z</published>
    <updated>2022-03-26T10:10:58.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>工厂方法模式（Factory Method Pattern）简称工厂模式，也叫<strong>虚拟构造器模式</strong>或者<strong>多态工厂模式</strong>，它属于<strong>类创建型模式</strong>。</p><p>在工厂方法模式中，有一个<strong>抽象工厂类</strong>，它定义了创建产品的接口。不同产品的<strong>工厂都是该抽象工厂的子类</strong>，负责实现该接口来生产具体的产品。这样的目的是<strong>将产品类的实例化操作交给工厂子类</strong>，通过确定工厂子类类确定实例化哪一个产品</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Product：抽象产品类，是工厂生产的所有产品的基类&#x2F;接口</li><li>Factory：抽象工厂类，是所有工厂的父类，定义工厂的接口</li><li>ConcreteProduct：具体产品类</li><li>ConcreteFactory：具体工厂类</li></ul><p><img src="http://typora.lemonchan.top/image-20220324100624337.png" alt="image-20220324100624337"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p>要求：每种品牌的电视机由相应的子工厂进程生产，每个工厂只负责一种电视机的生产。当增加新品种电视机时，无需修改原有结构，只需增加新的电视机和新的电视机工厂即可。</p><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteProduct</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TVFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">productTv</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTVFactory</span> extend TVFactory&#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">productTv</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Haier电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTVFactory</span> extend TVFactory&#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">productTv</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产Hisense电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li>向用户提供了实例化产品类的方法，并且向客户隐藏了具体哪个产品将被实例化这一细节</li><li>产品类实例化的细节完全由工厂决定</li><li>允许系统在不修改原有工厂类、产品类的情况下引入新产品，符合开闭原则</li><li>每个工厂类负责一个产品的生产，不会使得单一工厂职责过重</li></ul></li><li><p>缺点：</p><ul><li>系统中类的数量成对增加，每增加一个产品，就要增加两个类，增加了系统复杂度</li><li>增加了系统的抽象性和理解难度</li></ul></li><li><p>使用场景：</p><ul><li><p>客户端不知道需要的具体产品类，只需要知道工厂类名即可</p></li><li><p>抽象工厂通过其子类来指定创建哪个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File xmlFile=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/lab1/topic2/config.xml&quot;</span>);</span><br><span class="line">factory = (LogFactory) XMLUtil.getBean(xmlFile);</span><br><span class="line">log = factory.createLog();</span><br><span class="line">log.writeLog();</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;工厂方法模式（Factory Method Pattern）简称工厂模式，也叫&lt;strong&gt;虚拟构造器模式&lt;/strong</summary>
      
    
    
    
    <category term="编程思想" scheme="http://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-Http1.0、1.1、2.0的区别</title>
    <link href="http://yi-jiao-chan.github.io/posts/e792a541.html"/>
    <id>http://yi-jiao-chan.github.io/posts/e792a541.html</id>
    <published>2022-03-06T11:42:00.000Z</published>
    <updated>2022-03-06T12:36:04.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP1-1与1-0的区别"><a href="#HTTP1-1与1-0的区别" class="headerlink" title="HTTP1.1与1.0的区别"></a>HTTP1.1与1.0的区别</h2><ol><li>HTTP1.1默认使用长连接，而1.0默认使用短连接</li><li>HTTP1.1增加了大量的状态码，比如：<code>100(Continue)</code>——在请求大量资源时返回的预热，询问Client是否真的需要该资源</li><li>HTTP1.1在缓存上增加了许多细节，但具体实现与1.0一致。<ol><li>每个响应体都会带上一个时间，表示服务器中这些数据最后被修改的时间。</li><li>Client每次发送请求的时候都会携带对应的时间，询问服务器该资源是否过期，服务器比对Client发送过来的时间以及资源的最后修改时间，如果一致，则返回状态码为304的响应让Client从缓存取，否则返回200并带上最新资源响应体。</li></ol></li><li>HTTP1.1在请求头加入了Host字段，标记了服务器的主机名。因为一个IP地址可以由多个域名映射，一台服务器可以部署多个应用，不同的域名往往是不同的应用。DNS解析之后，会将已解析的域名替换成ip地址，此时服务器不知道客户想要访问的到底哪个应用。而HTTP1.1的Host字段就记录下了该域名，服务器就可以知道客户想要访问的应用</li><li>HTTP1.1增加了范围请求(<code>Range</code>)，可以请求某个数据的一部分（比如客户端只需要某个对象的一部分信息），也支持了断点传输。服务器可以忽略<code>Range</code>并返回全部数据，也可以返回若干<code>Range</code>响应。</li></ol><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><h3 id="SPDY：HTTP1-x的升级"><a href="#SPDY：HTTP1-x的升级" class="headerlink" title="SPDY：HTTP1.x的升级"></a>SPDY：HTTP1.x的升级</h3><p>是由Google剔除的方案，优化了HTTP1.X的请求延迟，解决了安全性，具体如下。</p><ol><li><strong>降低延迟</strong>：使用多路复用，使多个请求可以使用同一个TCP连接并发执行（长连接是串行）。</li><li><strong>请求优先级</strong>：因为多路复用可能会导致重要请求被阻塞，因此SPDY允许给不同请求设置优先级，重要的优先级会先响应。比如访问一个网站，对html内容的请求应该是最先响应，然后才是css、js、图片等。</li><li><strong>压缩请求头</strong>：HTTP1.X的请求&#x2F;响应头是文本传输，而SPDY对请求头进行压缩再传输。</li><li><strong>基于HTTPS</strong>：强制使用HTTPS加密传输。</li><li><strong>服务端推送</strong>：允许在浏览器明确发出请求前，将一些资源推送给浏览器，存放在浏览器缓存中。避免了浏览器对所有资源的分次请求，提高效率。</li></ol><h3 id="HTTP2-0：SPDY的升级"><a href="#HTTP2-0：SPDY的升级" class="headerlink" title="HTTP2.0：SPDY的升级"></a>HTTP2.0：SPDY的升级</h3><p>HTTP2.0与SPDY的不同：</p><ol><li>HTTP2.0支持明文传输，而SPDY必须使用HTTPS</li><li>HTTP2.0与SPDY的请求&#x2F;响应头压缩算法不一样</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP1-1与1-0的区别&quot;&gt;&lt;a href=&quot;#HTTP1-1与1-0的区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP1.1与1.0的区别&quot;&gt;&lt;/a&gt;HTTP1.1与1.0的区别&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;HTTP1.1默认使用长连接，而</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://yi-jiao-chan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-Https是如何加密的？</title>
    <link href="http://yi-jiao-chan.github.io/posts/ed7edf56.html"/>
    <id>http://yi-jiao-chan.github.io/posts/ed7edf56.html</id>
    <published>2022-03-05T15:28:00.000Z</published>
    <updated>2022-03-26T10:10:41.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul><li>HTTP使用明文通信（不加密），内容可能被窃听。</li><li>HTTP不验证通信双方身份，因此有可能遭遇伪装。</li><li>HTTP无法验证报文的完整性，报文可能会遭到篡改。</li></ul><p><strong>HTTPS&#x3D;HTTP+通信加密+证书+完整性保护</strong></p><h2 id="二、通信加密"><a href="#二、通信加密" class="headerlink" title="二、通信加密"></a>二、通信加密</h2><p>HTTPS同时使用了两种加密方式</p><ol><li>对称加密：加密和解密用的是同一密钥，优点是加密解密速度快，缺点是需要将密钥发送给接收方。用于HTTP通信交换报文阶段。</li><li>非对称加密：加密和解密用的是不同密钥，优点是不需要将密钥发送给接收方，缺点是加密解密速度慢。用于传输《对称加密的密钥》</li></ol><p><img src="http://typora.lemonchan.top/image-20220305233950281.png" alt="image-20220305233950281"></p><h2 id="三、证书"><a href="#三、证书" class="headerlink" title="三、证书"></a>三、证书</h2><p>如果公开密钥在传输过程中被攻击者拦截，并将公开密钥进行替换，接收端如果使用该被替换的公开密钥进行加密，则数据会被攻击方轻松破解。数字证书正是解决这种问题而出现的。</p><p><strong>数字证书</strong>：</p><ol><li>是由数字证书认证机构（CA）和其相关机关颁发的的公开密钥证书。</li><li>证书组成：证书内容（包括证书所有人、服务器公钥等信息）、加密算法、加密密文（证书内容加密的产物）</li></ol><p><strong>数字认证机构</strong>：是客户端和服务器双方都可信赖的第三方机构。</p><p><strong>证书申请过程</strong>：</p><ol><li>服务器运营人员向CA提出公开密钥的申请。</li><li>CA核实申请者身份后，将申请者提交的公开密钥、申请者信息、CA的信息等组合成证书内容，然后做数字签名（实际上是将证书内容使用SHA1算法进行hash，然后用CA的私钥对hash结果进行加密）</li><li>CA将证书内容、加密算法、数字签名组合成证书，然后交还给服务器。</li></ol><p><strong>证书如何保证安全？</strong></p><ol><li>服务器将数字证书发送给客户端，客户端收到证书后对数字证书进行验证（使用对应的CA的公钥和证书内的加密算法对数字签名进行解密，然后将证书内容使用SHA1算法进行hash，将两者结果对比），验证通过后客户端能确定这个证书是可信的。</li><li>CA的公钥如何安全传输是一个问题，因此多数浏览器开发商会在浏览器内部植入常用CA的公钥。</li></ol><p><img src="http://typora.lemonchan.top/image-20220305235402474.png" alt="image-20220305235402474"></p><h2 id="四、完整性保护"><a href="#四、完整性保护" class="headerlink" title="四、完整性保护"></a>四、完整性保护</h2><p>通过HTTPS发送的报文，其会携带名为MAC的报文摘要，能够提示报文是否遭到篡改</p><h2 id="五、HTTPS的安全通信机制"><a href="#五、HTTPS的安全通信机制" class="headerlink" title="五、HTTPS的安全通信机制"></a>五、HTTPS的安全通信机制</h2><ol><li>Client发送Client Hello报文开始SSL通信。报文中包含Client支持的<strong>SSL版本、加密组件列表（所使用的加密算法和密钥长度等）</strong></li><li>Server发送Server Hello报文响应Client，报文中同样包含Server支持的SSL版本和加密组件列表（<strong>从Client的Client Hello报文中筛选得出</strong>）</li><li>Server向Client发送Certificate报文，其中包含自己的<strong>公开密钥证书</strong></li><li>Server向Client发送Server Hello Done报文，表示SSL通信<strong>握手协商部分结束</strong></li><li>Client发送Client Key Exchange报文，其中包含了通信加密中使用的一种被称为Pre-master secret的随机<strong>密码串</strong>，该密码串<strong>已使用服务器的公钥进行加密</strong></li><li>Client发送Change Cipher Spec报文，告诉服务器今后的通信都用Pre-master secret（使用步骤2中的加密算法）进行对称加密。</li><li>Client发送Finished报文，该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。<strong>（该报文用步骤5中的随机密码串、步骤2中的加密方法进行加密）</strong></li><li>Server发送Change Cipher Spec报文。</li><li>Server发送Finished报文。</li><li>Client和Serve的Finished报文交换完毕，SSL连接建立完成，通信会收到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</li><li>应用层协议通信，即发送HTTP相应。</li><li>最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。</li></ol><p><img src="http://typora.lemonchan.top/image-20220306001438614.png" alt="image-20220306001438614"></p><p><img src="http://typora.lemonchan.top/image-20220306002632730.png" alt="image-20220306002632730"></p><p><strong>SSL和TLS的关系</strong>：TLS是以SSL为基准开发的，有时会统一称为SSL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTTP使用明文通信（不加密），内容可能被窃听。&lt;/li&gt;
&lt;li&gt;HTTP不验证通信双方身份，因此有可能遭遇伪</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://yi-jiao-chan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://yi-jiao-chan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记-Linux常用命令</title>
    <link href="http://yi-jiao-chan.github.io/posts/27065e75.html"/>
    <id>http://yi-jiao-chan.github.io/posts/27065e75.html</id>
    <published>2022-03-05T07:45:00.000Z</published>
    <updated>2022-03-26T10:10:21.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><ol><li><p><code>cd xx</code>：切换到目录<code>xx</code></p><ol><li><code>cd /</code>：切换到根目录</li><li><code>cd ~</code>：切换到当前用户目录</li><li><code>cd ../</code>：切换到上一层目录</li><li><code>cd -</code>：切换到上一操作所在目录</li></ol><p><img src="http://typora.lemonchan.top/image-20220305160402770-16464674663031.png" alt="image-20220305160402770"></p></li><li><p><code>mkdir [参数] [目录]</code>：创建一个目录</p><p><img src="http://typora.lemonchan.top/image-20220305161632460.png" alt="image-20220305161632460"></p></li><li><p><code>ls</code>：打印当前目录下的所有目录名&#x2F;文件名</p></li><li><p><code>ll</code>：等同于<code>ls -l</code>，打印当前目录下的所有目录&#x2F;文件详细信息</p><p><img src="http://typora.lemonchan.top/image-20220305160712165.png" alt="image-20220305160712165"></p></li><li><p><code>cp [参数] [文件名*n] [目的路径]</code>：复制文件或目录</p><p><img src="http://typora.lemonchan.top/image-20220305161433282.png" alt="image-20220305161433282"></p></li><li><p><code>mv [参数] [文件名] [目的路径]</code>：移动文件&#x2F;目录</p><p><img src="http://typora.lemonchan.top/image-20220305163219211.png" alt="image-20220305163219211"></p></li><li><p><code>pwd [参数]</code>：显示当前所在路径</p></li><li><p><code>tar [参数] [文件名]</code>：文件打包压缩&#x2F;解压</p><p><img src="http://typora.lemonchan.top/image-20220305183706369.png" alt="image-20220305183706369"></p><ol><li>常用压缩：<code>tar -zcvf [xxx.tar.gz] [待压缩文件]</code>：将待压缩文件打包成xxx.tar然后压缩成xxx.tar.gz。并显示运行过程</li><li>常用解压：<code>tar -xvf [xxx.tar.gz] -C [解压目录]</code>：将xxx.tar.gz解压到指定目录下。如果没有-C [解压目录]，则解压到xxx.tar.gz所在目录下。</li></ol></li><li><p><code>chmod [权限] [文件名]</code>：修改文件&#x2F;目录权限</p><ol><li><p>文件类型：</p><ul><li><code>d</code>：代表目录</li><li><code>-</code>：代表文件</li><li><code>l</code>：代表软连接</li></ul></li><li><p>权限：</p><ul><li><code>r</code>：可读，也可以用<code>4</code>表示，对目录来说是可以查看目录内文件。</li><li><code>w</code>：可写，也可以用<code>2</code>表示，对目录来说是可以修改目录内文件。</li><li><code>x</code>：可执行，也可以用<code>1</code>表示，对目录来说是可以cd进去。</li></ul></li><li><p>linux中的用户必须属于一个用户组，每个文件有所属用户、所属组、其他组的概念，需要对这3个概念对应的用户分别设置文件权限。</p><ul><li>文件所有者（u）：一般是文件创建者，也可以用<code>chown 用户名 文件名</code>命令修改</li><li>文件所在组（g）：初始是文件创建者所在组，也可以用<code>chgrp 组名 文件名</code>命令修改</li><li>其他组（o）：除了上述两种用户，对于一个文件来说，其他用户都属于其他组</li></ul></li><li><p>eg:<code>chmod u=rwx,g=rw,o=r aaa.txt</code>：文件所属者拥有读、写、执行权限，文件所属组的用户拥有读写权限，其他组的用户只拥有读的权限。</p></li></ol></li></ol><h2 id="文档编辑命令"><a href="#文档编辑命令" class="headerlink" title="文档编辑命令"></a>文档编辑命令</h2><ol><li><p><code>cat [参数] [文件名]</code>：显示文件所有内容，适用于内容少的文件，因为大量内容显示出来，只能看到最后一页的内容</p><p><img src="http://typora.lemonchan.top/image-20220305163939903.png" alt="image-20220305163939903"></p></li><li><p><code>more [参数] [文件]</code>：分页显示文件内容</p><p><img src="http://typora.lemonchan.top/image-20220305182851764.png" alt="image-20220305182851764"></p></li><li><p><code>tail [参数] [文件名]</code>：显示文件尾部的内容，默认显示最后10行，可以同时读取多个文件</p><p><img src="http://typora.lemonchan.top/image-20220305165421194.png" alt="image-20220305165421194"></p></li><li><p><code>less [参数] [文件名]</code>：显示文件内容，与more类似</p><p><img src="http://typora.lemonchan.top/image-20220305183253451.png" alt="image-20220305183253451"></p></li><li><p><code>vim [文件]</code>：编辑文件</p></li><li><p><code>echo [参数] [字符串]</code>：打印字符串或变量提取后的值</p><ol><li><code>echo $PATH</code>：打印<code>$PATH</code>存储的内容（因为传的是字符串变量）</li><li><code>echo &quot;String&quot;</code>：打印内容是<code>String</code>（因为传的是字符串）</li></ol><p><img src="http://typora.lemonchan.top/image-20220305164350174.png" alt="image-20220305164350174"></p></li><li><p><code>rm [参数] [文件]</code>：<del>用于删库跑路</del> 删除文件&#x2F;目录，可使用正则表达式</p><p><img src="http://typora.lemonchan.top/image-20220305165041686.png" alt="image-20220305165041686"></p></li><li></li><li><p><code>grep [参数] [模式] [目录]</code>：搜索指定目录下符合模式的文件名（也可用于管道搜索），当模式内部含有空格，需要用双引号引起来</p><p><img src="http://typora.lemonchan.top/image-20220305165715069.png" alt="image-20220305165715069"></p></li></ol><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ol><li><p><code>rpm [参数] [软件包]</code>：用于管理rpm软件包：安装、卸载、升级、查询、验证</p><p><img src="http://typora.lemonchan.top/image-20220305165918824.png" alt="image-20220305165918824"></p></li><li><p><code>find [参数] [查找路径] [查找范围]</code>：用于搜索指定路径下的满足要求的文件&#x2F;目录，是递归查找，会包括子目录内容</p><p><img src="http://typora.lemonchan.top/image-20220305170216953.png" alt="image-20220305170216953"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">find /etc -name <span class="string">&quot;*.conf&quot;</span> --查找/etc目录下结尾为.conf的文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find /etc -size +1M  --查找/etc目录下大于1M的文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">print</span> --查找当前用户主目录及其子目录下的所有文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">type</span> f -atime +7 --查找当前用户主目录及子目录下7天前被访问过的所有文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">type</span> f -amin +7 --查找当前用户主目录及子目录下7分钟前被访问过的所有文件</span></span><br></pre></td></tr></table></figure></li><li><p><code>uname [参数]</code>：打印系统信息</p><p><img src="http://typora.lemonchan.top/image-20220305182242657.png" alt="image-20220305182242657"></p></li><li><p><code>chkconfig --add [脚本名]</code>：添加开机启动脚本</p></li><li><p><code>chkconfig --list</code>：查看开机启动的脚本</p></li><li><p><code>ps [参数]</code>：查看进程</p><ol><li><code>ps -ef</code>显示所有进程，其信息包括<ul><li>所属用户（UID）</li><li>进程ID（PID）</li><li>父进程ID（PPID）</li><li>CPU使用率（C）</li><li>系统启动时间（STIME）</li><li>TTY（登入这的终端机位置）</li><li>用掉的CPU时间（TIME）</li><li>哪个指令启动的进程（CMD）</li></ul></li><li><code>ps -ef | grep xxx</code>显示进程名含有xxx的所有进程</li></ol></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ol><li><p><code>useradd [参数] [用户名]</code>：添加用户</p><p><img src="http://typora.lemonchan.top/image-20220305190212389.png" alt="image-20220305190212389"></p></li><li><p><code>userdel [参数] [用户名]</code>：删除用户账号</p><p><img src="http://typora.lemonchan.top/image-20220305190233651.png" alt="image-20220305190233651"></p></li><li><p><code>usermod [选项] [用户名]</code>：修改用户账户</p><p><img src="http://typora.lemonchan.top/image-20220305190335226.png" alt="image-20220305190335226"></p></li><li><p><code>passw [参数] [用户名]</code>：操作用户密码</p><p><img src="http://typora.lemonchan.top/image-20220305190506221.png" alt="image-20220305190506221"></p></li><li><p><code>groupadd [参数] [组名]</code>：添加用户组</p><p><img src="http://typora.lemonchan.top/image-20220305190624859.png" alt="image-20220305190624859"></p></li><li><p><code>groupdel [参数] [组名]</code>：删除用户组</p><p><img src="http://typora.lemonchan.top/image-20220305190720778.png" alt="image-20220305190720778"></p></li><li><p><code>groupmod [参数] [组名]</code>：修改用户组</p><p><img src="http://typora.lemonchan.top/image-20220305190924506.png" alt="image-20220305190924506"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.linuxcool.com/">Linux 命令大全</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件管理命令&quot;&gt;&lt;a href=&quot;#文件管理命令&quot; class=&quot;headerlink&quot; title=&quot;文件管理命令&quot;&gt;&lt;/a&gt;文件管理命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cd xx&lt;/code&gt;：切换到目录&lt;code&gt;xx&lt;/code&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://yi-jiao-chan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://yi-jiao-chan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-1584. 连接所有点的最小费用</title>
    <link href="http://yi-jiao-chan.github.io/posts/e421b227.html"/>
    <id>http://yi-jiao-chan.github.io/posts/e421b227.html</id>
    <published>2022-03-02T08:32:00.000Z</published>
    <updated>2022-03-26T10:09:44.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/min-cost-to-connect-all-points">http://leetcode-cn.com/problems/min-cost-to-connect-all-points</a></p><p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi] </code>。</p><p>连接点<code>[xi, yi]</code>和点<code> [xj, yj]</code> 的费用为它们之间的 曼哈顿距离 ：<code>|xi - xj| + |yi - yj| </code>，其中<code>|val|</code>表示<code>val</code>的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p><blockquote><ul><li><code>1 &lt;= points.length &lt;= 1000</code></li><li><code>-106 &lt;= xi, yi &lt;= 106</code></li><li>所有点 <code>(xi, yi)</code> 两两不同。</li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/c.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]</span><br><span class="line">输出：20</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最小生成树题目，用prim和kruskal算法解题</p><p>prim(加点法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//prim算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=points.length;</span><br><span class="line">        <span class="comment">// 记录未加入节点与已加入的节点的最小距离,已加入的节点距离为0</span></span><br><span class="line">        <span class="type">int</span>[] minDistance=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(minDistance,Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">// 初始节点为0</span></span><br><span class="line">        <span class="type">int</span> newPoint=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把所有节点都加进去需要n-1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 记录未加入的节点与已加入节点的距离最小值以及节点编号</span></span><br><span class="line">            <span class="type">int</span> min=Integer.MAX_VALUE,minIndex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">// 节点已加入,continue</span></span><br><span class="line">                <span class="keyword">if</span>(minDistance[j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 因为加入了新节点,所以要用新节点与未加入的节点算一下距离,如果更小则更新minDistance</span></span><br><span class="line">                minDistance[j]=Math.min(minDistance[j],dis(points,newPoint,j));</span><br><span class="line">                <span class="comment">// 取minDistance的非0最小值</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;minDistance[j])&#123;</span><br><span class="line">                    minIndex=j;</span><br><span class="line">                    min=minDistance[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=min;</span><br><span class="line">            minDistance[minIndex]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 记录下新加入的节点的编号</span></span><br><span class="line">            newPoint=minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dis</span><span class="params">(<span class="type">int</span> [][]points ,<span class="type">int</span> point1,<span class="type">int</span> point2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(points[point1][<span class="number">0</span>]-points[point2][<span class="number">0</span>])+Math.abs(points[point1][<span class="number">1</span>]-points[point2][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kruskal(加边法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 并查集类,使用加权压缩路径并查集</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Union</span>&#123;</span><br><span class="line">        <span class="comment">// 记录每个分支含有的节点数</span></span><br><span class="line">        <span class="type">int</span> []cnts;</span><br><span class="line">        <span class="comment">// 记录父节点</span></span><br><span class="line">        <span class="type">int</span> []parents;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">            cnts=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            parents=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                parents[i]=i;</span><br><span class="line">                cnts[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            <span class="type">int</span> tempN=n,next=parents[n];</span><br><span class="line">            <span class="comment">// 寻找最终父节点</span></span><br><span class="line">            <span class="keyword">while</span>(n!=parents[n])&#123;</span><br><span class="line">                n=parents[n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 路径压缩</span></span><br><span class="line">            <span class="keyword">while</span>(tempN!=parents[tempN])&#123;</span><br><span class="line">                next=parents[tempN];</span><br><span class="line">                parents[tempN]=n;</span><br><span class="line">                tempN=next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并两个节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">            <span class="comment">// 分别找出父节点</span></span><br><span class="line">            <span class="type">int</span> pa=getParent(a);</span><br><span class="line">            <span class="type">int</span> pb=getParent(b);</span><br><span class="line">            <span class="comment">// 已经在一个集合中,无需合并</span></span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 将节点数少的子集合并到节点数多的集合中</span></span><br><span class="line">            <span class="keyword">if</span>(cnts[pa]&gt;=cnts[pb])&#123;</span><br><span class="line">                parents[pb]=pa;</span><br><span class="line">                cnts[pa]+=cnts[pb];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parents[pa]=pb;</span><br><span class="line">                cnts[pb]+=cnts[pa];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=points.length,index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 边的数量是(n-1)+(n-2)+...+(1)</span></span><br><span class="line">        <span class="type">int</span> [][]sides=<span class="keyword">new</span> <span class="title class_">int</span>[len*(len-<span class="number">1</span>)/<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 遍历点构建边集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                sides[index][<span class="number">0</span>]=i;</span><br><span class="line">                sides[index][<span class="number">1</span>]=j;</span><br><span class="line">                sides[index++][<span class="number">2</span>]=Math.abs(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>])+Math.abs(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 边集根据边的长度排序</span></span><br><span class="line">        Arrays.sort(sides,(o1,o2)-&gt;o1[<span class="number">2</span>]-o2[<span class="number">2</span>]);</span><br><span class="line">        Union u=<span class="keyword">new</span> <span class="title class_">Union</span>(len);</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录下已经使用的边</span></span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []side :sides)&#123;</span><br><span class="line">            <span class="comment">// 遍历边集,如果两个点原本属于不同集合,则利用该边将两个集合连接(union)起来</span></span><br><span class="line">            <span class="keyword">if</span>(u.union(side[<span class="number">0</span>],side[<span class="number">1</span>]))&#123;</span><br><span class="line">                res+=side[<span class="number">2</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// n-1条边刚好可以将所有节点连接起来</span></span><br><span class="line">            <span class="keyword">if</span>(cnt==len-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://leetcode-cn.com/problems/min-cost-to-connect-all-point</summary>
      
    
    
    
    <category term="leetcode" scheme="http://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="http://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="prim" scheme="http://yi-jiao-chan.github.io/tags/prim/"/>
    
    <category term="Kruskal" scheme="http://yi-jiao-chan.github.io/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-743. 网络延迟时间</title>
    <link href="http://yi-jiao-chan.github.io/posts/10b4218e.html"/>
    <id>http://yi-jiao-chan.github.io/posts/10b4218e.html</id>
    <published>2022-03-02T08:10:00.000Z</published>
    <updated>2022-03-26T10:08:57.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/network-delay-time">http://leetcode-cn.com/problems/network-delay-time</a></p><p>有 <code>n </code>个网络节点，标记为 <code>1 </code>到<code> n</code>。</p><p>给你一个列表 <code>times</code>，表示信号经过 有向 边的传递时间。<code> times[i] = (ui, vi, wi)</code>，其中<code> ui</code> 是源节点，<code>vi</code> 是目标节点，<code>wi</code>是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回<code>-1</code>。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/931_example_1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dijkstra算法和floyd算法。分别求单源点的最短路径和多源点的最短路径。</p><p><strong>Dijkstra</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 邻接表存图</span></span><br><span class="line">    List&lt;<span class="type">int</span> []&gt;[]lists;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 记录这个点是否被用来当过中间点更新</span></span><br><span class="line">    <span class="type">boolean</span> []vis;</span><br><span class="line">    <span class="comment">// 记录所求点到每一个点的最短距离</span></span><br><span class="line">    <span class="type">int</span> []res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        lists=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[n+<span class="number">1</span>];</span><br><span class="line">        vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        res=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// -1代表不可达，初始状态只能到达自己</span></span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        res[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            lists[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] group:times)&#123;</span><br><span class="line">            lists[group[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;group[<span class="number">1</span>],group[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(k);</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 查找最大距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 有一个点不可达则返回-1</span></span><br><span class="line">            <span class="keyword">if</span>(res[i]==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            cnt=Math.max(cnt,res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迪杰斯特拉算法，二叉堆优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">// 用优先队列来存放当前备选中转节点,取距离最短的点为O(logN)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span> []&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((arr1,arr2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> arr1[<span class="number">1</span>]-arr2[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 初始只有自己本身,距离为0</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;k,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出距离最短的点.</span></span><br><span class="line">            <span class="type">int</span>[] midNode=queue.poll();</span><br><span class="line">            <span class="type">int</span> midIdx=midNode[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> midLen=midNode[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 因为所有入队的节点,都是通过已有节点中转进来的,而中转的节点必定比原来节点距离大,因此只要当过中转节点,那么它离原点距离必定最小</span></span><br><span class="line">            <span class="comment">//  已经当过中转节点,continue</span></span><br><span class="line">            <span class="keyword">if</span>(vis[midIdx]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 标记已当过中转节点</span></span><br><span class="line">            vis[midIdx]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 遍历以该中转节点为起点的所有边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> [] arr:lists[midIdx])&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[arr[<span class="number">0</span>]]==-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果该边的终点原本与k不可达,则更新</span></span><br><span class="line">                    res[arr[<span class="number">0</span>]]=arr[<span class="number">1</span>]+midLen;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>],res[arr[<span class="number">0</span>]]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">1</span>]+midLen&lt;res[arr[<span class="number">0</span>]])&#123;</span><br><span class="line">                    <span class="comment">// 如果该边的终点原本与k可达,但经过中转距离可以缩短,则更新</span></span><br><span class="line">                    res[arr[<span class="number">0</span>]]=arr[<span class="number">1</span>]+midLen;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>],res[arr[<span class="number">0</span>]]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Floyd</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 邻接矩阵存图</span></span><br><span class="line">    <span class="type">int</span> [][]map;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        map=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i) map[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> map[i][j]=map[j][i]=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把每条边映射到邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] group:times)&#123;</span><br><span class="line">            map[group[<span class="number">0</span>]][group[<span class="number">1</span>]]=group[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        floyd();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[k][i]==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            res=Math.max(map[k][i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点,以i作为中转节点,起点为j,终点为k,找最短路径</span></span><br><span class="line">        <span class="comment">//  i=1时,只能使用1作为中转</span></span><br><span class="line">        <span class="comment">//  i=2时,实际上一些节点已经替换成经过1中转了.因此此时是使用1和2作为中转</span></span><br><span class="line">        <span class="comment">//   以此类推......</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[j][k]==-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">// 原本不可达,经过中转可达,则更新</span></span><br><span class="line">                        <span class="keyword">if</span>(map[j][i]!=-<span class="number">1</span>&amp;&amp;map[i][k]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            map[j][k]=map[j][i]+map[i][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 原本可达,但经过中转后距离更小,更新</span></span><br><span class="line">                        <span class="keyword">if</span>(map[j][i]!=-<span class="number">1</span>&amp;&amp;map[i][k]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            map[j][k]=Math.min(map[j][i]+map[i][k],map[j][k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://leetcode-cn.com/problems/network-delay-time&quot;&gt;http://le</summary>
      
    
    
    
    <category term="leetcode" scheme="http://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="http://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="floyd" scheme="http://yi-jiao-chan.github.io/tags/floyd/"/>
    
    <category term="dijkstra" scheme="http://yi-jiao-chan.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-socket</title>
    <link href="http://yi-jiao-chan.github.io/posts/13b55345.html"/>
    <id>http://yi-jiao-chan.github.io/posts/13b55345.html</id>
    <published>2022-02-28T13:52:00.000Z</published>
    <updated>2022-03-26T10:10:34.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>socket即<strong>套接字</strong>，是一个软件接口，进程通过Socket向网络发送报文和从网络接收报文，是一台计算机内应用层与传输层之间的接口，用于计算机进程之间的网络通信。</p><h1 id="二、socket的类型"><a href="#二、socket的类型" class="headerlink" title="二、socket的类型"></a>二、socket的类型</h1><h2 id="1、流格式套接字（SOCK-STREAM）"><a href="#1、流格式套接字（SOCK-STREAM）" class="headerlink" title="1、流格式套接字（SOCK_STREAM）"></a>1、流格式套接字（SOCK_STREAM）</h2><p>面向连接的套接字，使用了TCP协议</p><ul><li>数据在传输过程中不会消失；</li><li>数据是按照顺序传输的；</li><li>数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。即连续ARQ</li></ul><h2 id="2、数据报格式套接字（SOCK-DGRAM）"><a href="#2、数据报格式套接字（SOCK-DGRAM）" class="headerlink" title="2、数据报格式套接字（SOCK_DGRAM）"></a>2、数据报格式套接字（SOCK_DGRAM）</h2><p>无连接的套接字，使用了UDP协议，它有以下特征：</p><ul><li>强调快速传输而非传输顺序；</li><li>传输的数据可能丢失也可能损毁；</li><li>限制每次传输的数据大小；</li><li>数据的发送和接收是同步的（有的教程也称“存在数据边界”）。</li></ul><h1 id="三、常用的socket函数（以TCP介绍）"><a href="#三、常用的socket函数（以TCP介绍）" class="headerlink" title="三、常用的socket函数（以TCP介绍）"></a>三、常用的socket函数（以TCP介绍）</h1><h2 id="1、socket"><a href="#1、socket" class="headerlink" title="1、socket"></a>1、socket</h2><p><code>int socket(int family, int type, int protocol)</code>：创建套接字，创建成功返回非负文件描述符，出错返回-1</p><ul><li><code>family</code>：指明协议族，如IPV4、IPV6</li><li><code>type</code>：指明套接字类型，如SOCK_STREAM、SOCK_DGRAM</li><li><code>protocol</code>：指定传输协议，如UDP、TCP，也可省略让系统根据<code>family</code>和<code>type</code>决定</li></ul><h2 id="2、bind"><a href="#2、bind" class="headerlink" title="2、bind"></a>2、bind</h2><p><code>int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)</code>：将一个本地协议地址（由ip地址和端口号组成）与该套接字绑定。绑定成功返回0，否则返回-1.</p><ul><li><code>sockfd</code>：socket的id</li><li><code>myaddr</code>：指向协议的地址结构的指针，包括ip地址和端口号</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="3、listen"><a href="#3、listen" class="headerlink" title="3、listen"></a>3、listen</h2><p><code>int listen(int sockfd, int backlog)</code>：socket被创建出来，默认都是主动套接字，是要调用connect发起连接的。调用listen后，会把该未连接的套接字转变成被动套接字，指示内核应该接收指向该套接字的连接请求。启动监听成功返回0，否则返回-1.</p><ul><li><code>sockfd</code>：socket的id</li><li><code>backlog</code>：有多种定义，目的都是指定半连接队列和全连接队列的大小。</li></ul><h2 id="4、connect"><a href="#4、connect" class="headerlink" title="4、connect"></a>4、connect</h2><p><code>int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)</code> 用来与服务器建立连接的函数，成功返回0，否则-1。</p><ul><li><code>sockfd</code>：socket的id</li><li><code>servaddr</code>：指向套接字的地址结构的指针，包括服务器ip地址和端口号（即指定了服务器的套接字）</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="5、accept"><a href="#5、accept" class="headerlink" title="5、accept"></a>5、accept</h2><p><code>int accept(int sockfd, const struct sockaddr *cliaddr, socklen_t addrlen)</code>一般由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成的连接，accept成功后会返回一个新的socekt id，用于表示与该client的连接。</p><ul><li><code>sockfd</code>：socket的id</li><li><code>servaddr</code>：指向client的协议地址的指针，包括客户机ip地址和端口号（即指定了客户机的套接字）</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="6、fork和exec"><a href="#6、fork和exec" class="headerlink" title="6、fork和exec"></a>6、fork和exec</h2><p>用于服务并发连接。</p><p><code>fork()</code>用于创建一个子线程，子进程的代码段、堆栈段、数据段都完全复制于父进程，但是它是独立运行的。</p><p><code>exec()</code>相当于借尸还魂，代码段会被替换成新的，堆栈段、数据段会重新分配，也就是说除了PCB号，其他的都变了。</p><p>那么如何实现并发服务器程序呢？答案是使用<code>fork()</code>。当一个连接建立时，accept返回，服务器调用<code>fork</code>，然后由子进程服务客户（通过父进程建立连接的套接字），<strong>父进程则关闭该套接字</strong>并等待下一个连接（通过监听套接字）。</p><p>父进程关闭了套接字为什么子进程还可以用来传输数据呢？因为每个文件都有一个引用计数，他是当前打开着的引用该文件的描述符的个数，子进程还在使用该套接字，父进程并没有真正关闭，仅仅是释放了引用。</p><p><img src="http://typora.lemonchan.top/image-20220228230805600.png" alt="image-20220228230805600"></p><p><img src="http://typora.lemonchan.top/image-20220228230822733.png" alt="image-20220228230822733"></p><h2 id="7、close"><a href="#7、close" class="headerlink" title="7、close"></a>7、close</h2><p><code>int close(int scokfd)</code>：用于关闭套接字，默认行为是将该套接字标记位已关闭，立即返回到调用线程。该套接字不能再由调用进程使用，但是TCP仍会使用该套接字发送缓冲区的数据，发送完毕后才是正常的TCP连接中止序列（四次挥手）。</p><p><em>假如socket未进行四次挥手就关闭了，那么客户端发来报文，服务器会响应一个RST报文段。客户端的TCP收到RST报文后就知道该连接已不可达，但是应用层还不知道，当应用层再次发送报文的时候，TCP不会将数据发出，而且发一个SIGPIPE信号（用于终止程序）给应用层</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;socket即&lt;strong&gt;套接字&lt;/strong&gt;，是一个软件接口，进程通过Socket向网络发送报文和从网络接收报文，</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://yi-jiao-chan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-863. 二叉树中所有距离为 K 的结点</title>
    <link href="http://yi-jiao-chan.github.io/posts/a535a0e3.html"/>
    <id>http://yi-jiao-chan.github.io/posts/a535a0e3.html</id>
    <published>2022-02-28T11:33:00.000Z</published>
    <updated>2022-03-26T10:09:08.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree">http://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree</a></p><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点<code>target</code> ，和一个整数值<code> k</code> 。</p><p>返回到目标结点<code>target</code>距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/sketch0.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2</span><br><span class="line">输出：[7,4,1]</span><br><span class="line">解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1</span><br><span class="line"></span><br><span class="line">输入: root = [1], target = 1, k = 3</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题中所求的是距离target节点距离为k的所有节点，而每个节点只能往3个方向走：左节点、右节点、父节点。因此要扫描一遍树，记录下所有节点的父节点（实际上只需记录下<code>target</code>及其前方所有节点的父节点即可，因为只有这些节点需要网上扫描。但判断是否是target需要耗时，在本题中扫描整棵树效率更高）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录下每个节点的父节点</span></span><br><span class="line">    Map&lt;TreeNode,TreeNode&gt; parents=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        serach(root,<span class="literal">null</span>);</span><br><span class="line">        dfs(<span class="literal">null</span>,target,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serach</span><span class="params">(TreeNode root,TreeNode parent)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        parents.put(root,parent);</span><br><span class="line">        serach(root.left,root);</span><br><span class="line">        serach(root.right,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode last,TreeNode root,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ==0了，再走就没必要了，return</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是回头路就不要走</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=last)</span><br><span class="line">            dfs(root,root.left,k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=last)</span><br><span class="line">            dfs(root,root.right,k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(parents.get(root)!=last)</span><br><span class="line">            dfs(root,parents.get(root),k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://leetcode-cn.com/problems/all-nodes-distance-k-in-binar</summary>
      
    
    
    
    <category term="leetcode" scheme="http://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="http://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="哈希" scheme="http://yi-jiao-chan.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="dfs" scheme="http://yi-jiao-chan.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-973. 最接近原点的 K 个点</title>
    <link href="http://yi-jiao-chan.github.io/posts/2e849c9d.html"/>
    <id>http://yi-jiao-chan.github.io/posts/2e849c9d.html</id>
    <published>2022-02-28T08:56:00.000Z</published>
    <updated>2022-02-28T11:43:20.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin">https://leetcode-cn.com/problems/k-closest-points-to-origin</a></p><p>给定一个数组 points ，其中 <code>points[i] = [xi, yi]</code> 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点<code>(0,0)</code>最近的 <code>k </code>个点。</p><p>这里，平面上两点之间的距离是 欧几里德距离<code>（ √(x1 - x2)2 + (y1 - y2)2 ）</code>。</p><p>你可以<strong>按 任何顺序 返回答案</strong>。除了点坐标的顺序之外，答案 确保 是 唯一 的。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,3],[-2,2]], k = 1</span><br><span class="line">输出：[[-2,2]]</span><br><span class="line">解释： </span><br><span class="line">(1, 3) 和原点之间的距离为 sqrt(10)，</span><br><span class="line">(-2, 2) 和原点之间的距离为 sqrt(8)，</span><br><span class="line">由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。</span><br><span class="line">我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。</span><br><span class="line"></span><br><span class="line">输入：points = [[3,3],[5,-1],[-2,4]], k = 2</span><br><span class="line">输出：[[3,3],[-2,4]]</span><br><span class="line">（答案 [[-2,4],[3,3]] 也会被接受。）</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>堆排序，取k次堆顶即可。因为答案要求返回节点的x和y坐标，而排序标准是与原点距离，因此新建一个类存放x、y、len，排序过程中就不用反复计算len节省时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 建一个类来存放x，y和原点距离len</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">long</span> len;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">long</span> len)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.x=x;</span><br><span class="line">            <span class="built_in">this</span>.y=y;</span><br><span class="line">            <span class="built_in">this</span>.len=len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] kClosest(<span class="type">int</span>[][] points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 建堆</span></span><br><span class="line">        Node [] arr=<span class="keyword">new</span> <span class="title class_">Node</span> [points.length];</span><br><span class="line">        <span class="comment">// 把数据加入堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">long</span> len=points[i][<span class="number">0</span>]*points[i][<span class="number">0</span>]+points[i][<span class="number">1</span>]*points[i][<span class="number">1</span>];</span><br><span class="line">            arr[i]=<span class="keyword">new</span> <span class="title class_">Node</span>(points[i][<span class="number">0</span>],points[i][<span class="number">1</span>],len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化堆（从最后一个非叶子节点开始建队，逐渐前移）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sortHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> [][]res=<span class="keyword">new</span> <span class="title class_">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">// 堆顶为当前距离原点最近的点，取出并加入结果集</span></span><br><span class="line">            res[i]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>].x,arr[<span class="number">0</span>].y&#125;;</span><br><span class="line">            <span class="comment">// 把堆顶与堆末尾交换，移出堆</span></span><br><span class="line">            swap(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>-i);</span><br><span class="line">            <span class="comment">// 堆顶交换了，所以从堆顶位置整理堆</span></span><br><span class="line">            sortHeap(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入堆、整理的节点下标、堆的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortHeap</span><span class="params">(Node []arr,<span class="type">int</span> index,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 越界返回</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果存在右节点且右节点的值更小，则右节点称为可能与根节点交换的节点</span></span><br><span class="line">        <span class="keyword">if</span>(left+<span class="number">1</span>&lt;length&amp;&amp;arr[left].len&gt;arr[left+<span class="number">1</span>].len)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点值比左/右节点的最小值小，交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[index].len&gt;arr[left].len)&#123;</span><br><span class="line">            swap(arr,index,left);</span><br><span class="line">            <span class="comment">// 交换后要整理被交换的子节点</span></span><br><span class="line">            sortHeap(arr,left,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Node []arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Node temp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/k-closest-points-to-origin&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="http://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="http://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="堆排序" scheme="http://yi-jiao-chan.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-55. 跳跃游戏</title>
    <link href="http://yi-jiao-chan.github.io/posts/a738f689.html"/>
    <id>http://yi-jiao-chan.github.io/posts/a738f689.html</id>
    <published>2022-02-27T15:14:00.000Z</published>
    <updated>2022-02-27T15:17:49.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><blockquote><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心，记录下当前可以跳的最大步数，然后每次跳一步，步数－－。如果当前位置能跳的步数大于剩下能跳的步数，则在这个位置停下，然后重新记录能跳的最大步数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录下当前能往前走的最大长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果长度为0，则不能走到当前位置，return false</span></span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 每走一步长度--</span></span><br><span class="line">            len--;</span><br><span class="line">            <span class="comment">// 更新可走长度</span></span><br><span class="line">            len=Math.max(len,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game/&quot;&gt;https://leetcode</summary>
      
    
    
    
    <category term="leetcode" scheme="http://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="http://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="贪心" scheme="http://yi-jiao-chan.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-264. 丑数 II</title>
    <link href="http://yi-jiao-chan.github.io/posts/a62a3dc0.html"/>
    <id>http://yi-jiao-chan.github.io/posts/a62a3dc0.html</id>
    <published>2022-02-27T13:05:00.000Z</published>
    <updated>2022-02-27T13:30:20.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br><span class="line"></span><br><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol><li><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。即丑数只能由丑数×2、×3、×5得出。已知丑数集合<code>[1]</code>，分别可以算出<code>[1*2][1*3][1*5]</code>，取其中最小<code>2</code>的加入丑数集合得到<code>[1,2]</code>。</li><li>然后可以算出来丑数<code>[1*2,2*2][1*3,2*3][1*5,2*5]</code>，三组丑数中仅有<code>[1*2]</code>是重复的，因为<code>1*2</code>上一轮已经加入了丑数集合，因此本轮应该只算出丑数<code>[2*2][1*3,2*3][1*5,2*5]</code>，如何只算出这些呢？显而易见的是，2不能×丑数中的第一个数了。此时加入丑数集合的应该是<code>1*3</code>，得到<code>[1,2,3]</code></li><li>然后可以算出来丑数<code>[1*2,2*2,3*2][1*3,2*3,3*3][1*5,2*5,3*5]</code>，三组丑数中<code>[1*2][1*3]</code>是重复的，因为<code>1*2和1*3</code>之前已经加入了丑数集合，因此本轮应该只算出丑数<code>[3*2][2*3,3*3][1*5,2*5,3*5]</code>，如何只算出这些呢？显而易见的是，2和3都不能×丑数中的第一个数了。此时加入丑数集合的应该是<code>2*2</code>，得到<code>[1,2,3，4]</code></li><li>显而易见，剔除掉已经加入丑数集合的计算结果后，每次加入数组的都是算出的3组计算结果中最小的，而每组结果组内是递增的，因此我们只需要计算每组第一个未被加入丑数数组的的结果，取三者最小加入丑数集合即可。</li><li>所以我们应该维护3个指针，三个指针所指向的数分别×2、×3、×5，3者最小值就是下一个丑数。而如果计算出的下一个丑数是该指针的计算结果，则该指针需要++（因为不可重复）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 分别记录*2 *3 *5的数的下标</span></span><br><span class="line">        <span class="type">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>,idx=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;n)&#123;</span><br><span class="line">            <span class="comment">// 计算出三个指针指向丑数分别*2 *3 *5的结果</span></span><br><span class="line">            <span class="type">int</span> num2=arr[p2]*<span class="number">2</span>,num3=arr[p3]*<span class="number">3</span>,num5=arr[p5]*<span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 计算结果的最小值是下一个丑数</span></span><br><span class="line">            arr[idx]=Math.min(num2,Math.min(num3,num5));</span><br><span class="line">            <span class="comment">// 如果下一丑数是该指针的计算结果，则需要++。</span></span><br><span class="line">            <span class="comment">//  可能出现下一丑数是多个指针的计算结果的情况，则多个指针++</span></span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num2)&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num3)&#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num5)&#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number-ii/&quot;&gt;https://lee</summary>
      
    
    
    
    <category term="leetcode" scheme="http://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="动态规划" scheme="http://yi-jiao-chan.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="medium" scheme="http://yi-jiao-chan.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-501. 二叉搜索树中的众数</title>
    <link href="http://yi-jiao-chan.github.io/posts/c505a049.html"/>
    <id>http://yi-jiao-chan.github.io/posts/c505a049.html</id>
    <published>2022-02-26T13:46:00.000Z</published>
    <updated>2022-03-26T10:08:40.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><blockquote><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="http://typora.lemonchan.top/image-20220226214928619.png" alt="image-20220226214928619"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,4,4,3,4,4,5,1,3]</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由题意可知，每一个节点的父节点和右节点，其值必定大于或等于当前节点值。因此中序遍历必定是非降序，即可计算出每个值出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        TreeNode last=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxCnt=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// Morris遍历，寻找左子树的最右节点</span></span><br><span class="line">            TreeNode leftRight=root.left;</span><br><span class="line">            <span class="keyword">while</span>(leftRight!=<span class="literal">null</span>&amp;&amp;leftRight.right!=<span class="literal">null</span>&amp;&amp;leftRight.right!=root)&#123;</span><br><span class="line">                leftRight=leftRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左子树最右节点为空（没有左子树），或者已经连接过了（即左子树已经遍历过）</span></span><br><span class="line">            <span class="comment">//  中序遍历，所以轮到当前节点被扫描到</span></span><br><span class="line">            <span class="keyword">if</span>(leftRight==<span class="literal">null</span>||leftRight.right==root)&#123;</span><br><span class="line">                <span class="comment">// 判断是否跟上一个扫描的节点值相同，如果相同cnt++，否则cnt设为1</span></span><br><span class="line">                <span class="keyword">if</span>(last!=<span class="literal">null</span>&amp;&amp;last.val==root.val)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果cnt&gt;maxCnt，则已经记录下的数值不是众数，clear结果集并更新maxCnt</span></span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;maxCnt)&#123;</span><br><span class="line">                    maxCnt=cnt;</span><br><span class="line">                    res.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前节点值的cnt与maxCnt一致，是暂时的众数，加入结果集</span></span><br><span class="line">                <span class="keyword">if</span>(cnt==maxCnt)&#123;</span><br><span class="line">                    res.add(root.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历右子树</span></span><br><span class="line">                last=root;</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 把左子树最右节点的right指向当前节点，然后遍历左子树</span></span><br><span class="line">                leftRight.right=root;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:res)&#123;</span><br><span class="line">            arr[cnt++]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。&lt;/p&gt;
&lt;p&gt;如</summary>
      
    
    
    
    <category term="leetcode" scheme="http://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="http://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="Morris遍历" scheme="http://yi-jiao-chan.github.io/tags/Morris%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
</feed>
