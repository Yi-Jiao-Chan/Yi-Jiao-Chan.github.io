<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柠檬的个人博客</title>
  <icon>https://www.gravatar.com/avatar/ce19897a92677092dba1f768f6eeb22e</icon>
  
  <link href="https://yi-jiao-chan.github.io/atom.xml" rel="self"/>
  
  <link href="https://yi-jiao-chan.github.io/"/>
  <updated>2022-03-06T12:36:04.605Z</updated>
  <id>https://yi-jiao-chan.github.io/</id>
  
  <author>
    <name>Lemon Chan</name>
    <email>yi_jiao_chan@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络学习笔记-Http1.0、1.1、2.0的区别</title>
    <link href="https://yi-jiao-chan.github.io/posts/e792a541.html"/>
    <id>https://yi-jiao-chan.github.io/posts/e792a541.html</id>
    <published>2022-03-06T11:42:00.000Z</published>
    <updated>2022-03-06T12:36:04.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP1-1与1-0的区别"><a href="#HTTP1-1与1-0的区别" class="headerlink" title="HTTP1.1与1.0的区别"></a>HTTP1.1与1.0的区别</h2><ol><li>HTTP1.1默认使用长连接，而1.0默认使用短连接</li><li>HTTP1.1增加了大量的状态码，比如：<code>100(Continue)</code>——在请求大量资源时返回的预热，询问Client是否真的需要该资源</li><li>HTTP1.1在缓存上增加了许多细节，但具体实现与1.0一致。<ol><li>每个响应体都会带上一个时间，表示服务器中这些数据最后被修改的时间。</li><li>Client每次发送请求的时候都会携带对应的时间，询问服务器该资源是否过期，服务器比对Client发送过来的时间以及资源的最后修改时间，如果一致，则返回状态码为304的响应让Client从缓存取，否则返回200并带上最新资源响应体。</li></ol></li><li>HTTP1.1在请求头加入了Host字段，标记了服务器的主机名。因为一个IP地址可以由多个域名映射，一台服务器可以部署多个应用，不同的域名往往是不同的应用。DNS解析之后，会将已解析的域名替换成ip地址，此时服务器不知道客户想要访问的到底哪个应用。而HTTP1.1的Host字段就记录下了该域名，服务器就可以知道客户想要访问的应用</li><li>HTTP1.1增加了范围请求(<code>Range</code>)，可以请求某个数据的一部分（比如客户端只需要某个对象的一部分信息），也支持了断点传输。服务器可以忽略<code>Range</code>并返回全部数据，也可以返回若干<code>Range</code>响应。</li></ol><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><h3 id="SPDY：HTTP1-x的升级"><a href="#SPDY：HTTP1-x的升级" class="headerlink" title="SPDY：HTTP1.x的升级"></a>SPDY：HTTP1.x的升级</h3><p>是由Google剔除的方案，优化了HTTP1.X的请求延迟，解决了安全性，具体如下。</p><ol><li><strong>降低延迟</strong>：使用多路复用，使多个请求可以使用同一个TCP连接并发执行（长连接是串行）。</li><li><strong>请求优先级</strong>：因为多路复用可能会导致重要请求被阻塞，因此SPDY允许给不同请求设置优先级，重要的优先级会先响应。比如访问一个网站，对html内容的请求应该是最先响应，然后才是css、js、图片等。</li><li><strong>压缩请求头</strong>：HTTP1.X的请求&#x2F;响应头是文本传输，而SPDY对请求头进行压缩再传输。</li><li><strong>基于HTTPS</strong>：强制使用HTTPS加密传输。</li><li><strong>服务端推送</strong>：允许在浏览器明确发出请求前，将一些资源推送给浏览器，存放在浏览器缓存中。避免了浏览器对所有资源的分次请求，提高效率。</li></ol><h3 id="HTTP2-0：SPDY的升级"><a href="#HTTP2-0：SPDY的升级" class="headerlink" title="HTTP2.0：SPDY的升级"></a>HTTP2.0：SPDY的升级</h3><p>HTTP2.0与SPDY的不同：</p><ol><li>HTTP2.0支持明文传输，而SPDY必须使用HTTPS</li><li>HTTP2.0与SPDY的请求&#x2F;响应头压缩算法不一样</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP1-1与1-0的区别&quot;&gt;&lt;a href=&quot;#HTTP1-1与1-0的区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP1.1与1.0的区别&quot;&gt;&lt;/a&gt;HTTP1.1与1.0的区别&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;HTTP1.1默认使用长连接，而</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://yi-jiao-chan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="https://yi-jiao-chan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-Https是如何加密的？</title>
    <link href="https://yi-jiao-chan.github.io/posts/ed7edf56.html"/>
    <id>https://yi-jiao-chan.github.io/posts/ed7edf56.html</id>
    <published>2022-03-05T15:28:00.000Z</published>
    <updated>2022-03-06T12:35:46.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul><li>HTTP使用明文通信（不加密），内容可能被窃听。</li><li>HTTP不验证通信双方身份，因此有可能遭遇伪装。</li><li>HTTP无法验证报文的完整性，报文可能会遭到篡改。</li></ul><p><strong>HTTPS&#x3D;HTTP+通信加密+证书+完整性保护</strong></p><h2 id="二、通信加密"><a href="#二、通信加密" class="headerlink" title="二、通信加密"></a>二、通信加密</h2><p>HTTPS同时使用了两种加密方式</p><ol><li>对称加密：加密和解密用的是同一密钥，优点是加密解密速度快，缺点是需要将密钥发送给接收方。用于HTTP通信交换报文阶段。</li><li>非对称加密：加密和解密用的是不同密钥，优点是不需要将密钥发送给接收方，缺点是加密解密速度慢。用于传输《对称加密的密钥》</li></ol><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305233950281.png" alt="image-20220305233950281"></p><h2 id="三、证书"><a href="#三、证书" class="headerlink" title="三、证书"></a>三、证书</h2><p>如果公开密钥在传输过程中被攻击者拦截，并将公开密钥进行替换，接收端如果使用该被替换的公开密钥进行加密，则数据会被攻击方轻松破解。数字证书正是解决这种问题而出现的。</p><p><strong>数字证书</strong>：</p><ol><li>是由数字证书认证机构（CA）和其相关机关颁发的的公开密钥证书。</li><li>证书组成：证书内容（包括证书所有人、服务器公钥等信息）、加密算法、加密密文（证书内容加密的产物）</li></ol><p><strong>数字认证机构</strong>：是客户端和服务器双方都可信赖的第三方机构。</p><p><strong>证书申请过程</strong>：</p><ol><li>服务器运营人员向CA提出公开密钥的申请。</li><li>CA核实申请者身份后，将申请者提交的公开密钥、申请者信息、CA的信息等组合成证书内容，然后做数字签名（实际上是将证书内容使用SHA1算法进行hash，然后用CA的私钥对hash结果进行加密）</li><li>CA将证书内容、加密算法、数字签名组合成证书，然后交还给服务器。</li></ol><p><strong>证书如何保证安全？</strong></p><ol><li>服务器将数字证书发送给客户端，客户端收到证书后对数字证书进行验证（使用对应的CA的公钥和证书内的加密算法对数字签名进行解密，然后将证书内容使用SHA1算法进行hash，将两者结果对比），验证通过后客户端能确定这个证书是可信的。</li><li>CA的公钥如何安全传输是一个问题，因此多数浏览器开发商会在浏览器内部植入常用CA的公钥。</li></ol><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305235402474.png" alt="image-20220305235402474"></p><h2 id="四、完整性保护"><a href="#四、完整性保护" class="headerlink" title="四、完整性保护"></a>四、完整性保护</h2><p>通过HTTPS发送的报文，其会携带名为MAC的报文摘要，能够提示报文是否遭到篡改</p><h2 id="五、HTTPS的安全通信机制"><a href="#五、HTTPS的安全通信机制" class="headerlink" title="五、HTTPS的安全通信机制"></a>五、HTTPS的安全通信机制</h2><ol><li>Client发送Client Hello报文开始SSL通信。报文中包含Client支持的<strong>SSL版本、加密组件列表（所使用的加密算法和密钥长度等）</strong></li><li>Server发送Server Hello报文响应Client，报文中同样包含Server支持的SSL版本和加密组件列表（<strong>从Client的Client Hello报文中筛选得出</strong>）</li><li>Server向Client发送Certificate报文，其中包含自己的<strong>公开密钥证书</strong></li><li>Server向Client发送Server Hello Done报文，表示SSL通信<strong>握手协商部分结束</strong></li><li>Client发送Client Key Exchange报文，其中包含了通信加密中使用的一种被称为Pre-master secret的随机<strong>密码串</strong>，该密码串<strong>已使用服务器的公钥进行加密</strong></li><li>Client发送Change Cipher Spec报文，告诉服务器今后的通信都用Pre-master secret（使用步骤2中的加密算法）进行对称加密。</li><li>Client发送Finished报文，该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。<strong>（该报文用步骤5中的随机密码串、步骤2中的加密方法进行加密）</strong></li><li>Server发送Change Cipher Spec报文。</li><li>Server发送Finished报文。</li><li>Client和Serve的Finished报文交换完毕，SSL连接建立完成，通信会收到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</li><li>应用层协议通信，即发送HTTP相应。</li><li>最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。</li></ol><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220306001438614.png" alt="image-20220306001438614"></p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220306002632730.png" alt="image-20220306002632730"></p><p><strong>SSL和TLS的关系</strong>：TLS是以SSL为基准开发的，有时会统一称为SSL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTTP使用明文通信（不加密），内容可能被窃听。&lt;/li&gt;
&lt;li&gt;HTTP不验证通信双方身份，因此有可能遭遇伪</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://yi-jiao-chan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="https://yi-jiao-chan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记-Linux常用命令</title>
    <link href="https://yi-jiao-chan.github.io/posts/27065e75.html"/>
    <id>https://yi-jiao-chan.github.io/posts/27065e75.html</id>
    <published>2022-03-05T07:45:00.000Z</published>
    <updated>2022-03-06T12:35:32.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><ol><li><p><code>cd xx</code>：切换到目录<code>xx</code></p><ol><li><code>cd /</code>：切换到根目录</li><li><code>cd ~</code>：切换到当前用户目录</li><li><code>cd ../</code>：切换到上一层目录</li><li><code>cd -</code>：切换到上一操作所在目录</li></ol><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305160402770-16464674663031.png" alt="image-20220305160402770"></p></li><li><p><code>mkdir [参数] [目录]</code>：创建一个目录</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305161632460.png" alt="image-20220305161632460"></p></li><li><p><code>ls</code>：打印当前目录下的所有目录名&#x2F;文件名</p></li><li><p><code>ll</code>：等同于<code>ls -l</code>，打印当前目录下的所有目录&#x2F;文件详细信息</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305160712165.png" alt="image-20220305160712165"></p></li><li><p><code>cp [参数] [文件名*n] [目的路径]</code>：复制文件或目录</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305161433282.png" alt="image-20220305161433282"></p></li><li><p><code>mv [参数] [文件名] [目的路径]</code>：移动文件&#x2F;目录</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305163219211.png" alt="image-20220305163219211"></p></li><li><p><code>pwd [参数]</code>：显示当前所在路径</p></li><li><p><code>tar [参数] [文件名]</code>：文件打包压缩&#x2F;解压</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305183706369.png" alt="image-20220305183706369"></p><ol><li>常用压缩：<code>tar -zcvf [xxx.tar.gz] [待压缩文件]</code>：将待压缩文件打包成xxx.tar然后压缩成xxx.tar.gz。并显示运行过程</li><li>常用解压：<code>tar -xvf [xxx.tar.gz] -C [解压目录]</code>：将xxx.tar.gz解压到指定目录下。如果没有-C [解压目录]，则解压到xxx.tar.gz所在目录下。</li></ol></li><li><p><code>chmod [权限] [文件名]</code>：修改文件&#x2F;目录权限</p><ol><li><p>文件类型：</p><ul><li><code>d</code>：代表目录</li><li><code>-</code>：代表文件</li><li><code>l</code>：代表软连接</li></ul></li><li><p>权限：</p><ul><li><code>r</code>：可读，也可以用<code>4</code>表示，对目录来说是可以查看目录内文件。</li><li><code>w</code>：可写，也可以用<code>2</code>表示，对目录来说是可以修改目录内文件。</li><li><code>x</code>：可执行，也可以用<code>1</code>表示，对目录来说是可以cd进去。</li></ul></li><li><p>linux中的用户必须属于一个用户组，每个文件有所属用户、所属组、其他组的概念，需要对这3个概念对应的用户分别设置文件权限。</p><ul><li>文件所有者（u）：一般是文件创建者，也可以用<code>chown 用户名 文件名</code>命令修改</li><li>文件所在组（g）：初始是文件创建者所在组，也可以用<code>chgrp 组名 文件名</code>命令修改</li><li>其他组（o）：除了上述两种用户，对于一个文件来说，其他用户都属于其他组</li></ul></li><li><p>eg:<code>chmod u=rwx,g=rw,o=r aaa.txt</code>：文件所属者拥有读、写、执行权限，文件所属组的用户拥有读写权限，其他组的用户只拥有读的权限。</p></li></ol></li></ol><h2 id="文档编辑命令"><a href="#文档编辑命令" class="headerlink" title="文档编辑命令"></a>文档编辑命令</h2><ol><li><p><code>cat [参数] [文件名]</code>：显示文件所有内容，适用于内容少的文件，因为大量内容显示出来，只能看到最后一页的内容</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305163939903.png" alt="image-20220305163939903"></p></li><li><p><code>more [参数] [文件]</code>：分页显示文件内容</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305182851764.png" alt="image-20220305182851764"></p></li><li><p><code>tail [参数] [文件名]</code>：显示文件尾部的内容，默认显示最后10行，可以同时读取多个文件</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305165421194.png" alt="image-20220305165421194"></p></li><li><p><code>less [参数] [文件名]</code>：显示文件内容，与more类似</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305183253451.png" alt="image-20220305183253451"></p></li><li><p><code>vim [文件]</code>：编辑文件</p></li><li><p><code>echo [参数] [字符串]</code>：打印字符串或变量提取后的值</p><ol><li><code>echo $PATH</code>：打印<code>$PATH</code>存储的内容（因为传的是字符串变量）</li><li><code>echo &quot;String&quot;</code>：打印内容是<code>String</code>（因为传的是字符串）</li></ol><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305164350174.png" alt="image-20220305164350174"></p></li><li><p><code>rm [参数] [文件]</code>：<del>用于删库跑路</del> 删除文件&#x2F;目录，可使用正则表达式</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305165041686.png" alt="image-20220305165041686"></p></li><li></li><li><p><code>grep [参数] [模式] [目录]</code>：搜索指定目录下符合模式的文件名（也可用于管道搜索），当模式内部含有空格，需要用双引号引起来</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305165715069.png" alt="image-20220305165715069"></p></li></ol><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ol><li><p><code>rpm [参数] [软件包]</code>：用于管理rpm软件包：安装、卸载、升级、查询、验证</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305165918824.png" alt="image-20220305165918824"></p></li><li><p><code>find [参数] [查找路径] [查找范围]</code>：用于搜索指定路径下的满足要求的文件&#x2F;目录，是递归查找，会包括子目录内容</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305170216953.png" alt="image-20220305170216953"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">find /etc -name <span class="string">&quot;*.conf&quot;</span> --查找/etc目录下结尾为.conf的文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find /etc -size +1M  --查找/etc目录下大于1M的文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">print</span> --查找当前用户主目录及其子目录下的所有文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">type</span> f -atime +7 --查找当前用户主目录及子目录下7天前被访问过的所有文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">find <span class="variable">$HOME</span> -<span class="built_in">type</span> f -amin +7 --查找当前用户主目录及子目录下7分钟前被访问过的所有文件</span></span><br></pre></td></tr></table></figure></li><li><p><code>uname [参数]</code>：打印系统信息</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305182242657.png" alt="image-20220305182242657"></p></li><li><p><code>chkconfig --add [脚本名]</code>：添加开机启动脚本</p></li><li><p><code>chkconfig --list</code>：查看开机启动的脚本</p></li><li><p><code>ps [参数]</code>：查看进程</p><ol><li><code>ps -ef</code>显示所有进程，其信息包括<ul><li>所属用户（UID）</li><li>进程ID（PID）</li><li>父进程ID（PPID）</li><li>CPU使用率（C）</li><li>系统启动时间（STIME）</li><li>TTY（登入这的终端机位置）</li><li>用掉的CPU时间（TIME）</li><li>哪个指令启动的进程（CMD）</li></ul></li><li><code>ps -ef | grep xxx</code>显示进程名含有xxx的所有进程</li></ol></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ol><li><p><code>useradd [参数] [用户名]</code>：添加用户</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305190212389.png" alt="image-20220305190212389"></p></li><li><p><code>userdel [参数] [用户名]</code>：删除用户账号</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305190233651.png" alt="image-20220305190233651"></p></li><li><p><code>usermod [选项] [用户名]</code>：修改用户账户</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305190335226.png" alt="image-20220305190335226"></p></li><li><p><code>passw [参数] [用户名]</code>：操作用户密码</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305190506221.png" alt="image-20220305190506221"></p></li><li><p><code>groupadd [参数] [组名]</code>：添加用户组</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305190624859.png" alt="image-20220305190624859"></p></li><li><p><code>groupdel [参数] [组名]</code>：删除用户组</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305190720778.png" alt="image-20220305190720778"></p></li><li><p><code>groupmod [参数] [组名]</code>：修改用户组</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220305190924506.png" alt="image-20220305190924506"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.linuxcool.com/">Linux 命令大全</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件管理命令&quot;&gt;&lt;a href=&quot;#文件管理命令&quot; class=&quot;headerlink&quot; title=&quot;文件管理命令&quot;&gt;&lt;/a&gt;文件管理命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cd xx&lt;/code&gt;：切换到目录&lt;code&gt;xx&lt;/code&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://yi-jiao-chan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="https://yi-jiao-chan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-1584. 连接所有点的最小费用</title>
    <link href="https://yi-jiao-chan.github.io/posts/e421b227.html"/>
    <id>https://yi-jiao-chan.github.io/posts/e421b227.html</id>
    <published>2022-03-02T08:32:00.000Z</published>
    <updated>2022-03-02T16:24:19.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points">https://leetcode-cn.com/problems/min-cost-to-connect-all-points</a></p><p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi] </code>。</p><p>连接点<code>[xi, yi]</code>和点<code> [xj, yj]</code> 的费用为它们之间的 曼哈顿距离 ：<code>|xi - xj| + |yi - yj| </code>，其中<code>|val|</code>表示<code>val</code>的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p><blockquote><ul><li><code>1 &lt;= points.length &lt;= 1000</code></li><li><code>-106 &lt;= xi, yi &lt;= 106</code></li><li>所有点 <code>(xi, yi)</code> 两两不同。</li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/c.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]</span><br><span class="line">输出：20</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最小生成树题目，用prim和kruskal算法解题</p><p>prim(加点法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//prim算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=points.length;</span><br><span class="line">        <span class="comment">// 记录未加入节点与已加入的节点的最小距离,已加入的节点距离为0</span></span><br><span class="line">        <span class="type">int</span>[] minDistance=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(minDistance,Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">// 初始节点为0</span></span><br><span class="line">        <span class="type">int</span> newPoint=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把所有节点都加进去需要n-1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 记录未加入的节点与已加入节点的距离最小值以及节点编号</span></span><br><span class="line">            <span class="type">int</span> min=Integer.MAX_VALUE,minIndex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">// 节点已加入,continue</span></span><br><span class="line">                <span class="keyword">if</span>(minDistance[j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 因为加入了新节点,所以要用新节点与未加入的节点算一下距离,如果更小则更新minDistance</span></span><br><span class="line">                minDistance[j]=Math.min(minDistance[j],dis(points,newPoint,j));</span><br><span class="line">                <span class="comment">// 取minDistance的非0最小值</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;minDistance[j])&#123;</span><br><span class="line">                    minIndex=j;</span><br><span class="line">                    min=minDistance[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=min;</span><br><span class="line">            minDistance[minIndex]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 记录下新加入的节点的编号</span></span><br><span class="line">            newPoint=minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dis</span><span class="params">(<span class="type">int</span> [][]points ,<span class="type">int</span> point1,<span class="type">int</span> point2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(points[point1][<span class="number">0</span>]-points[point2][<span class="number">0</span>])+Math.abs(points[point1][<span class="number">1</span>]-points[point2][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kruskal(加边法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 并查集类,使用加权压缩路径并查集</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Union</span>&#123;</span><br><span class="line">        <span class="comment">// 记录每个分支含有的节点数</span></span><br><span class="line">        <span class="type">int</span> []cnts;</span><br><span class="line">        <span class="comment">// 记录父节点</span></span><br><span class="line">        <span class="type">int</span> []parents;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">            cnts=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            parents=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                parents[i]=i;</span><br><span class="line">                cnts[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            <span class="type">int</span> tempN=n,next=parents[n];</span><br><span class="line">            <span class="comment">// 寻找最终父节点</span></span><br><span class="line">            <span class="keyword">while</span>(n!=parents[n])&#123;</span><br><span class="line">                n=parents[n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 路径压缩</span></span><br><span class="line">            <span class="keyword">while</span>(tempN!=parents[tempN])&#123;</span><br><span class="line">                next=parents[tempN];</span><br><span class="line">                parents[tempN]=n;</span><br><span class="line">                tempN=next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并两个节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">            <span class="comment">// 分别找出父节点</span></span><br><span class="line">            <span class="type">int</span> pa=getParent(a);</span><br><span class="line">            <span class="type">int</span> pb=getParent(b);</span><br><span class="line">            <span class="comment">// 已经在一个集合中,无需合并</span></span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 将节点数少的子集合并到节点数多的集合中</span></span><br><span class="line">            <span class="keyword">if</span>(cnts[pa]&gt;=cnts[pb])&#123;</span><br><span class="line">                parents[pb]=pa;</span><br><span class="line">                cnts[pa]+=cnts[pb];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parents[pa]=pb;</span><br><span class="line">                cnts[pb]+=cnts[pa];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=points.length,index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 边的数量是(n-1)+(n-2)+...+(1)</span></span><br><span class="line">        <span class="type">int</span> [][]sides=<span class="keyword">new</span> <span class="title class_">int</span>[len*(len-<span class="number">1</span>)/<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 遍历点构建边集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                sides[index][<span class="number">0</span>]=i;</span><br><span class="line">                sides[index][<span class="number">1</span>]=j;</span><br><span class="line">                sides[index++][<span class="number">2</span>]=Math.abs(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>])+Math.abs(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 边集根据边的长度排序</span></span><br><span class="line">        Arrays.sort(sides,(o1,o2)-&gt;o1[<span class="number">2</span>]-o2[<span class="number">2</span>]);</span><br><span class="line">        Union u=<span class="keyword">new</span> <span class="title class_">Union</span>(len);</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录下已经使用的边</span></span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []side :sides)&#123;</span><br><span class="line">            <span class="comment">// 遍历边集,如果两个点原本属于不同集合,则利用该边将两个集合连接(union)起来</span></span><br><span class="line">            <span class="keyword">if</span>(u.union(side[<span class="number">0</span>],side[<span class="number">1</span>]))&#123;</span><br><span class="line">                res+=side[<span class="number">2</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// n-1条边刚好可以将所有节点连接起来</span></span><br><span class="line">            <span class="keyword">if</span>(cnt==len-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/min-cost-to-connect-all-poin</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="prim" scheme="https://yi-jiao-chan.github.io/tags/prim/"/>
    
    <category term="Kruskal" scheme="https://yi-jiao-chan.github.io/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-743. 网络延迟时间</title>
    <link href="https://yi-jiao-chan.github.io/posts/10b4218e.html"/>
    <id>https://yi-jiao-chan.github.io/posts/10b4218e.html</id>
    <published>2022-03-02T08:10:00.000Z</published>
    <updated>2022-03-02T16:24:19.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/network-delay-time">https://leetcode-cn.com/problems/network-delay-time</a></p><p>有 <code>n </code>个网络节点，标记为 <code>1 </code>到<code> n</code>。</p><p>给你一个列表 <code>times</code>，表示信号经过 有向 边的传递时间。<code> times[i] = (ui, vi, wi)</code>，其中<code> ui</code> 是源节点，<code>vi</code> 是目标节点，<code>wi</code>是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回<code>-1</code>。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/931_example_1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dijkstra算法和floyd算法。分别求单源点的最短路径和多源点的最短路径。</p><p><strong>Dijkstra</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 邻接表存图</span></span><br><span class="line">    List&lt;<span class="type">int</span> []&gt;[]lists;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 记录这个点是否被用来当过中间点更新</span></span><br><span class="line">    <span class="type">boolean</span> []vis;</span><br><span class="line">    <span class="comment">// 记录所求点到每一个点的最短距离</span></span><br><span class="line">    <span class="type">int</span> []res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        lists=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[n+<span class="number">1</span>];</span><br><span class="line">        vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        res=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// -1代表不可达，初始状态只能到达自己</span></span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        res[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            lists[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] group:times)&#123;</span><br><span class="line">            lists[group[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;group[<span class="number">1</span>],group[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(k);</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 查找最大距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 有一个点不可达则返回-1</span></span><br><span class="line">            <span class="keyword">if</span>(res[i]==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            cnt=Math.max(cnt,res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迪杰斯特拉算法，二叉堆优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">// 用优先队列来存放当前备选中转节点,取距离最短的点为O(logN)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span> []&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((arr1,arr2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> arr1[<span class="number">1</span>]-arr2[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 初始只有自己本身,距离为0</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;k,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出距离最短的点.</span></span><br><span class="line">            <span class="type">int</span>[] midNode=queue.poll();</span><br><span class="line">            <span class="type">int</span> midIdx=midNode[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> midLen=midNode[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 因为所有入队的节点,都是通过已有节点中转进来的,而中转的节点必定比原来节点距离大,因此只要当过中转节点,那么它离原点距离必定最小</span></span><br><span class="line">            <span class="comment">//  已经当过中转节点,continue</span></span><br><span class="line">            <span class="keyword">if</span>(vis[midIdx]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 标记已当过中转节点</span></span><br><span class="line">            vis[midIdx]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 遍历以该中转节点为起点的所有边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> [] arr:lists[midIdx])&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[arr[<span class="number">0</span>]]==-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果该边的终点原本与k不可达,则更新</span></span><br><span class="line">                    res[arr[<span class="number">0</span>]]=arr[<span class="number">1</span>]+midLen;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>],res[arr[<span class="number">0</span>]]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">1</span>]+midLen&lt;res[arr[<span class="number">0</span>]])&#123;</span><br><span class="line">                    <span class="comment">// 如果该边的终点原本与k可达,但经过中转距离可以缩短,则更新</span></span><br><span class="line">                    res[arr[<span class="number">0</span>]]=arr[<span class="number">1</span>]+midLen;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>],res[arr[<span class="number">0</span>]]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Floyd</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 邻接矩阵存图</span></span><br><span class="line">    <span class="type">int</span> [][]map;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        map=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i) map[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> map[i][j]=map[j][i]=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把每条边映射到邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] group:times)&#123;</span><br><span class="line">            map[group[<span class="number">0</span>]][group[<span class="number">1</span>]]=group[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        floyd();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[k][i]==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            res=Math.max(map[k][i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点,以i作为中转节点,起点为j,终点为k,找最短路径</span></span><br><span class="line">        <span class="comment">//  i=1时,只能使用1作为中转</span></span><br><span class="line">        <span class="comment">//  i=2时,实际上一些节点已经替换成经过1中转了.因此此时是使用1和2作为中转</span></span><br><span class="line">        <span class="comment">//   以此类推......</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[j][k]==-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">// 原本不可达,经过中转可达,则更新</span></span><br><span class="line">                        <span class="keyword">if</span>(map[j][i]!=-<span class="number">1</span>&amp;&amp;map[i][k]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            map[j][k]=map[j][i]+map[i][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 原本可达,但经过中转后距离更小,更新</span></span><br><span class="line">                        <span class="keyword">if</span>(map[j][i]!=-<span class="number">1</span>&amp;&amp;map[i][k]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            map[j][k]=Math.min(map[j][i]+map[i][k],map[j][k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/network-delay-time&quot;&gt;https://</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="floyd" scheme="https://yi-jiao-chan.github.io/tags/floyd/"/>
    
    <category term="dijkstra" scheme="https://yi-jiao-chan.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-socket</title>
    <link href="https://yi-jiao-chan.github.io/posts/13b55345.html"/>
    <id>https://yi-jiao-chan.github.io/posts/13b55345.html</id>
    <published>2022-02-28T13:52:00.000Z</published>
    <updated>2022-03-06T12:35:26.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>socket即<strong>套接字</strong>，是一个软件接口，进程通过Socket向网络发送报文和从网络接收报文，是一台计算机内应用层与传输层之间的接口，用于计算机进程之间的网络通信。</p><h1 id="二、socket的类型"><a href="#二、socket的类型" class="headerlink" title="二、socket的类型"></a>二、socket的类型</h1><h2 id="1、流格式套接字（SOCK-STREAM）"><a href="#1、流格式套接字（SOCK-STREAM）" class="headerlink" title="1、流格式套接字（SOCK_STREAM）"></a>1、流格式套接字（SOCK_STREAM）</h2><p>面向连接的套接字，使用了TCP协议</p><ul><li>数据在传输过程中不会消失；</li><li>数据是按照顺序传输的；</li><li>数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。即连续ARQ</li></ul><h2 id="2、数据报格式套接字（SOCK-DGRAM）"><a href="#2、数据报格式套接字（SOCK-DGRAM）" class="headerlink" title="2、数据报格式套接字（SOCK_DGRAM）"></a>2、数据报格式套接字（SOCK_DGRAM）</h2><p>无连接的套接字，使用了UDP协议，它有以下特征：</p><ul><li>强调快速传输而非传输顺序；</li><li>传输的数据可能丢失也可能损毁；</li><li>限制每次传输的数据大小；</li><li>数据的发送和接收是同步的（有的教程也称“存在数据边界”）。</li></ul><h1 id="三、常用的socket函数（以TCP介绍）"><a href="#三、常用的socket函数（以TCP介绍）" class="headerlink" title="三、常用的socket函数（以TCP介绍）"></a>三、常用的socket函数（以TCP介绍）</h1><h2 id="1、socket"><a href="#1、socket" class="headerlink" title="1、socket"></a>1、socket</h2><p><code>int socket(int family, int type, int protocol)</code>：创建套接字，创建成功返回非负文件描述符，出错返回-1</p><ul><li><code>family</code>：指明协议族，如IPV4、IPV6</li><li><code>type</code>：指明套接字类型，如SOCK_STREAM、SOCK_DGRAM</li><li><code>protocol</code>：指定传输协议，如UDP、TCP，也可省略让系统根据<code>family</code>和<code>type</code>决定</li></ul><h2 id="2、bind"><a href="#2、bind" class="headerlink" title="2、bind"></a>2、bind</h2><p><code>int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)</code>：将一个本地协议地址（由ip地址和端口号组成）与该套接字绑定。绑定成功返回0，否则返回-1.</p><ul><li><code>sockfd</code>：socket的id</li><li><code>myaddr</code>：指向协议的地址结构的指针，包括ip地址和端口号</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="3、listen"><a href="#3、listen" class="headerlink" title="3、listen"></a>3、listen</h2><p><code>int listen(int sockfd, int backlog)</code>：socket被创建出来，默认都是主动套接字，是要调用connect发起连接的。调用listen后，会把该未连接的套接字转变成被动套接字，指示内核应该接收指向该套接字的连接请求。启动监听成功返回0，否则返回-1.</p><ul><li><code>sockfd</code>：socket的id</li><li><code>backlog</code>：有多种定义，目的都是指定半连接队列和全连接队列的大小。</li></ul><h2 id="4、connect"><a href="#4、connect" class="headerlink" title="4、connect"></a>4、connect</h2><p><code>int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)</code> 用来与服务器建立连接的函数，成功返回0，否则-1。</p><ul><li><code>sockfd</code>：socket的id</li><li><code>servaddr</code>：指向套接字的地址结构的指针，包括服务器ip地址和端口号（即指定了服务器的套接字）</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="5、accept"><a href="#5、accept" class="headerlink" title="5、accept"></a>5、accept</h2><p><code>int accept(int sockfd, const struct sockaddr *cliaddr, socklen_t addrlen)</code>一般由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成的连接，accept成功后会返回一个新的socekt id，用于表示与该client的连接。</p><ul><li><code>sockfd</code>：socket的id</li><li><code>servaddr</code>：指向client的协议地址的指针，包括客户机ip地址和端口号（即指定了客户机的套接字）</li><li><code>addrlen</code>：协议地址结构的长度</li></ul><h2 id="6、fork和exec"><a href="#6、fork和exec" class="headerlink" title="6、fork和exec"></a>6、fork和exec</h2><p>用于服务并发连接。</p><p><code>fork()</code>用于创建一个子线程，子进程的代码段、堆栈段、数据段都完全复制于父进程，但是它是独立运行的。</p><p><code>exec()</code>相当于借尸还魂，代码段会被替换成新的，堆栈段、数据段会重新分配，也就是说除了PCB号，其他的都变了。</p><p>那么如何变形并发服务器程序呢？答案是使用<code>fork()</code>和<code>exec()</code>。当一个连接建立时，accept返回，服务器调用<code>fork</code>，然后由子进程服务客户（通过父进程建立连接的套接字），<strong>父进程则关闭该套接字</strong>并等待下一个连接（通过监听套接字）。</p><p>父进程关闭了套接字为什么子进程还可以用来传输数据呢？因为每个文件都有一个引用技术，他是当前打开着的引用该文件的描述符的个数，子进程还在使用该套接字，父进程并没有真正关闭，仅仅是释放了引用。</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220228230805600.png" alt="image-20220228230805600"></p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220228230822733.png" alt="image-20220228230822733"></p><h2 id="7、close"><a href="#7、close" class="headerlink" title="7、close"></a>7、close</h2><p><code>int close(int scokfd)</code>：用于关闭套接字，默认行为是将该套接字标记位已关闭，立即返回到调用线程。该套接字不能再由调用进程使用，但是TCP仍会使用该套接字发送缓冲区的数据，发送完毕后才是正常的TCP连接中止序列（四次挥手）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;socket即&lt;strong&gt;套接字&lt;/strong&gt;，是一个软件接口，进程通过Socket向网络发送报文和从网络接收报文，</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://yi-jiao-chan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-863. 二叉树中所有距离为 K 的结点</title>
    <link href="https://yi-jiao-chan.github.io/posts/a535a0e3.html"/>
    <id>https://yi-jiao-chan.github.io/posts/a535a0e3.html</id>
    <published>2022-02-28T11:33:00.000Z</published>
    <updated>2022-02-28T11:43:20.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree">https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree</a></p><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点<code>target</code> ，和一个整数值<code> k</code> 。</p><p>返回到目标结点<code>target</code>距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/sketch0.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2</span><br><span class="line">输出：[7,4,1]</span><br><span class="line">解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1</span><br><span class="line"></span><br><span class="line">输入: root = [1], target = 1, k = 3</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题中所求的是距离target节点距离为k的所有节点，而每个节点只能往3个方向走：左节点、右节点、父节点。因此要扫描一遍树，记录下所有节点的父节点（实际上只需记录下<code>target</code>及其前方所有节点的父节点即可，因为只有这些节点需要网上扫描。但判断是否是target需要耗时，在本题中扫描整棵树效率更高）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录下每个节点的父节点</span></span><br><span class="line">    Map&lt;TreeNode,TreeNode&gt; parents=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        serach(root,<span class="literal">null</span>);</span><br><span class="line">        dfs(<span class="literal">null</span>,target,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serach</span><span class="params">(TreeNode root,TreeNode parent)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        parents.put(root,parent);</span><br><span class="line">        serach(root.left,root);</span><br><span class="line">        serach(root.right,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode last,TreeNode root,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ==0了，再走就没必要了，return</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是回头路就不要走</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=last)</span><br><span class="line">            dfs(root,root.left,k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=last)</span><br><span class="line">            dfs(root,root.right,k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(parents.get(root)!=last)</span><br><span class="line">            dfs(root,parents.get(root),k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/all-nodes-distance-k-in-bina</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="dfs" scheme="https://yi-jiao-chan.github.io/tags/dfs/"/>
    
    <category term="哈希" scheme="https://yi-jiao-chan.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-973. 最接近原点的 K 个点</title>
    <link href="https://yi-jiao-chan.github.io/posts/2e849c9d.html"/>
    <id>https://yi-jiao-chan.github.io/posts/2e849c9d.html</id>
    <published>2022-02-28T08:56:00.000Z</published>
    <updated>2022-02-28T11:43:20.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin">https://leetcode-cn.com/problems/k-closest-points-to-origin</a></p><p>给定一个数组 points ，其中 <code>points[i] = [xi, yi]</code> 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点<code>(0,0)</code>最近的 <code>k </code>个点。</p><p>这里，平面上两点之间的距离是 欧几里德距离<code>（ √(x1 - x2)2 + (y1 - y2)2 ）</code>。</p><p>你可以<strong>按 任何顺序 返回答案</strong>。除了点坐标的顺序之外，答案 确保 是 唯一 的。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,3],[-2,2]], k = 1</span><br><span class="line">输出：[[-2,2]]</span><br><span class="line">解释： </span><br><span class="line">(1, 3) 和原点之间的距离为 sqrt(10)，</span><br><span class="line">(-2, 2) 和原点之间的距离为 sqrt(8)，</span><br><span class="line">由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。</span><br><span class="line">我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。</span><br><span class="line"></span><br><span class="line">输入：points = [[3,3],[5,-1],[-2,4]], k = 2</span><br><span class="line">输出：[[3,3],[-2,4]]</span><br><span class="line">（答案 [[-2,4],[3,3]] 也会被接受。）</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>堆排序，取k次堆顶即可。因为答案要求返回节点的x和y坐标，而排序标准是与原点距离，因此新建一个类存放x、y、len，排序过程中就不用反复计算len节省时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 建一个类来存放x，y和原点距离len</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">long</span> len;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">long</span> len)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.x=x;</span><br><span class="line">            <span class="built_in">this</span>.y=y;</span><br><span class="line">            <span class="built_in">this</span>.len=len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] kClosest(<span class="type">int</span>[][] points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 建堆</span></span><br><span class="line">        Node [] arr=<span class="keyword">new</span> <span class="title class_">Node</span> [points.length];</span><br><span class="line">        <span class="comment">// 把数据加入堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">long</span> len=points[i][<span class="number">0</span>]*points[i][<span class="number">0</span>]+points[i][<span class="number">1</span>]*points[i][<span class="number">1</span>];</span><br><span class="line">            arr[i]=<span class="keyword">new</span> <span class="title class_">Node</span>(points[i][<span class="number">0</span>],points[i][<span class="number">1</span>],len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化堆（从最后一个非叶子节点开始建队，逐渐前移）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sortHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> [][]res=<span class="keyword">new</span> <span class="title class_">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">// 堆顶为当前距离原点最近的点，取出并加入结果集</span></span><br><span class="line">            res[i]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>].x,arr[<span class="number">0</span>].y&#125;;</span><br><span class="line">            <span class="comment">// 把堆顶与堆末尾交换，移出堆</span></span><br><span class="line">            swap(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>-i);</span><br><span class="line">            <span class="comment">// 堆顶交换了，所以从堆顶位置整理堆</span></span><br><span class="line">            sortHeap(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入堆、整理的节点下标、堆的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortHeap</span><span class="params">(Node []arr,<span class="type">int</span> index,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 越界返回</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果存在右节点且右节点的值更小，则右节点称为可能与根节点交换的节点</span></span><br><span class="line">        <span class="keyword">if</span>(left+<span class="number">1</span>&lt;length&amp;&amp;arr[left].len&gt;arr[left+<span class="number">1</span>].len)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点值比左/右节点的最小值小，交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[index].len&gt;arr[left].len)&#123;</span><br><span class="line">            swap(arr,index,left);</span><br><span class="line">            <span class="comment">// 交换后要整理被交换的子节点</span></span><br><span class="line">            sortHeap(arr,left,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Node []arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Node temp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/k-closest-points-to-origin&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="堆排序" scheme="https://yi-jiao-chan.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-55. 跳跃游戏</title>
    <link href="https://yi-jiao-chan.github.io/posts/a738f689.html"/>
    <id>https://yi-jiao-chan.github.io/posts/a738f689.html</id>
    <published>2022-02-27T15:14:00.000Z</published>
    <updated>2022-02-27T15:17:49.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><blockquote><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心，记录下当前可以跳的最大步数，然后每次跳一步，步数－－。如果当前位置能跳的步数大于剩下能跳的步数，则在这个位置停下，然后重新记录能跳的最大步数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录下当前能往前走的最大长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果长度为0，则不能走到当前位置，return false</span></span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 每走一步长度--</span></span><br><span class="line">            len--;</span><br><span class="line">            <span class="comment">// 更新可走长度</span></span><br><span class="line">            len=Math.max(len,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game/&quot;&gt;https://leetcode</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="贪心" scheme="https://yi-jiao-chan.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-264. 丑数 II</title>
    <link href="https://yi-jiao-chan.github.io/posts/a62a3dc0.html"/>
    <id>https://yi-jiao-chan.github.io/posts/a62a3dc0.html</id>
    <published>2022-02-27T13:05:00.000Z</published>
    <updated>2022-02-27T13:30:20.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br><span class="line"></span><br><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol><li><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。即丑数只能由丑数×2、×3、×5得出。已知丑数集合<code>[1]</code>，分别可以算出<code>[1*2][1*3][1*5]</code>，取其中最小<code>2</code>的加入丑数集合得到<code>[1,2]</code>。</li><li>然后可以算出来丑数<code>[1*2,2*2][1*3,2*3][1*5,2*5]</code>，三组丑数中仅有<code>[1*2]</code>是重复的，因为<code>1*2</code>上一轮已经加入了丑数集合，因此本轮应该只算出丑数<code>[2*2][1*3,2*3][1*5,2*5]</code>，如何只算出这些呢？显而易见的是，2不能×丑数中的第一个数了。此时加入丑数集合的应该是<code>1*3</code>，得到<code>[1,2,3]</code></li><li>然后可以算出来丑数<code>[1*2,2*2,3*2][1*3,2*3,3*3][1*5,2*5,3*5]</code>，三组丑数中<code>[1*2][1*3]</code>是重复的，因为<code>1*2和1*3</code>之前已经加入了丑数集合，因此本轮应该只算出丑数<code>[3*2][2*3,3*3][1*5,2*5,3*5]</code>，如何只算出这些呢？显而易见的是，2和3都不能×丑数中的第一个数了。此时加入丑数集合的应该是<code>2*2</code>，得到<code>[1,2,3，4]</code></li><li>显而易见，剔除掉已经加入丑数集合的计算结果后，每次加入数组的都是算出的3组计算结果中最小的，而每组结果组内是递增的，因此我们只需要计算每组第一个未被加入丑数数组的的结果，取三者最小加入丑数集合即可。</li><li>所以我们应该维护3个指针，三个指针所指向的数分别×2、×3、×5，3者最小值就是下一个丑数。而如果计算出的下一个丑数是该指针的计算结果，则该指针需要++（因为不可重复）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 分别记录*2 *3 *5的数的下标</span></span><br><span class="line">        <span class="type">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>,idx=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;n)&#123;</span><br><span class="line">            <span class="comment">// 计算出三个指针指向丑数分别*2 *3 *5的结果</span></span><br><span class="line">            <span class="type">int</span> num2=arr[p2]*<span class="number">2</span>,num3=arr[p3]*<span class="number">3</span>,num5=arr[p5]*<span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 计算结果的最小值是下一个丑数</span></span><br><span class="line">            arr[idx]=Math.min(num2,Math.min(num3,num5));</span><br><span class="line">            <span class="comment">// 如果下一丑数是该指针的计算结果，则需要++。</span></span><br><span class="line">            <span class="comment">//  可能出现下一丑数是多个指针的计算结果的情况，则多个指针++</span></span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num2)&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num3)&#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num5)&#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number-ii/&quot;&gt;https://lee</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="动态规划" scheme="https://yi-jiao-chan.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-501. 二叉搜索树中的众数</title>
    <link href="https://yi-jiao-chan.github.io/posts/c505a049.html"/>
    <id>https://yi-jiao-chan.github.io/posts/c505a049.html</id>
    <published>2022-02-26T13:46:00.000Z</published>
    <updated>2022-02-26T13:51:30.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><blockquote><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220226214928619.png" alt="image-20220226214928619"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,4,4,3,4,4,5,1,3]</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由题意可知，每一个节点的父节点和右节点，其值必定大于或等于当前节点值。因此中序遍历必定是非降序，即可计算出每个值出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        TreeNode last=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxCnt=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// Morris遍历，寻找左子树的最右节点</span></span><br><span class="line">            TreeNode leftRight=root.left;</span><br><span class="line">            <span class="keyword">while</span>(leftRight!=<span class="literal">null</span>&amp;&amp;leftRight.right!=<span class="literal">null</span>&amp;&amp;leftRight.right!=root)&#123;</span><br><span class="line">                leftRight=leftRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左子树最右节点为空（没有左子树），或者已经连接过了（即左子树已经遍历过）</span></span><br><span class="line">            <span class="comment">//  中序遍历，所以轮到当前节点被扫描到</span></span><br><span class="line">            <span class="keyword">if</span>(leftRight==<span class="literal">null</span>||leftRight.right==root)&#123;</span><br><span class="line">                <span class="comment">// 判断是否跟上一个扫描的节点值相同，如果相同cnt++，否则cnt设为1</span></span><br><span class="line">                <span class="keyword">if</span>(last!=<span class="literal">null</span>&amp;&amp;last.val==root.val)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果cnt&gt;maxCnt，则已经记录下的数值不是众数，clear结果集并更新maxCnt</span></span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;maxCnt)&#123;</span><br><span class="line">                    maxCnt=cnt;</span><br><span class="line">                    res.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前节点值的cnt与maxCnt一致，是暂时的众数，加入结果集</span></span><br><span class="line">                <span class="keyword">if</span>(cnt==maxCnt)&#123;</span><br><span class="line">                    res.add(root.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历右子树</span></span><br><span class="line">                last=root;</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 把左子树最右节点的right指向当前节点，然后遍历左子树</span></span><br><span class="line">                leftRight.right=root;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:res)&#123;</span><br><span class="line">            arr[cnt++]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。&lt;/p&gt;
&lt;p&gt;如</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="Morris遍历" scheme="https://yi-jiao-chan.github.io/tags/Morris%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-3. 无重复字符的最长子串</title>
    <link href="https://yi-jiao-chan.github.io/posts/6c54b1f1.html"/>
    <id>https://yi-jiao-chan.github.io/posts/6c54b1f1.html</id>
    <published>2022-02-26T13:00:00.000Z</published>
    <updated>2022-02-26T13:51:30.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>滑动窗口，始终维护一个没有重复字符的窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录该字符上一次出现的位置（记录值是下标+1）</span></span><br><span class="line">        <span class="type">int</span> []visited=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">255</span>];</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">1</span>,res=<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> []chars=s.toCharArray();</span><br><span class="line">        <span class="comment">// 滑动窗口，begin是左边界（记录的是下标+1），i是右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="comment">// System.out.println(visited[chars[i]]);</span></span><br><span class="line">            <span class="comment">// 当前字符上一次出现位置在窗口内，则左边界要移动，移动到当前字符上一次出现位置+1</span></span><br><span class="line">            <span class="keyword">if</span>(visited[chars[i]]&gt;=begin)&#123;</span><br><span class="line">                res=Math.max(res,i-begin+<span class="number">1</span>);</span><br><span class="line">                begin=visited[chars[i]]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录位置</span></span><br><span class="line">            visited[chars[i]]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右边界出了数组的特判</span></span><br><span class="line">        res=Math.max(res,chars.length-begin+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-re</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="滑动窗口" scheme="https://yi-jiao-chan.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-1642. 可以到达的最远建筑</title>
    <link href="https://yi-jiao-chan.github.io/posts/f2bf78e0.html"/>
    <id>https://yi-jiao-chan.github.io/posts/f2bf78e0.html</id>
    <published>2022-02-26T12:37:00.000Z</published>
    <updated>2022-02-26T13:51:30.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach">https://leetcode-cn.com/problems/furthest-building-you-can-reach</a></p><p>给你一个整数数组 <code>heights </code>，表示建筑物的高度。另有一些砖块 <code>bricks </code>和梯子<code>ladders</code>。</p><p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p><p>当从建筑物<code>i</code>移动到建筑物<code> i+1</code>（<strong>下标 从 0 开始</strong> ）时：</p><p>如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块<br>如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 <code>(h[i+1] - h[i]) </code>个砖块<br>如果以最佳方式使用给定的梯子和砖块，返回你可以到达的<strong>最远建筑物的下标</strong>（下标 从 0 开始 ）。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/q4.gif" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：从建筑物 0 出发，你可以按此方案完成旅程：</span><br><span class="line">- 不使用砖块或梯子到达建筑物 1 ，因为 4 &gt;= 2</span><br><span class="line">- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 &lt; 7</span><br><span class="line">- 不使用砖块或梯子到达建筑物 3 ，因为 7 &gt;= 6</span><br><span class="line">- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 &lt; 9</span><br><span class="line">无法越过建筑物 4 ，因为没有更多砖块或梯子。</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">输入：heights = [14,3,19,3], bricks = 17, ladders = 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>贪心，每次遇到难关先记录下如果用砖头的话，需要多少块。</p></li><li><p>如果此时有梯子，就用梯子。</p></li><li><p>如果此时没有梯子，则从前方记录下的每一关用梯子替换掉的砖头数中，取出用需要砖头数最少的位置。</p><ul><li>如果当前砖头数满足要求，则删除该记录（把该位置用砖头填上了，当前位置就可以用梯子）</li><li>如果当前砖头数量不满足要求，则无法到达，结束</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">furthestBuilding</span><span class="params">(<span class="type">int</span>[] heights, <span class="type">int</span> bricks, <span class="type">int</span> ladders)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;heights.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sub=heights[i]-heights[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(sub&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 把所需砖头树加入优先队列</span></span><br><span class="line">                queue.offer(sub);</span><br><span class="line">                <span class="comment">// 如果有梯子，先用梯子</span></span><br><span class="line">                <span class="keyword">if</span>(ladders&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ladders--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(queue.peek()&lt;=bricks)&#123;</span><br><span class="line">                     <span class="comment">// 如果没梯子了,就把之前用了梯子的一个地方，替换成砖头。要找砖头需求数最少的位置</span></span><br><span class="line">                    bricks-=queue.poll();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> i-<span class="number">1</span>;   <span class="comment">// 怎样都不能到当前位置，返回i-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heights.length-<span class="number">1</span>;    <span class="comment">//出了循环就能到达最后一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/furthest-building-you-can-re</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="优先队列" scheme="https://yi-jiao-chan.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://yi-jiao-chan.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-简单（静态）工厂模式</title>
    <link href="https://yi-jiao-chan.github.io/posts/e14d1dd7.html"/>
    <id>https://yi-jiao-chan.github.io/posts/e14d1dd7.html</id>
    <published>2022-02-25T02:29:00.000Z</published>
    <updated>2022-03-06T12:35:24.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>简单工厂模式（Simple Factory Pattern）又称静态工厂方法模式（Static Factory Method），属于<strong>创建型模式</strong>，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义了一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Factory：工厂角色，负责创建对象实例</li><li>Product：抽象类，是工厂生产的所有产品的基类&#x2F;接口</li><li>ConcreteProduct：具体类，有一个或多个，是工厂生产的产品类</li></ul><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220225103432166.png" alt="image-20220225103432166"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p>要求：某电视机厂专为各知名电视机品牌代工生产各类电视机，当需要海尔牌电视机时只需要在调用该工厂的工厂方法时传入参数<code>“Haier”</code>，需要海信电视机时只需要传入参数<code>“Hisense”</code>，<strong>工厂可以根据传入的不同参数返回不同品牌的电视机</strong>。现使用简单工厂模式来模拟该电视机工厂的生产过程。</p><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteProduct</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TV <span class="title function_">productTV</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.equalsIgnoreCase(<span class="string">&quot;Haier&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在生产Haier电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equalsIgnoreCase(<span class="string">&quot;Hisense&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在生产Hisense电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseTv</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            thorw <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;对不起，暂不能生产该品牌电视机!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li><p>将对象的创建和对象本身业务处理分离，降低系统耦合度，使两者都更加便于修改。</p></li><li><p>静态方法使用方便，不需要实例化工厂。</p></li><li><p>只需要传入参数即可创建对象，不需要知道实现细节。</p></li><li><p>可以把参数保存至<strong>XML配置文件</strong>中，修改时不需要修改Java源代码。</p></li></ul></li><li><p>缺点：</p><ul><li>工厂类集中了所有产品的创建逻辑，<strong>职责过重</strong>，一旦不能工作整个系统都会受影响。</li><li><strong>增加了系统中类的数量</strong>（增加了工厂类），增加系统复杂度和理解难度</li><li>系统拓展困难，一旦增加产品，就需要修改工厂类。</li><li>因为静态方法无法被继承，因此工厂类也无法形成基于继承的等级结构，工厂类不能得到很好地扩展。</li></ul></li><li><p>使用简单工厂模式的情况：</p><ul><li>工厂类负责创建的对象比较少，职责不会过重，逻辑不会过于复杂</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;简单工厂模式（Simple Factory Pattern）又称静态工厂方法模式（Static Factory Method</summary>
      
    
    
    
    <category term="编程思想" scheme="https://yi-jiao-chan.github.io/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="设计模式" scheme="https://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-149. 直线上最多的点数</title>
    <link href="https://yi-jiao-chan.github.io/posts/229ddae5.html"/>
    <id>https://yi-jiao-chan.github.io/posts/229ddae5.html</id>
    <published>2022-02-22T13:39:00.000Z</published>
    <updated>2022-02-22T15:16:55.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p><blockquote><ul><li><code>1 &lt;= points.length &lt;= 300</code></li><li><code>points[i].length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li><li><code>points</code> 中的所有点 <strong>互不相同</strong></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220222214716400.png" alt="image-20220222214716400" style="zoom:50%;" /><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,1],[2,2],[3,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220222214733386.png" alt="image-20220222214733386" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>双重循环，遍历每一个点与其他定点所形成的直线的斜率，因为其一为定点，所以斜率相等即同一直线。用<code>HashMap&lt;Double,Integer&gt;</code>记录斜率对应点个数即可。</p><p>因为<code>double</code>存在精度丢失问题，可以使用<code>String</code>类型记录<code>&quot;Δy/Δx&quot;</code>作为key存入<code>HashMap&lt;String,Integer&gt;</code>（lc中本题使用Double也可通过）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储各个斜率对应的点的个数</span></span><br><span class="line">        Map&lt;Double,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有点，以该点为定点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 剩余的点数量不足以更新res，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;=points.length-i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 重置map</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="comment">// 确定定点后，遍历剩余的点，两点计算斜率，用map存储每一个斜率对应点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="comment">// 因为前面的点已经计算过其与其他各个点的斜率，即也计算了与当前点的斜率， 因此遍历从i+1开始</span></span><br><span class="line">                <span class="type">int</span> deltaX=points[j][<span class="number">0</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> deltaY=points[j][<span class="number">1</span>]-points[i][<span class="number">1</span>];</span><br><span class="line">                Double k=<span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 被除数为0，则结果为0。 但0有+0和-0两种情况，特判</span></span><br><span class="line">                <span class="keyword">if</span>(deltaY==<span class="number">0</span>)&#123;</span><br><span class="line">                    k=<span class="number">0D</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deltaX!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 除数不能为0，需要特判，刚好hashmap可以存放null key，所以设为null。</span></span><br><span class="line">                    k=(<span class="type">double</span>)deltaY/(<span class="type">double</span>)deltaX;</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="type">int</span> cnt=map.getOrDefault(k,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                res=Math.max(res,cnt);</span><br><span class="line">                map.put(k,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用String替换Double的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储各个斜率对应的点的个数</span></span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有点，以该点为定点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 剩余的点数量不足以更新res，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;=points.length-i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 重置map</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="comment">// 确定定点后，遍历剩余的点，两点计算斜率，用map存储每一个斜率对应点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="comment">// 因为前面的点已经计算过其与其他各个点的斜率，即也计算了与当前点的斜率， 因此遍历从i+1开始</span></span><br><span class="line">                <span class="type">int</span> deltaX=points[j][<span class="number">0</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> deltaY=points[j][<span class="number">1</span>]-points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 默认是除数为0状态</span></span><br><span class="line">                String k=<span class="string">&quot;max&quot;</span>;</span><br><span class="line">                <span class="comment">// 被除数为0，则结果为0。 但0有+0和-0两种情况，特判</span></span><br><span class="line">                <span class="keyword">if</span>(deltaY==<span class="number">0</span>)&#123;</span><br><span class="line">                    k=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deltaX!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 除数不为0才进行计算</span></span><br><span class="line">                    <span class="type">int</span> t=gcd(deltaX,deltaY);</span><br><span class="line">                    <span class="comment">// 除以最大公约数，化简分数</span></span><br><span class="line">                    deltaX/=t;</span><br><span class="line">                    deltaY/=t;</span><br><span class="line">                    k=deltaX+<span class="string">&quot;/&quot;</span>+deltaY;</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="type">int</span> cnt=map.getOrDefault(k,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                res=Math.max(res,cnt);</span><br><span class="line">                map.put(k,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;points&lt;/code&gt; ，其中 &lt;code&gt;points[i] = [xi, yi]&lt;/code&gt; 表示 &lt;s</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="hard" scheme="https://yi-jiao-chan.github.io/tags/hard/"/>
    
    <category term="哈希" scheme="https://yi-jiao-chan.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-218. 天际线问题</title>
    <link href="https://yi-jiao-chan.github.io/posts/7257d04d.html"/>
    <id>https://yi-jiao-chan.github.io/posts/7257d04d.html</id>
    <published>2022-02-21T03:27:00.000Z</published>
    <updated>2022-02-22T15:16:55.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。</p><p>每个建筑物的几何信息由数组 <code>buildings</code> 表示，其中三元组 <code>buildings[i] = [lefti, righti, heighti]</code> 表示：</p><p><code>lefti</code> 是第 <code>i</code> 座建筑物左边缘的 <code>x</code> 坐标。<br><code>righti</code> 是第 <code>i</code> 座建筑物右边缘的 <code>x</code> 坐标。<br><code>heighti </code>是第 <code>i</code> 座建筑物的高度。<br>你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。</p><p>天际线 应该表示为由 “关键点” 组成的列表，格式<code>[[x1,y1],[x2,y2],...]</code>，并按<code>x</code>坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如<code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code>是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p><blockquote><p><code>1 &lt;= buildings.length &lt;= 104</code><br><code>0 &lt;= lefti &lt; righti &lt;= 231 - 1</code><br><code>1 &lt;= heighti &lt;= 231 - 1</code><br><code>buildings</code>按<code>lefti</code>非递减排序</p></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220221113143326.png" alt="image-20220221113143326"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</span><br><span class="line">输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</span><br><span class="line">解释：</span><br><span class="line">图 A 显示输入的所有建筑物的位置和高度，</span><br><span class="line">图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings = [[0,2,3],[2,5,3]]</span><br><span class="line">输出：[[0,3],[5,0]]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>扫描线：把每个矩形转变成两条竖直边。题中所求的是，两个矩形相交位置为x坐标，两矩形高度更大者为y坐标。所以可以维护一个优先队列（大根堆），扫描线的过程中将每一条左边对应的高度入队列（矩形开始），如果遇到右边，则将对应的高度出队列（矩形结束）。因此优先队列的对头存储的始终是当前位置的最高矩形的高度，则该高度与当前位置x坐标就可以确定一个答案点（注意要忽略连续相同的高度）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getSkyline</span><span class="params">(<span class="type">int</span>[][] buildings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=buildings.length;</span><br><span class="line">        <span class="comment">//把每个矩形转变成两条竖线，记录下x坐标、高度、是矩形左边/右边 &#123;x,y,left/right&#125;</span></span><br><span class="line">        <span class="type">int</span> [][] lines=<span class="keyword">new</span> <span class="title class_">int</span>[n*<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []building:buildings)&#123;</span><br><span class="line">            <span class="comment">// 1代表左边，-1代表右边</span></span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;building[<span class="number">0</span>],building[<span class="number">2</span>],<span class="number">1</span>&#125;;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;building[<span class="number">1</span>],building[<span class="number">2</span>],-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对转换出来的竖线排序，按x坐标升序。</span></span><br><span class="line">        <span class="comment">//      如果x相同，则先排左边，再排右边。</span></span><br><span class="line">        <span class="comment">//          左边线按高度降序。 保证同一个位置，取的是最高的点</span></span><br><span class="line">        <span class="comment">//          右边线按高度升序。 保证此前最高的点，最晚出队列。</span></span><br><span class="line">                    <span class="comment">//  本质上是将高度不一，x坐标和宽度完全一致的矩形，看作是高度大的矩形包含高度小的矩形</span></span><br><span class="line">        Arrays.sort(lines,(line1,line2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(line1[<span class="number">0</span>]!=line2[<span class="number">0</span>]) <span class="keyword">return</span> line1[<span class="number">0</span>]-line2[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> line2[<span class="number">1</span>]*line2[<span class="number">2</span>]-line1[<span class="number">1</span>]*line1[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 优先队列记录此前最大高度</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeight=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((int1,int2)-&gt;int2-int1);</span><br><span class="line">        maxHeight.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 记录上一个输出的高度</span></span><br><span class="line">        <span class="type">int</span> lastHeight=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []line:lines)&#123;</span><br><span class="line">            <span class="type">int</span> x=line[<span class="number">0</span>],height=line[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 是右边界，则该高度的矩形结束一个，其对应的高度出队列</span></span><br><span class="line">            <span class="keyword">if</span>(line[<span class="number">2</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                maxHeight.remove(height);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 是左边界，其对应的高度入队列</span></span><br><span class="line">                maxHeight.offer(height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前队列中的最大值（结果高度）</span></span><br><span class="line">            <span class="type">int</span> curMaxHeight=maxHeight.peek();</span><br><span class="line">            <span class="comment">// 结果高度与上一次输出的高度不一致，输出</span></span><br><span class="line">            <span class="keyword">if</span>(curMaxHeight!=lastHeight)&#123;</span><br><span class="line">                List&lt;Integer&gt; tempList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                tempList.add(x);</span><br><span class="line">                tempList.add(curMaxHeight);</span><br><span class="line">                res.add(tempList);</span><br><span class="line">                <span class="comment">// 记录下高度</span></span><br><span class="line">                lastHeight=curMaxHeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://leetcode-cn.com/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/">【宫水三叶】扫描线算法基本思路 &amp; 优先队列维护当前最大高度</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。&lt;/p</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="hard" scheme="https://yi-jiao-chan.github.io/tags/hard/"/>
    
    <category term="扫描线" scheme="https://yi-jiao-chan.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-391. 完美矩形</title>
    <link href="https://yi-jiao-chan.github.io/posts/bb46c52a.html"/>
    <id>https://yi-jiao-chan.github.io/posts/bb46c52a.html</id>
    <published>2022-02-20T15:02:00.000Z</published>
    <updated>2022-02-21T03:29:17.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/perfect-rectangle">https://leetcode-cn.com/problems/perfect-rectangle</a></p><p>给你一个数组 rectangles ，其中 rectangles[i] &#x3D; [xi, yi, ai, bi] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (xi, yi) ，右上顶点是 (ai, bi) 。</p><p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。</p><blockquote><ul><li><code>1 &lt;= rectangles.length &lt;= 2 * 104</code></li><li><code>rectangles[i].length == 4</code></li><li><code>-105 &lt;= xi, yi, ai, bi &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220230348305.png" alt="image-20220220230348305"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：5 个矩形一起可以精确地覆盖一个矩形区域。 </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220230620076.png" alt="image-20220220230620076"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：两个矩形之间有间隔，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220230647964.png" alt="image-20220220230647964"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>把每一个矩形，看作是两条x坐标不一样，y的始末坐标完全一致的竖直线组成，分别是左边线和右边线，因此引入一个标志来标识这是矩形是左边线还是右边线。因此通过<code>&#123;x,yLow,yHigh,left/right&#125;</code>记录下每一个矩形。</p><p>对于一个完美矩形来说：</p><ul><li><p>非边界线：非边界线在完美矩形的内部，因此必定是多个小矩形的拼接处，那么对于每一条线，都有一条与其位置完全一样，但是属于不同小矩形的不同方向的线。即<code>x,yLow,yHigh</code>相等，<code>left/right</code>相反。</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220231633077.png" alt="image-20220220231633077"></p></li><li><p>边界线（最左和最右的线）：在同一个x坐标下，只有一条连续的线</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220231847774.png" alt="image-20220220231847774"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRectangleCover</span><span class="params">(<span class="type">int</span>[][] rectangles)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=rectangles.length;</span><br><span class="line">        <span class="comment">// 一个矩形可以转换成两条竖直边，每条边记录为&#123;x轴坐标，下方y轴坐标，上方y轴坐标，矩形左边还是右边（1/-1）&#125;</span></span><br><span class="line">        <span class="type">int</span> [][]lines=<span class="keyword">new</span> <span class="title class_">int</span>[n*<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把矩形转换成边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []points:rectangles)&#123;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">3</span>],<span class="number">1</span>&#125;;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;points[<span class="number">2</span>],points[<span class="number">1</span>],points[<span class="number">3</span>],-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据x坐标升序排序，x坐标相同，则按照下方y轴坐标升序排序</span></span><br><span class="line">        Arrays.sort(lines,(line1,line2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(line1[<span class="number">0</span>]!=line2[<span class="number">0</span>]) <span class="keyword">return</span> line1[<span class="number">0</span>]-line2[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> line1[<span class="number">1</span>]-line2[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 分别记录左右边，只记录同一x下的，只记录y坐标 &#123;下方y轴坐标，上方y轴坐标&#125;</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; leftList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; rightList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 每次取出x坐标相同的所有边，根据其属于矩形的左边还是右边进行分类（扫描边）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;)&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            leftList.clear();</span><br><span class="line">            rightList.clear();</span><br><span class="line">            <span class="comment">// 找出横坐标相同的边的范围,因为j初始等于i，所以至少执行一次，j&gt;i恒成立</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;<span class="number">2</span>*n&amp;&amp;lines[i][<span class="number">0</span>]==lines[j][<span class="number">0</span>]) j++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                <span class="type">int</span> []line=lines[k];</span><br><span class="line">                List&lt;<span class="type">int</span>[]&gt; tempList=line[<span class="number">3</span>]==<span class="number">1</span>?leftList:rightList;</span><br><span class="line">                <span class="comment">// 把当前遍历到的边，加入到list中</span></span><br><span class="line">                <span class="keyword">if</span>(tempList.isEmpty()) tempList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;line[<span class="number">1</span>],line[<span class="number">2</span>]&#125;);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 取出该list中，最靠近上方的边</span></span><br><span class="line">                    <span class="type">int</span> []pre=tempList.get(tempList.size()-<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 上一条边最高位置高于当前边最低位置，重叠（对于同一方向的边，有重叠则证明矩形重叠），返回false</span></span><br><span class="line">                    <span class="comment">//      （由于lines以根据边的最低位置升序排序，所以不需要判断当前边的最高位置是否大于上一条边的最低位置）</span></span><br><span class="line">                    <span class="keyword">if</span>(pre[<span class="number">1</span>]&gt;line[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 上一条边最高位置等于当前边最低位置，两条边紧邻，合并</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(pre[<span class="number">1</span>]==line[<span class="number">1</span>]) pre[<span class="number">1</span>]=line[<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span> tempList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;line[<span class="number">1</span>],line[<span class="number">2</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不是边缘，则判断是否每一条边都重合（left和right每条边始末都相等）</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j&lt;<span class="number">2</span>*n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(leftList.size()!=rightList.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;leftList.size();k++)&#123;</span><br><span class="line">                    <span class="type">int</span> []left=leftList.get(k);</span><br><span class="line">                    <span class="type">int</span> []right=rightList.get(k);</span><br><span class="line">                    <span class="keyword">if</span>(left[<span class="number">0</span>]!=right[<span class="number">0</span>]||left[<span class="number">1</span>]!=right[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 是边缘,判断是否连续且没有重叠</span></span><br><span class="line">                <span class="keyword">if</span>(leftList.size()+rightList.size()!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j肯定比i大，用来替代i++</span></span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://leetcode-cn.com/problems/perfect-rectangle/solution/gong-shui-san-xie-chang-gui-sao-miao-xia-p4q4/">【宫水三叶】常规扫描线题目</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/perfect-rectangle&quot;&gt;https://l</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="hard" scheme="https://yi-jiao-chan.github.io/tags/hard/"/>
    
    <category term="扫描线" scheme="https://yi-jiao-chan.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-Spring框架</title>
    <link href="https://yi-jiao-chan.github.io/posts/690c4485.html"/>
    <id>https://yi-jiao-chan.github.io/posts/690c4485.html</id>
    <published>2022-02-17T02:38:00.000Z</published>
    <updated>2022-02-21T01:20:00.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解名称一、什么是Spring"><a href="#注解名称一、什么是Spring" class="headerlink" title="注解名称一、什么是Spring"></a><strong>注解名称</strong>一、什么是Spring</h1><p>Spring是一个轻量级的控制反转(IOC)和面向切面变成(AOP)的框架，可以用来整合其他框架</p><p>优点</p><ul><li>Spring是一个轻量级的，非入侵式的框架</li><li>Spring支持控制反转（IOC）和面向切面编程（AOP）</li><li>Spring支持事务管理，对框架的整合</li></ul><h1 id="二、Spring框架七大模块"><a href="#二、Spring框架七大模块" class="headerlink" title="二、Spring框架七大模块"></a>二、Spring框架七大模块</h1><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215105840732.png" alt="image-20220215105840732"></p><ol><li>Core：<strong>核心容器</strong>。这是Spring框架最基础的部分，它提供了依赖注入（Dependency Injection）特征来实现容器对Bean的管理。这里最基本的概念是BeanFactory，它是任何Spring应用的核心。BeanFactory是工厂模式的一个实现，它使用IOC将应用配置和依赖说明从实际的应用代码中分离出来。</li><li>Context：<strong>应用上下文</strong>。核心模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。该模块还提供了一些面向服务支持这个模块扩展了BeanFactory的概念，增加了对国际化（I18N）消息、事件传播以及验证的支持。另外，这个模块还提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括对模版框架例如Velocity和FreeMarker集成的支持。</li><li>AOP：<strong>面向切面编程</strong>。Spring在它的AOP模块中提供了对面向切面编程的丰富支持。AOP允许通过分离应用的业务逻辑与系统级服务（例如安全和事务管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。<strong>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务</strong>。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li><li>ORM：<strong>对象&#x2F;关系映射集成模块</strong>。Spring 框架集成了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li>DAO：<strong>Spring DAO模块</strong>。Spring虽然集成了几个ORM产品，但也可以不选择这几款产品，因为Spring提供了JDBC和DAO模块。该模块对现有的JDBC技术进行了优化。你可以保持你的数据库访问代码干净简洁，并且可以防止因关闭数据库资源失败而引起的问题。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li>Web：<strong>Web上下文模块</strong>。建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。它也提供了Spring和其它Web框架的集成，比如Struts、WebWork。</li><li>Web MVC：<strong>Spring的MVC框架</strong>Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts2，但Spring的MVC框架使用IOC对控制逻辑和业务对象提供了完全的分离，容纳了大量视图技术，如JSP。</li></ol><h1 id="三、IOC（控制反转）"><a href="#三、IOC（控制反转）" class="headerlink" title="三、IOC（控制反转）"></a>三、IOC（控制反转）</h1><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215114132804.png" alt="image-20220215114132804"></p><p>IOC就是<strong>对象的的创建移交给第三方</strong>，即在一个类当中不直接实例化另一个类的对象（例如：在service层中不直接new dao层对象，而是创建一个dao层接口的变量，通过这个接口变量调用dao层的各种方法实现业务逻辑。真正的dao层实例对象，是在程序运行过程中由容器提供并赋给接口变量的）。依赖注入（DI）是实 现IOC的一种方法。</p><h1 id="四、Spring使用IOC创建对象–依赖注入"><a href="#四、Spring使用IOC创建对象–依赖注入" class="headerlink" title="四、Spring使用IOC创建对象–依赖注入"></a>四、Spring使用IOC创建对象–依赖注入</h1><ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象的所有属性由容器注入</li></ul><h2 id="1、set方法注入"><a href="#1、set方法注入" class="headerlink" title="1、set方法注入"></a>1、set方法注入</h2><h3 id="1-1-复杂类型"><a href="#1-1-复杂类型" class="headerlink" title="1.1 复杂类型"></a>1.1 复杂类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-bean测试对象"><a href="#1-2-bean测试对象" class="headerlink" title="1.2 bean测试对象"></a>1.2 bean测试对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="comment">/*省略get set方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-applicationContext-xml"><a href="#1-3-applicationContext-xml" class="headerlink" title="1.3 applicationContext.xml"></a>1.3 applicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;广东省佛山市南海区华南师范大学南海校区&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--普通值注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--bean注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--Array注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>深入理解Java虚拟机<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Effective Java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>unix环境高级编程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--list注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打游戏<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打代码<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--map注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;440000000011112039&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;校园卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;201833330000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;银行卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2341212342134123423&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--set注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>NBA2K<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>地平线4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--null注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--properties注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;url&quot;</span>&gt;</span>www.lemonchan.top<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>Lemon Chan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;telephone&quot;</span>&gt;</span>13131313131<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-测试类"><a href="#1-4-测试类" class="headerlink" title="1.4 测试类"></a>1.4 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    System.out.println(context.getBean(<span class="string">&quot;student&quot;</span>));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Student&#123;</span></span><br><span class="line"><span class="comment">    *   name=&#x27;张三&#x27;,</span></span><br><span class="line"><span class="comment">    *   address=Address&#123;address=&#x27;广东省佛山市南海区华南师范大学南海校区&#x27;&#125;, </span></span><br><span class="line"><span class="comment">    *   books=[深入理解Java虚拟机, Effective Java, unix环境高级编程], </span></span><br><span class="line"><span class="comment">    *   hobbies=[打游戏, 看书, 打代码], </span></span><br><span class="line"><span class="comment">    *   card=&#123;</span></span><br><span class="line"><span class="comment">    *       身份证=440000000011112039, </span></span><br><span class="line"><span class="comment">    *       校园卡=201833330000, </span></span><br><span class="line"><span class="comment">    *       银行卡=2341212342134123423</span></span><br><span class="line"><span class="comment">    *   &#125;, </span></span><br><span class="line"><span class="comment">    *   games=[NBA2K, 地平线4], wife=&#x27;null&#x27;, </span></span><br><span class="line"><span class="comment">    *   info=&#123;telephone=13131313131, </span></span><br><span class="line"><span class="comment">    *       url=www.lemonchan.top, </span></span><br><span class="line"><span class="comment">    *       username=Lemon Chan</span></span><br><span class="line"><span class="comment">    *   &#125;</span></span><br><span class="line"><span class="comment">    * &#125;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、构造器注入"><a href="#2、构造器注入" class="headerlink" title="2、构造器注入"></a>2、构造器注入</h2><h3 id="2-1、无参构造方法创建"><a href="#2-1、无参构造方法创建" class="headerlink" title="2.1、无参构造方法创建"></a>2.1、无参构造方法创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2、构造方法参数下标构造"><a href="#2-2、构造方法参数下标构造" class="headerlink" title="2.2、构造方法参数下标构造"></a>2.2、构造方法参数下标构造</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3、参数类型构造（不建议使用）"><a href="#2-3、参数类型构造（不建议使用）" class="headerlink" title="2.3、参数类型构造（不建议使用）"></a>2.3、参数类型构造（不建议使用）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4、参数名构造"><a href="#2-4、参数名构造" class="headerlink" title="2.4、参数名构造"></a>2.4、参数名构造</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bb&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件加载时，Spring容器就会实例化bean，而默认情况下通过ApplicationContext获取到的同一id的bean对象，都是同一个对象（即一个id对应一个bean对象）。</p><h2 id="3、拓展方式注入"><a href="#3、拓展方式注入" class="headerlink" title="3、拓展方式注入"></a>3、拓展方式注入</h2><ul><li>两种拓展注入方式只能注入普通值和bean对象</li></ul><h3 id="3-1、p命名空间"><a href="#3-1、p命名空间" class="headerlink" title="3.1、p命名空间"></a>3.1、p命名空间</h3><ul><li><code>p:key=&quot;value&quot;</code>实现了了<code>&lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt;</code>的功能</li><li><code>p:key-ref=&quot;value&quot;</code>实现了了<code>&lt;property name=&quot;key&quot; ref=&quot;value&quot;/&gt;</code>的功能</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--beans标签需要加上的属性--&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Address&quot;</span> <span class="attr">p:address</span>=<span class="string">&quot;广东省佛山市南海区华南师范大学南海校区&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">p:address-ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2、c命名空间"><a href="#3-2、c命名空间" class="headerlink" title="3.2、c命名空间"></a>3.2、c命名空间</h3><ul><li><code>c:key=&quot;value&quot;</code>实现了了<code>&lt;constructor-arg name=&quot;key&quot; value=&quot;value&quot;/&gt;</code>的功能</li><li><code>c:key-ref=&quot;value&quot;</code>实现了了<code>&lt;constructor-arg name=&quot;key&quot; ref=&quot;value&quot;/&gt;</code>的功能</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--beans标签需要加上的属性--&gt;</span></span><br><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">c:aa</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">c:bb-ref</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">c:_0</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">c:_1-ref</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="五、Spring常用配置"><a href="#五、Spring常用配置" class="headerlink" title="五、Spring常用配置"></a>五、Spring常用配置</h1><h2 id="1、bean"><a href="#1、bean" class="headerlink" title="1、bean"></a>1、bean</h2><ul><li>id：bean的唯一标识符</li><li>class：bean对象对应的全限类名</li><li>name：与alias类似，给bean对象取别名，而且<strong>可以同时有多个别名</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2 hello3&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、alias"><a href="#2、alias" class="headerlink" title="2、alias"></a>2、alias</h2><p>配置了alias后，可以通过alias获取bean对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;aliasHello&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name：bean的id</li><li>alias：bean的别名</li></ul><h2 id="3、import"><a href="#3、import" class="headerlink" title="3、import"></a>3、import</h2><p>将多个配置文件导入合并到当前xml文件中。多用于团队开发</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;helloWord&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="六、bean的作用域"><a href="#六、bean的作用域" class="headerlink" title="六、bean的作用域"></a>六、bean的作用域</h1><h2 id="1、singleton–单例模式"><a href="#1、singleton–单例模式" class="headerlink" title="1、singleton–单例模式"></a>1、singleton–单例模式</h2><p>Spring的bean对象作用域默认是singleton。每次从容器中getBean() 都是同一个对象</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215235010967.png" alt="image-20220215235010967"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、prototype"><a href="#2、prototype" class="headerlink" title="2、prototype"></a>2、prototype</h2><p>每次从容器中getBean() 都是不同对象</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215235316311.png" alt="image-20220215235316311"></p><h2 id="3、request、session、application、websocket用于web开发中"><a href="#3、request、session、application、websocket用于web开发中" class="headerlink" title="3、request、session、application、websocket用于web开发中"></a>3、request、session、application、websocket用于web开发中</h2><h1 id="七、Bean的自动装配"><a href="#七、Bean的自动装配" class="headerlink" title="七、Bean的自动装配"></a>七、Bean的自动装配</h1><h2 id="1、byName自动装配"><a href="#1、byName自动装配" class="headerlink" title="1、byName自动装配"></a>1、byName自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--会在容器上下文中查找，找到与自己对象的set方法后面的变量名对应的beanId进行自动装配</span></span><br><span class="line"><span class="comment">例如：Person类有一个setDog方法，则会找到beanId未dog的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">要求容器上下文中所有bean的id唯一，且id要与set方法后面的变量名一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;张三&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、byType自动装配"><a href="#2、byType自动装配" class="headerlink" title="2、byType自动装配"></a>2、byType自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--会在容器上下文中查找，找到与自己对象属性的类型对应的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">例如：Person对象有一个Dog类型的属性，则会找到class=“Dog”的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">要求容器上下文中只有一个该类型的bean对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;张三&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、注解实现自动装配"><a href="#3、注解实现自动装配" class="headerlink" title="3、注解实现自动装配"></a>3、注解实现自动装配</h2><p>准备工作</p><ol><li>导入约束：xmlns:context</li><li>配置注解支持标签：<code>&lt;context:annotation-config/&gt;</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@Autowired</strong><br>直接在属性上使用即可，不需要set方法。也可以在set方法上使用<br>使用Autowired的前提是这个自动装配的属性在IOC容器中存在，**@Autowired先使用byType方式注入，如果存在多个相同类型bean，则根据id注入**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required= false )</span> <span class="comment">// 说明这个对象可以为null，即找不到bean注入也报错</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value= &quot;dog222&quot;)</span><span class="comment">// 使用@Qualifier注解配合使用，指定beanId进行注入（Type和Name都满足才能注入）</span></span><br><span class="line"><span class="keyword">private</span> Dog dog; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用byName，找不到则使用byType，可以通过参数指定type和name</span></span><br><span class="line"><span class="meta">@Resource(type = Cat.class,name = &quot;cat123&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><h1 id="八、使用注解开发"><a href="#八、使用注解开发" class="headerlink" title="八、使用注解开发"></a>八、使用注解开发</h1><ul><li>使用注解开发前，需要导入Spring-AOP包</li><li>开启注解包扫描，指定要扫描的包<code>&lt;context:component-scan base-package=&quot;com.lemon.pojo&quot;/&gt;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span> <span class="comment">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot; scope=&quot;singleton&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span><span class="comment">//等价于&lt;property name=&quot;name&quot; value=&quot;lemon&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Component的衍生注解：功能与@Component一致，都是将某个类装装配成bean。</p><ul><li>@Component–用于pojo</li><li>@Reposity–用于dao层</li><li>@Service–用于service层</li><li>@Controller–用于controller层</li></ul><p>总结：</p><ul><li>xml更加万能，适用于各种场合，维护简单</li><li>注解更加方便，不是自己的类使用不了，维护更复杂</li><li>常用实践：<ul><li>使用xml管理bean</li><li>使用注解完成属性注入（@Value）</li></ul></li></ul><h1 id="九、AppConfig"><a href="#九、AppConfig" class="headerlink" title="九、AppConfig"></a>九、AppConfig</h1><p>完全使用Java配置Spring（无xml），实质上是用Java类来替代xml文件。配置类需要用@Configuration声明。</p><p>xml配置后用<code>ClassPathXmlApplicationContext(&quot;path&quot;)</code>获取IOC容器，**@Configuration声明的配置类用<code>AnnotationConfigApplicationContext(Class&lt;?&gt;)</code>获取IOC容器**。</p><p>使用@Import(Class&lt;?&gt; [])注解来引入其他的配置类</p><p>使用@ImportResource(String [])注解来引入xml配置文件</p><p><strong>使用@Configuration声明配置类时有两种方法生成（注册）Bean</strong></p><ol><li><p>在配置类中定义一个方法，使用@Bean注解。方法返回值对应class，方法名对应beanId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">// 等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在需要注册的类上使用@Component注解，在配置类上使用@ComponentScan(“包”)开启包扫描（也可以用@ComponentScans(value&#x3D;”@ComponentScan数组”) 开启多个包扫描）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//等价于&lt;context:component-scan base-package=&quot;com.lemon.pojo&quot;/&gt;</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lemon.pojo&quot;)</span></span><br><span class="line"><span class="comment">//与上面等价 @ComponentScans(value=&#123;@ComponentScan(&quot;com.lemon.pojo&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果上述两种方法都使用，会创建两个Bean对象</p></li></ol><h1 id="十、代理模式"><a href="#十、代理模式" class="headerlink" title="十、代理模式"></a>十、代理模式</h1><p>代理模式即在不修改原有代码的基础上对原有功能进行增强。符合开闭原则。</p><h2 id="1、静态代理"><a href="#1、静态代理" class="headerlink" title="1、静态代理"></a>1、静态代理</h2><p>角色分析：</p><ul><li>抽象角色：一般使用接口或抽象类来解决，真实角色与代理角色都继承（实现）抽象角色。</li><li>真实角色：<strong>被代理</strong>的角色</li><li>代理角色：<strong>代理</strong>真实角色的角色，代理真实角色后，一般会做一些附属操作（比如权限检验）</li><li>客户：<strong>访问</strong>代理角色的角色</li></ul><p>优点：</p><ul><li>使真实角色的操作更加纯粹，不用去关注一些公共业务。（比如权限检验）</li><li>公共业务交给了代理角色，解耦。</li><li>公共业务发生拓展的时候，方便集中管理。（比如增加一个权限角色）</li></ul><p>缺点：</p><ul><li>一个真实角色就会产生一个代理角色，代码量翻倍，开发效率变低</li></ul><h2 id="2、动态代理"><a href="#2、动态代理" class="headerlink" title="2、动态代理"></a>2、动态代理</h2><ul><li>动态代理的角色与静态代理一致</li><li>动态代理的代理类是动态生成的，不是直接写好的</li><li>动态代理实现方法主要分为三类：<ul><li>基于接口的动态代理：JDK动态代理</li><li>基于类的动态代理：cglib</li><li>基于Java字节码：Javassist</li></ul></li></ul><h3 id="2-1、JDK的动态代理实现"><a href="#2-1、JDK的动态代理实现" class="headerlink" title="2.1、JDK的动态代理实现"></a>2.1、JDK的动态代理实现</h3><h4 id="2-1-1、Proxy类"><a href="#2-1-1、Proxy类" class="headerlink" title="2.1.1、Proxy类"></a>2.1.1、Proxy类</h4><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220216160801622.png" alt="image-20220216160801622"></p><p>用静态方法来获取代理类</p><h4 id="2-1-2、InvocationHandler接口"><a href="#2-1-2、InvocationHandler接口" class="headerlink" title="2.1.2、InvocationHandler接口"></a>2.1.2、InvocationHandler接口</h4><p>实现该接口的类称为处理机类，必须实现invoke方法。</p><p>使用该<code>处理机类的实例对象ih</code>生成<code>代理对象A</code>，A调用的任何方法，实质上都是通过反射获取到Method对象，然后交由给ih的invoke方法执行。</p><p>生成代理对象的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * classLoader:真实对象的类加载器</span></span><br><span class="line"><span class="comment"> * interfaces:需要代理的接口（真实对象中只有这些接口对应的方法才会被代理，生成的代理对象中只有这些接口对应的方法）</span></span><br><span class="line"><span class="comment"> * invocationHandler: 处理机对象，实现代理增加功能的关键！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Proxy.newProxyInstance(classLoader,<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]interfaces,invocationHandler);</span><br></pre></td></tr></table></figure><p><strong>特别注意</strong>：生成的代理对象<code>A</code>是接口对象，只有<code>interfaces</code>接口对应的方法</p><h4 id="2-1-3、demo"><a href="#2-1-3、demo" class="headerlink" title="2.1.3、demo"></a>2.1.3、demo</h4><ol><li><p>自定义InvocationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个处理机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">getUserService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceInvocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceInvocationHandler</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        check();</span><br><span class="line">        Object res=method.invoke(userService,args);</span><br><span class="line">        log(method.getName());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行权限检验&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;日志：执行了&quot;</span>+msg+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String arg)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insert业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;update业务,参数为：&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;select业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>client应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//        真实对象</span></span><br><span class="line">        UserServiceImpl userService=<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="comment">//        调用处理器，实现invoke方法，通过该调用处理器生成的代理对象，其调用方法都会使用这个invoke方法进行调用</span></span><br><span class="line">        UserServiceInvocationHandler invocationHandler=<span class="keyword">new</span> <span class="title class_">UserServiceInvocationHandler</span>(userService);</span><br><span class="line"><span class="comment">//        通过Proxy的静态方法，使用invocationHandler生成动态代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取代理对象</span></span><br><span class="line"><span class="comment">         * 真实对象的类加载器、代理对象代理的接口、处理机对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        UserService userService2= (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;UserService.class&#125;,invocationHandler);</span><br><span class="line"><span class="comment">//        通过代理对象调用方法</span></span><br><span class="line">        userService2.update(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* userService2.update(&quot;123&quot;); 等价于下面两行代码*/</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> invocationHandler.getUserService().getClass().getDeclaredMethod(<span class="string">&quot;update&quot;</span>, <span class="string">&quot;123&quot;</span>.getClass());</span><br><span class="line">        invocationHandler.invoke(userService2,method,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;123&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*newMethod()方法不是接口方法，因此userService2中没有该方法！*/</span></span><br><span class="line">        userService.newMethod();</span><br><span class="line"><span class="comment">//        userService2.newMethod(); //不存在该方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>项目结构</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220221091953436.png" alt="image-20220221091953436"></p></li></ol><h3 id="2-2、动态代理的好处"><a href="#2-2、动态代理的好处" class="headerlink" title="2.2、动态代理的好处"></a>2.2、动态代理的好处</h3><ul><li>使真实角色的操作更加纯粹，不用去关注一些公共业务。（比如权限检验）</li><li>公共业务交给了代理角色，解耦。</li><li>公共业务发生拓展的时候，方便集中管理。（比如增加一个权限角色）</li><li>一个动态代理类代理的是一个&#x2F;多个接口，一般就是对应一类业务。</li><li>一个动态代理类可以代理多个类，只要是实现了同一接口</li></ul><h1 id="十一、AOP"><a href="#十一、AOP" class="headerlink" title="十一、AOP"></a>十一、AOP</h1><h2 id="1、什么是AOP"><a href="#1、什么是AOP" class="headerlink" title="1、什么是AOP"></a>1、什么是AOP</h2><p> AOP即面向切面编程（Aspect Oriented Program） 。使用面向对象编程，降低了代码的复杂程度，使类可重用，但也增加了代码的重复性。例如：每个类都需要做日志，那按面向对象的设计方法，需要在两个类的方法中都加入日志的内容。也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<strong>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong></p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220216225246039.png" alt="image-20220216224738230"></p><h2 id="2、AOP在Spring中的作用"><a href="#2、AOP在Spring中的作用" class="headerlink" title="2、AOP在Spring中的作用"></a>2、AOP在Spring中的作用</h2><p><strong>提供声明式事务；允许用户自定义切面</strong></p><ul><li>横切关注点：影响应用多处的功能（日志、权限检验等）</li><li>通知（Adivce）：切面要完成的工作</li><li>连接点（JoinPoint）：应用程序执行过程中能插入切面的点（方法执行时，抛出错误时、方法返回时）</li><li>切点（PointCut）：定义通知被应用的位置（哪些方法需要织入切面）</li><li>切面（ASPECT）：通知和切点的集合</li><li>引入（Intorduction）：允许在现有的实现类中添加自定义的方法和属性。</li><li>目标（Target）：被通知的对象（动态代理中的真实对象）</li><li>代理（Proxy）：想目标对象应用通知后创建的对象（动态代理中的代理对象）</li><li>织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。Spring AOP框架默认采用动态代理织入，而AspectJ（基于Java语言的AOP框架）采用编译器织入和类装载期织入。</li></ul><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220216224738230.png" alt="image-20220216225246039"></p><p>SpringAOP中，通过Advice定义不同连接点的通知</p><table><thead><tr><th>通知类型</th><th>连接点</th><th>实现接口(org.springframework.aop.*)</th></tr></thead><tbody><tr><td>前置通知</td><td>方法前</td><td>MethonBeforeAdvice</td></tr><tr><td>后置通知</td><td>方法后</td><td>AfterReturningAdvice</td></tr><tr><td>环绕通知</td><td>方法前后</td><td>MethodInterceptor</td></tr><tr><td>异常抛出通知</td><td>方法抛出异常</td><td>ThrowAdvice</td></tr><tr><td>引介通知</td><td>类中增加新的方法属性</td><td>IntroductionInterceptor</td></tr></tbody></table><h2 id="3、使用Spring实现AOP"><a href="#3、使用Spring实现AOP" class="headerlink" title="3、使用Spring实现AOP"></a>3、使用Spring实现AOP</h2><h3 id="3-1、使用Spring的API接口"><a href="#3-1、使用Spring的API接口" class="headerlink" title="3.1、使用Spring的API接口"></a>3.1、使用Spring的API接口</h3><ol><li><p>自定义一个类，实现<code>AfterReturningAdive</code>接口（可以实现多个接口），即定义了一个<strong>连接点</strong>为方法返回时的<strong>通知</strong>，<code>afterReturning()</code>方法是通知的具体内容。并通过<code>@Component</code>注解将该切面注册到Spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterLog</span> <span class="keyword">implements</span> <span class="title class_">AfterReturningAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+method.getName()+<span class="string">&quot;方法，返回结果为&quot;</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml配置文件中配置AOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AOP，需要导入命名空间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点：在些方法执行 expression=&quot;execution(要执行的位置 方法修饰词 包名.类名 方法名 方法参数)&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行环绕增加</span></span><br><span class="line"><span class="comment">_ advice-ref:Spring容器中的切面beanID  pointcut-ref：已配置的切入点</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2、自定义类实现AOP"><a href="#3-2、自定义类实现AOP" class="headerlink" title="3.2、自定义类实现AOP"></a>3.2、自定义类实现AOP</h3><ol><li><p>自定义一个切面类，无需实现任何接口。在类中定义若干个方法作为<strong>通知</strong>。并通过<code>@Component</code>注解将该切面注册到Spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;diy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyPointCut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========方法执行前========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========方法执行后========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml配置文件中配置AOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--把beanID为diy的bean对象作为切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--切入点：在哪些方法执行  expression=&quot;execution(要执行的位置  方法修饰词 包名.类名.方法名(方法参数))&quot;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义连接点，before、after、...   method=该连接点用哪个通知（切面类中的方法） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>两种方法异同：</strong></p><ul><li>方法一在切面类中就已经规定好连接点，特定的方法名对应不同连接点。</li><li>方法二在xml配置文件中定义连接点，方法名与连接点之间无关。</li></ul><h3 id="3-3、注解实现"><a href="#3-3、注解实现" class="headerlink" title="3.3、注解实现"></a>3.3、注解实现</h3><ol><li><p>自定义一个切面类，不实现任何的接口。用<code>@Aspect</code>标记这是一个切面类。然后使用<code>@Component</code>将该切面类注册到Spring容器中。在类中定义若干个方法作为<strong>通知</strong>，并使用<code>@Before、@Around</code>等标记方法进行连接点和切点的定义。</p><p><strong>注意</strong>：一个方法只能有一个连接点-切入点注解生效，生效的是连接点最前的注解。例如在同一个方法同时使用了<code>@After @Before</code>，则生效的是<code>Before</code>，因为<code>@Before</code>是切点（方法执行）前执行，而<code>@After</code>是切点（方法执行）后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 把这个自定义切面注册到Spring容器中</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationPointCut</span> &#123;</span><br><span class="line">    <span class="comment">//  同时配置连接点（Before、After、...） 和切入点（execution()）</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======方法执行前=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  使用已定义的切点进行配置</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut1()&quot;)</span></span><br><span class="line">    <span class="comment">//  在环绕增强中，我们可以给定一个ProceedingJoinPoint参数，用来获取被 应用通知 的点（如：方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed(); <span class="comment">//        执行方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml配置文件中开启aop注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!--开启AOP注解  </span></span><br><span class="line"><span class="comment">--proxy-target-class=&quot;false&quot;  采用JDK方式实现动态代理/AOP  </span></span><br><span class="line"><span class="comment">--proxy-target-class=&quot;true&quot;   采用cglib的方式实现动态代理/AOP--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>常用AOP注解</p><table><thead><tr><th><strong>注解名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>@Aspect</td><td>用于定义一个切面，注解在切面类上</td></tr><tr><td>@Pointcut</td><td>用于定义切入点表达式。在使用时，需要定义一个切入点方法。该方法是一个返回值void，且方法体为空的普通方法，方法名()即切点名</td></tr><tr><td>@Before</td><td>用于定义前置通知。在使用时，通常为其指value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@AfterReturning</td><td>用于定义后置返回通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@Around</td><td>用于定义环绕通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@AfterThrowing</td><td>用于定义异常通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式。另外，还有一个throwing属性用于访问目标方法抛出的异常，该属性值与异常通知方法中同名的形参一致</td></tr><tr><td>@Aftter</td><td>用于定义后置（最终）通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr></tbody></table></li></ol><h1 id="十二、整合MyBatis"><a href="#十二、整合MyBatis" class="headerlink" title="十二、整合MyBatis"></a>十二、整合MyBatis</h1><blockquote><p>待补充</p></blockquote><h1 id="十三、声明式事务"><a href="#十三、声明式事务" class="headerlink" title="十三、声明式事务"></a>十三、声明式事务</h1><blockquote><p>待补充</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1WE411d7Dv">【狂神说Java】Spring5最新完整教程IDEA版通俗易懂</a></p><p><a href="https://blog.csdn.net/qq_33082731/article/details/75066956">Spring的七大模块，以及每个模块的作用</a></p><p><a href="https://zhuanlan.zhihu.com/p/40784174">Java编程—Spring框架七大模块</a></p><p><a href="https://baike.baidu.com/item/spring%E6%A1%86%E6%9E%B6/2853288?fr=aladdin">Spring框架-百度百科</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html">Spring官方文档</a></p><p><a href="https://www.iteye.com/blog/hejiajunsh-1776569">JavaWeb过滤器.监听器.拦截器-原理&amp;区别-个人总结</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注解名称一、什么是Spring&quot;&gt;&lt;a href=&quot;#注解名称一、什么是Spring&quot; class=&quot;headerlink&quot; title=&quot;注解名称一、什么是Spring&quot;&gt;&lt;/a&gt;&lt;strong&gt;注解名称&lt;/strong&gt;一、什么是Spring&lt;/h1&gt;&lt;p&gt;S</summary>
      
    
    
    
    <category term="Java" scheme="https://yi-jiao-chan.github.io/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://yi-jiao-chan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-200. 岛屿数量</title>
    <link href="https://yi-jiao-chan.github.io/posts/5ad2b77.html"/>
    <id>https://yi-jiao-chan.github.io/posts/5ad2b77.html</id>
    <published>2022-02-16T12:20:00.000Z</published>
    <updated>2022-02-16T13:49:34.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></p><p>给你一个由<code> &#39;1&#39;</code>（陆地）和<code> &#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><blockquote><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>两种思路：</p><ul><li>使用并查集把所有为<code>1</code>的节点连接起来，用<code>parent</code>数组记录，最后遍历<code>parent</code>数组查询有多少个<code>parent[i]=[i]</code></li><li>dfs&#x2F;bfs遍历所有<code>1</code>节点，把遍历到的节点修改成<code>0</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> []parent=<span class="keyword">new</span> <span class="title class_">int</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>) parent[i*grid[<span class="number">0</span>].length+j]=i*grid[<span class="number">0</span>].length+j;</span><br><span class="line">               <span class="keyword">else</span> parent[i*grid[<span class="number">0</span>].length+j]=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 上</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;grid[i-<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> now=getParent(parent,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="type">int</span> up=getParent(parent,(i-<span class="number">1</span>)*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="keyword">if</span>(now!=up)&#123;</span><br><span class="line">                        parent[now]=up;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>&amp;&amp;grid[i][j-<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> now=getParent(parent,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="type">int</span> left=getParent(parent,i*grid[<span class="number">0</span>].length+j-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(now!=left)&#123;</span><br><span class="line">                        parent[now]=left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;parent.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i]==i) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> []parent,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[index]!=index)&#123;</span><br><span class="line">            parent[index]=getParent(parent,parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs和dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[i].length;j++)&#123;</span><br><span class="line">                <span class="comment">/*bfs*/</span></span><br><span class="line">                <span class="comment">// if(grid[i][j]==&#x27;1&#x27;) bfs(grid,i,j);</span></span><br><span class="line">                <span class="comment">/*dfs*/</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span> [][]grid,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;=grid.length||col&lt;<span class="number">0</span>||col&gt;=grid[<span class="number">0</span>].length||grid[row][col]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> [] arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        grid[row][col]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            dfs(grid,row+arr[i-<span class="number">1</span>],col+arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="type">int</span> cols=grid[<span class="number">0</span>].length;</span><br><span class="line">        Deque&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(row*cols+col);</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> index=queue.poll();</span><br><span class="line">            row=index/cols;</span><br><span class="line">            col=index%cols;</span><br><span class="line">            <span class="keyword">if</span>(grid[row][col]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            grid[row][col]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line">            <span class="keyword">if</span>(row&gt;<span class="number">0</span>&amp;&amp;grid[row-<span class="number">1</span>][col]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index-cols);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span>(col&gt;<span class="number">0</span>&amp;&amp;grid[row][col-<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">if</span>(row&lt;grid.length-<span class="number">1</span>&amp;&amp;grid[row+<span class="number">1</span>][col]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index+cols);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(col&lt;cols-<span class="number">1</span>&amp;&amp;grid[row][col+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index+<span class="number">1</span>);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands&quot;&gt;https://l</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="dfs" scheme="https://yi-jiao-chan.github.io/tags/dfs/"/>
    
    <category term="并查集" scheme="https://yi-jiao-chan.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="bfs" scheme="https://yi-jiao-chan.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-8. 字符串转换整数 (atoi)</title>
    <link href="https://yi-jiao-chan.github.io/posts/263d0e65.html"/>
    <id>https://yi-jiao-chan.github.io/posts/263d0e65.html</id>
    <published>2022-02-16T12:20:00.000Z</published>
    <updated>2022-02-16T13:49:34.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi">https://leetcode-cn.com/problems/string-to-integer-atoi</a></p><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li><li>返回整数作为最终结果。</li></ol><blockquote><ul><li><p>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</p></li><li><p>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</p></li><li><p><code>0 &lt;= s.length &lt;= 200</code></p></li><li><p><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</p></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>模拟题，多设计样例进行边界测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除前导空格</span></span><br><span class="line">        s=s.trim();</span><br><span class="line">        <span class="comment">// 转换成char数组遍历更快</span></span><br><span class="line">        <span class="type">char</span> []chars=s.toCharArray();</span><br><span class="line">        <span class="comment">// 去除前导空格后为空串，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(chars.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录正负</span></span><br><span class="line">        <span class="type">int</span> direction=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 判断第一位是否是正负号，如果是负号则修改direction</span></span><br><span class="line">        <span class="keyword">if</span>(chars[i]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            direction=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历计算连续值（前导0在计算过程中会自动去除）</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;chars.length)&#123;</span><br><span class="line">            <span class="comment">// 遇到非数字字节跳出遍历</span></span><br><span class="line">            <span class="keyword">if</span>(chars[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;chars[i]&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                res=res*<span class="number">10</span>+(<span class="type">int</span>)(chars[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超过int类型就跳出（根据正负号分别进行判断）</span></span><br><span class="line">            <span class="keyword">if</span>(direction==<span class="number">1</span>&amp;&amp;res&gt;=Integer.MAX_VALUE)&#123;</span><br><span class="line">                res=Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==-<span class="number">1</span>&amp;&amp;res&gt;Integer.MAX_VALUE)&#123;</span><br><span class="line">                res=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) res*direction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-integer-atoi&quot;&gt;http</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
  </entry>
  
</feed>
