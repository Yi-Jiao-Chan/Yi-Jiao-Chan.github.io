<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柠檬的个人博客</title>
  <icon>https://www.gravatar.com/avatar/ce19897a92677092dba1f768f6eeb22e</icon>
  
  <link href="https://yi-jiao-chan.github.io/atom.xml" rel="self"/>
  
  <link href="https://yi-jiao-chan.github.io/"/>
  <updated>2022-02-28T11:43:20.315Z</updated>
  <id>https://yi-jiao-chan.github.io/</id>
  
  <author>
    <name>Lemon Chan</name>
    <email>yi_jiao_chan@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode刷题笔记-863. 二叉树中所有距离为 K 的结点</title>
    <link href="https://yi-jiao-chan.github.io/posts/a535a0e3.html"/>
    <id>https://yi-jiao-chan.github.io/posts/a535a0e3.html</id>
    <published>2022-02-28T11:33:00.000Z</published>
    <updated>2022-02-28T11:43:20.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree">https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree</a></p><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点<code>target</code> ，和一个整数值<code> k</code> 。</p><p>返回到目标结点<code>target</code>距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/sketch0.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2</span><br><span class="line">输出：[7,4,1]</span><br><span class="line">解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1</span><br><span class="line"></span><br><span class="line">输入: root = [1], target = 1, k = 3</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题中所求的是距离target节点距离为k的所有节点，而每个节点只能往3个方向走：左节点、右节点、父节点。因此要扫描一遍树，记录下所有节点的父节点（实际上只需记录下<code>target</code>及其前方所有节点的父节点即可，因为只有这些节点需要网上扫描。但判断是否是target需要耗时，在本题中扫描整棵树效率更高）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录下每个节点的父节点</span></span><br><span class="line">    Map&lt;TreeNode,TreeNode&gt; parents=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        serach(root,<span class="literal">null</span>);</span><br><span class="line">        dfs(<span class="literal">null</span>,target,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serach</span><span class="params">(TreeNode root,TreeNode parent)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        parents.put(root,parent);</span><br><span class="line">        serach(root.left,root);</span><br><span class="line">        serach(root.right,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode last,TreeNode root,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ==0了，再走就没必要了，return</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是回头路就不要走</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=last)</span><br><span class="line">            dfs(root,root.left,k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=last)</span><br><span class="line">            dfs(root,root.right,k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(parents.get(root)!=last)</span><br><span class="line">            dfs(root,parents.get(root),k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/all-nodes-distance-k-in-bina</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="dfs" scheme="https://yi-jiao-chan.github.io/tags/dfs/"/>
    
    <category term="哈希" scheme="https://yi-jiao-chan.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-973. 最接近原点的 K 个点</title>
    <link href="https://yi-jiao-chan.github.io/posts/2e849c9d.html"/>
    <id>https://yi-jiao-chan.github.io/posts/2e849c9d.html</id>
    <published>2022-02-28T08:56:00.000Z</published>
    <updated>2022-02-28T11:43:20.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin">https://leetcode-cn.com/problems/k-closest-points-to-origin</a></p><p>给定一个数组 points ，其中 <code>points[i] = [xi, yi]</code> 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点<code>(0,0)</code>最近的 <code>k </code>个点。</p><p>这里，平面上两点之间的距离是 欧几里德距离<code>（ √(x1 - x2)2 + (y1 - y2)2 ）</code>。</p><p>你可以<strong>按 任何顺序 返回答案</strong>。除了点坐标的顺序之外，答案 确保 是 唯一 的。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,3],[-2,2]], k = 1</span><br><span class="line">输出：[[-2,2]]</span><br><span class="line">解释： </span><br><span class="line">(1, 3) 和原点之间的距离为 sqrt(10)，</span><br><span class="line">(-2, 2) 和原点之间的距离为 sqrt(8)，</span><br><span class="line">由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。</span><br><span class="line">我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。</span><br><span class="line"></span><br><span class="line">输入：points = [[3,3],[5,-1],[-2,4]], k = 2</span><br><span class="line">输出：[[3,3],[-2,4]]</span><br><span class="line">（答案 [[-2,4],[3,3]] 也会被接受。）</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>堆排序，取k次堆顶即可。因为答案要求返回节点的x和y坐标，而排序标准是与原点距离，因此新建一个类存放x、y、len，排序过程中就不用反复计算len节省时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 建一个类来存放x，y和原点距离len</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">long</span> len;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">long</span> len)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.x=x;</span><br><span class="line">            <span class="built_in">this</span>.y=y;</span><br><span class="line">            <span class="built_in">this</span>.len=len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] kClosest(<span class="type">int</span>[][] points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 建堆</span></span><br><span class="line">        Node [] arr=<span class="keyword">new</span> <span class="title class_">Node</span> [points.length];</span><br><span class="line">        <span class="comment">// 把数据加入堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">long</span> len=points[i][<span class="number">0</span>]*points[i][<span class="number">0</span>]+points[i][<span class="number">1</span>]*points[i][<span class="number">1</span>];</span><br><span class="line">            arr[i]=<span class="keyword">new</span> <span class="title class_">Node</span>(points[i][<span class="number">0</span>],points[i][<span class="number">1</span>],len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化堆（从最后一个非叶子节点开始建队，逐渐前移）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sortHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> [][]res=<span class="keyword">new</span> <span class="title class_">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">// 堆顶为当前距离原点最近的点，取出并加入结果集</span></span><br><span class="line">            res[i]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>].x,arr[<span class="number">0</span>].y&#125;;</span><br><span class="line">            <span class="comment">// 把堆顶与堆末尾交换，移出堆</span></span><br><span class="line">            swap(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>-i);</span><br><span class="line">            <span class="comment">// 堆顶交换了，所以从堆顶位置整理堆</span></span><br><span class="line">            sortHeap(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入堆、整理的节点下标、堆的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortHeap</span><span class="params">(Node []arr,<span class="type">int</span> index,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 越界返回</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果存在右节点且右节点的值更小，则右节点称为可能与根节点交换的节点</span></span><br><span class="line">        <span class="keyword">if</span>(left+<span class="number">1</span>&lt;length&amp;&amp;arr[left].len&gt;arr[left+<span class="number">1</span>].len)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点值比左/右节点的最小值小，交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[index].len&gt;arr[left].len)&#123;</span><br><span class="line">            swap(arr,index,left);</span><br><span class="line">            <span class="comment">// 交换后要整理被交换的子节点</span></span><br><span class="line">            sortHeap(arr,left,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Node []arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Node temp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/k-closest-points-to-origin&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="堆排序" scheme="https://yi-jiao-chan.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-55. 跳跃游戏</title>
    <link href="https://yi-jiao-chan.github.io/posts/a738f689.html"/>
    <id>https://yi-jiao-chan.github.io/posts/a738f689.html</id>
    <published>2022-02-27T15:14:00.000Z</published>
    <updated>2022-02-27T15:17:49.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><blockquote><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心，记录下当前可以跳的最大步数，然后每次跳一步，步数－－。如果当前位置能跳的步数大于剩下能跳的步数，则在这个位置停下，然后重新记录能跳的最大步数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录下当前能往前走的最大长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果长度为0，则不能走到当前位置，return false</span></span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 每走一步长度--</span></span><br><span class="line">            len--;</span><br><span class="line">            <span class="comment">// 更新可走长度</span></span><br><span class="line">            len=Math.max(len,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game/&quot;&gt;https://leetcode</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="贪心" scheme="https://yi-jiao-chan.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-264. 丑数 II</title>
    <link href="https://yi-jiao-chan.github.io/posts/a62a3dc0.html"/>
    <id>https://yi-jiao-chan.github.io/posts/a62a3dc0.html</id>
    <published>2022-02-27T13:05:00.000Z</published>
    <updated>2022-02-27T13:30:20.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br><span class="line"></span><br><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol><li><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。即丑数只能由丑数×2、×3、×5得出。已知丑数集合<code>[1]</code>，分别可以算出<code>[1*2][1*3][1*5]</code>，取其中最小<code>2</code>的加入丑数集合得到<code>[1,2]</code>。</li><li>然后可以算出来丑数<code>[1*2,2*2][1*3,2*3][1*5,2*5]</code>，三组丑数中仅有<code>[1*2]</code>是重复的，因为<code>1*2</code>上一轮已经加入了丑数集合，因此本轮应该只算出丑数<code>[2*2][1*3,2*3][1*5,2*5]</code>，如何只算出这些呢？显而易见的是，2不能×丑数中的第一个数了。此时加入丑数集合的应该是<code>1*3</code>，得到<code>[1,2,3]</code></li><li>然后可以算出来丑数<code>[1*2,2*2,3*2][1*3,2*3,3*3][1*5,2*5,3*5]</code>，三组丑数中<code>[1*2][1*3]</code>是重复的，因为<code>1*2和1*3</code>之前已经加入了丑数集合，因此本轮应该只算出丑数<code>[3*2][2*3,3*3][1*5,2*5,3*5]</code>，如何只算出这些呢？显而易见的是，2和3都不能×丑数中的第一个数了。此时加入丑数集合的应该是<code>2*2</code>，得到<code>[1,2,3，4]</code></li><li>显而易见，剔除掉已经加入丑数集合的计算结果后，每次加入数组的都是算出的3组计算结果中最小的，而每组结果组内是递增的，因此我们只需要计算每组第一个未被加入丑数数组的的结果，取三者最小加入丑数集合即可。</li><li>所以我们应该维护3个指针，三个指针所指向的数分别×2、×3、×5，3者最小值就是下一个丑数。而如果计算出的下一个丑数是该指针的计算结果，则该指针需要++（因为不可重复）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 分别记录*2 *3 *5的数的下标</span></span><br><span class="line">        <span class="type">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>,idx=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;n)&#123;</span><br><span class="line">            <span class="comment">// 计算出三个指针指向丑数分别*2 *3 *5的结果</span></span><br><span class="line">            <span class="type">int</span> num2=arr[p2]*<span class="number">2</span>,num3=arr[p3]*<span class="number">3</span>,num5=arr[p5]*<span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 计算结果的最小值是下一个丑数</span></span><br><span class="line">            arr[idx]=Math.min(num2,Math.min(num3,num5));</span><br><span class="line">            <span class="comment">// 如果下一丑数是该指针的计算结果，则需要++。</span></span><br><span class="line">            <span class="comment">//  可能出现下一丑数是多个指针的计算结果的情况，则多个指针++</span></span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num2)&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num3)&#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx]==num5)&#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number-ii/&quot;&gt;https://lee</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="动态规划" scheme="https://yi-jiao-chan.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-501. 二叉搜索树中的众数</title>
    <link href="https://yi-jiao-chan.github.io/posts/c505a049.html"/>
    <id>https://yi-jiao-chan.github.io/posts/c505a049.html</id>
    <published>2022-02-26T13:46:00.000Z</published>
    <updated>2022-02-26T13:51:30.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><blockquote><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220226214928619.png" alt="image-20220226214928619"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,4,4,3,4,4,5,1,3]</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由题意可知，每一个节点的父节点和右节点，其值必定大于或等于当前节点值。因此中序遍历必定是非降序，即可计算出每个值出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        TreeNode last=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxCnt=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// Morris遍历，寻找左子树的最右节点</span></span><br><span class="line">            TreeNode leftRight=root.left;</span><br><span class="line">            <span class="keyword">while</span>(leftRight!=<span class="literal">null</span>&amp;&amp;leftRight.right!=<span class="literal">null</span>&amp;&amp;leftRight.right!=root)&#123;</span><br><span class="line">                leftRight=leftRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左子树最右节点为空（没有左子树），或者已经连接过了（即左子树已经遍历过）</span></span><br><span class="line">            <span class="comment">//  中序遍历，所以轮到当前节点被扫描到</span></span><br><span class="line">            <span class="keyword">if</span>(leftRight==<span class="literal">null</span>||leftRight.right==root)&#123;</span><br><span class="line">                <span class="comment">// 判断是否跟上一个扫描的节点值相同，如果相同cnt++，否则cnt设为1</span></span><br><span class="line">                <span class="keyword">if</span>(last!=<span class="literal">null</span>&amp;&amp;last.val==root.val)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果cnt&gt;maxCnt，则已经记录下的数值不是众数，clear结果集并更新maxCnt</span></span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;maxCnt)&#123;</span><br><span class="line">                    maxCnt=cnt;</span><br><span class="line">                    res.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前节点值的cnt与maxCnt一致，是暂时的众数，加入结果集</span></span><br><span class="line">                <span class="keyword">if</span>(cnt==maxCnt)&#123;</span><br><span class="line">                    res.add(root.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历右子树</span></span><br><span class="line">                last=root;</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 把左子树最右节点的right指向当前节点，然后遍历左子树</span></span><br><span class="line">                leftRight.right=root;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> []arr=<span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:res)&#123;</span><br><span class="line">            arr[cnt++]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。&lt;/p&gt;
&lt;p&gt;如</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="Morris遍历" scheme="https://yi-jiao-chan.github.io/tags/Morris%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-3. 无重复字符的最长子串</title>
    <link href="https://yi-jiao-chan.github.io/posts/6c54b1f1.html"/>
    <id>https://yi-jiao-chan.github.io/posts/6c54b1f1.html</id>
    <published>2022-02-26T13:00:00.000Z</published>
    <updated>2022-02-26T13:51:30.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>滑动窗口，始终维护一个没有重复字符的窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录该字符上一次出现的位置（记录值是下标+1）</span></span><br><span class="line">        <span class="type">int</span> []visited=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">255</span>];</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">1</span>,res=<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> []chars=s.toCharArray();</span><br><span class="line">        <span class="comment">// 滑动窗口，begin是左边界（记录的是下标+1），i是右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="comment">// System.out.println(visited[chars[i]]);</span></span><br><span class="line">            <span class="comment">// 当前字符上一次出现位置在窗口内，则左边界要移动，移动到当前字符上一次出现位置+1</span></span><br><span class="line">            <span class="keyword">if</span>(visited[chars[i]]&gt;=begin)&#123;</span><br><span class="line">                res=Math.max(res,i-begin+<span class="number">1</span>);</span><br><span class="line">                begin=visited[chars[i]]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录位置</span></span><br><span class="line">            visited[chars[i]]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右边界出了数组的特判</span></span><br><span class="line">        res=Math.max(res,chars.length-begin+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-re</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="滑动窗口" scheme="https://yi-jiao-chan.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-1642. 可以到达的最远建筑</title>
    <link href="https://yi-jiao-chan.github.io/posts/f2bf78e0.html"/>
    <id>https://yi-jiao-chan.github.io/posts/f2bf78e0.html</id>
    <published>2022-02-26T12:37:00.000Z</published>
    <updated>2022-02-26T13:51:30.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach">https://leetcode-cn.com/problems/furthest-building-you-can-reach</a></p><p>给你一个整数数组 <code>heights </code>，表示建筑物的高度。另有一些砖块 <code>bricks </code>和梯子<code>ladders</code>。</p><p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p><p>当从建筑物<code>i</code>移动到建筑物<code> i+1</code>（<strong>下标 从 0 开始</strong> ）时：</p><p>如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块<br>如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 <code>(h[i+1] - h[i]) </code>个砖块<br>如果以最佳方式使用给定的梯子和砖块，返回你可以到达的<strong>最远建筑物的下标</strong>（下标 从 0 开始 ）。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/q4.gif" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：从建筑物 0 出发，你可以按此方案完成旅程：</span><br><span class="line">- 不使用砖块或梯子到达建筑物 1 ，因为 4 &gt;= 2</span><br><span class="line">- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 &lt; 7</span><br><span class="line">- 不使用砖块或梯子到达建筑物 3 ，因为 7 &gt;= 6</span><br><span class="line">- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 &lt; 9</span><br><span class="line">无法越过建筑物 4 ，因为没有更多砖块或梯子。</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">输入：heights = [14,3,19,3], bricks = 17, ladders = 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>贪心，每次遇到难关先记录下如果用砖头的话，需要多少块。</p></li><li><p>如果此时有梯子，就用梯子。</p></li><li><p>如果此时没有梯子，则从前方记录下的每一关用梯子替换掉的砖头数中，取出用需要砖头数最少的位置。</p><ul><li>如果当前砖头数满足要求，则删除该记录（把该位置用砖头填上了，当前位置就可以用梯子）</li><li>如果当前砖头数量不满足要求，则无法到达，结束</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">furthestBuilding</span><span class="params">(<span class="type">int</span>[] heights, <span class="type">int</span> bricks, <span class="type">int</span> ladders)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;heights.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sub=heights[i]-heights[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(sub&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 把所需砖头树加入优先队列</span></span><br><span class="line">                queue.offer(sub);</span><br><span class="line">                <span class="comment">// 如果有梯子，先用梯子</span></span><br><span class="line">                <span class="keyword">if</span>(ladders&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ladders--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(queue.peek()&lt;=bricks)&#123;</span><br><span class="line">                     <span class="comment">// 如果没梯子了,就把之前用了梯子的一个地方，替换成砖头。要找砖头需求数最少的位置</span></span><br><span class="line">                    bricks-=queue.poll();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> i-<span class="number">1</span>;   <span class="comment">// 怎样都不能到当前位置，返回i-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heights.length-<span class="number">1</span>;    <span class="comment">//出了循环就能到达最后一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/furthest-building-you-can-re</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="优先队列" scheme="https://yi-jiao-chan.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://yi-jiao-chan.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-简单（静态）工厂模式</title>
    <link href="https://yi-jiao-chan.github.io/posts/e14d1dd7.html"/>
    <id>https://yi-jiao-chan.github.io/posts/e14d1dd7.html</id>
    <published>2022-02-25T02:29:00.000Z</published>
    <updated>2022-02-26T13:51:30.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>简单工厂模式（Simple Factory Pattern）又称静态工厂方法模式（Static Factory Method），属于<strong>创建型模式</strong>，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义了一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Factory：工厂角色，负责创建对象实例</li><li>Product：抽象类，是工厂生产的所有产品的基类&#x2F;接口</li><li>ConcreteProduct：具体类，有一个或多个，是工厂生产的产品类</li></ul><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220225103432166.png" alt="image-20220225103432166"></p><h2 id="模式实例"><a href="#模式实例" class="headerlink" title="模式实例"></a>模式实例</h2><p>要求：某电视机厂专为各知名电视机品牌代工生产各类电视机，当需要海尔牌电视机时只需要在调用该工厂的工厂方法时传入参数<code>“Haier”</code>，需要海信电视机时只需要传入参数<code>“Hisense”</code>，<strong>工厂可以根据传入的不同参数返回不同品牌的电视机</strong>。现使用简单工厂模式来模拟该电视机工厂的生产过程。</p><p><code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteProduct</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaierTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Haier电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HisenseTv</span> <span class="keyword">implements</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hisense电视正在运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TV <span class="title function_">productTV</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.equalsIgnoreCase(<span class="string">&quot;Haier&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在生产Haier电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equalsIgnoreCase(<span class="string">&quot;Hisense&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在生产Hisense电视！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HisenseTv</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            thorw <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;对不起，暂不能生产该品牌电视机!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li><p>优点：</p><ul><li><p>将对象的创建和对象本身业务处理分离，降低系统耦合度，使两者都更加便于修改。</p></li><li><p>静态方法使用方便，不需要实例化工厂。</p></li><li><p>只需要传入参数即可创建对象，不需要知道实现细节。</p></li><li><p>可以把参数保存至<strong>XML配置文件</strong>中，修改时不需要修改Java源代码。</p></li></ul></li><li><p>缺点：</p><ul><li>工厂类集中了所有产品的创建逻辑，<strong>职责过重</strong>，一旦不能工作整个系统都会受影响。</li><li><strong>增加了系统中类的数量</strong>（增加了工厂类），增加系统复杂度和理解难度</li><li>系统拓展困难，一旦增加产品，就需要修改工厂类。</li><li>因为静态方法无法被继承，因此工厂类也无法形成基于继承的等级结构，工厂类不能得到很好地扩展。</li></ul></li><li><p>使用简单工厂模式的情况：</p><ul><li>工厂类负责创建的对象比较少，职责不会过重，逻辑不会过于复杂</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;简单工厂模式（Simple Factory Pattern）又称静态工厂方法模式（Static Factory Method</summary>
      
    
    
    
    <category term="大学课程" scheme="https://yi-jiao-chan.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="设计模式" scheme="https://yi-jiao-chan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-149. 直线上最多的点数</title>
    <link href="https://yi-jiao-chan.github.io/posts/229ddae5.html"/>
    <id>https://yi-jiao-chan.github.io/posts/229ddae5.html</id>
    <published>2022-02-22T13:39:00.000Z</published>
    <updated>2022-02-22T15:16:55.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p><blockquote><ul><li><code>1 &lt;= points.length &lt;= 300</code></li><li><code>points[i].length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li><li><code>points</code> 中的所有点 <strong>互不相同</strong></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220222214716400.png" alt="image-20220222214716400" style="zoom:50%;" /><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,1],[2,2],[3,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220222214733386.png" alt="image-20220222214733386" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>双重循环，遍历每一个点与其他定点所形成的直线的斜率，因为其一为定点，所以斜率相等即同一直线。用<code>HashMap&lt;Double,Integer&gt;</code>记录斜率对应点个数即可。</p><p>因为<code>double</code>存在精度丢失问题，可以使用<code>String</code>类型记录<code>&quot;Δy/Δx&quot;</code>作为key存入<code>HashMap&lt;String,Integer&gt;</code>（lc中本题使用Double也可通过）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储各个斜率对应的点的个数</span></span><br><span class="line">        Map&lt;Double,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有点，以该点为定点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 剩余的点数量不足以更新res，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;=points.length-i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 重置map</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="comment">// 确定定点后，遍历剩余的点，两点计算斜率，用map存储每一个斜率对应点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="comment">// 因为前面的点已经计算过其与其他各个点的斜率，即也计算了与当前点的斜率， 因此遍历从i+1开始</span></span><br><span class="line">                <span class="type">int</span> deltaX=points[j][<span class="number">0</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> deltaY=points[j][<span class="number">1</span>]-points[i][<span class="number">1</span>];</span><br><span class="line">                Double k=<span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 被除数为0，则结果为0。 但0有+0和-0两种情况，特判</span></span><br><span class="line">                <span class="keyword">if</span>(deltaY==<span class="number">0</span>)&#123;</span><br><span class="line">                    k=<span class="number">0D</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deltaX!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 除数不能为0，需要特判，刚好hashmap可以存放null key，所以设为null。</span></span><br><span class="line">                    k=(<span class="type">double</span>)deltaY/(<span class="type">double</span>)deltaX;</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="type">int</span> cnt=map.getOrDefault(k,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                res=Math.max(res,cnt);</span><br><span class="line">                map.put(k,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用String替换Double的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储各个斜率对应的点的个数</span></span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有点，以该点为定点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 剩余的点数量不足以更新res，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;=points.length-i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 重置map</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="comment">// 确定定点后，遍历剩余的点，两点计算斜率，用map存储每一个斜率对应点的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="comment">// 因为前面的点已经计算过其与其他各个点的斜率，即也计算了与当前点的斜率， 因此遍历从i+1开始</span></span><br><span class="line">                <span class="type">int</span> deltaX=points[j][<span class="number">0</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> deltaY=points[j][<span class="number">1</span>]-points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 默认是除数为0状态</span></span><br><span class="line">                String k=<span class="string">&quot;max&quot;</span>;</span><br><span class="line">                <span class="comment">// 被除数为0，则结果为0。 但0有+0和-0两种情况，特判</span></span><br><span class="line">                <span class="keyword">if</span>(deltaY==<span class="number">0</span>)&#123;</span><br><span class="line">                    k=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deltaX!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 除数不为0才进行计算</span></span><br><span class="line">                    <span class="type">int</span> t=gcd(deltaX,deltaY);</span><br><span class="line">                    <span class="comment">// 除以最大公约数，化简分数</span></span><br><span class="line">                    deltaX/=t;</span><br><span class="line">                    deltaY/=t;</span><br><span class="line">                    k=deltaX+<span class="string">&quot;/&quot;</span>+deltaY;</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="type">int</span> cnt=map.getOrDefault(k,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                res=Math.max(res,cnt);</span><br><span class="line">                map.put(k,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;points&lt;/code&gt; ，其中 &lt;code&gt;points[i] = [xi, yi]&lt;/code&gt; 表示 &lt;s</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="hard" scheme="https://yi-jiao-chan.github.io/tags/hard/"/>
    
    <category term="哈希" scheme="https://yi-jiao-chan.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-218. 天际线问题</title>
    <link href="https://yi-jiao-chan.github.io/posts/7257d04d.html"/>
    <id>https://yi-jiao-chan.github.io/posts/7257d04d.html</id>
    <published>2022-02-21T03:27:00.000Z</published>
    <updated>2022-02-22T15:16:55.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。</p><p>每个建筑物的几何信息由数组 <code>buildings</code> 表示，其中三元组 <code>buildings[i] = [lefti, righti, heighti]</code> 表示：</p><p><code>lefti</code> 是第 <code>i</code> 座建筑物左边缘的 <code>x</code> 坐标。<br><code>righti</code> 是第 <code>i</code> 座建筑物右边缘的 <code>x</code> 坐标。<br><code>heighti </code>是第 <code>i</code> 座建筑物的高度。<br>你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。</p><p>天际线 应该表示为由 “关键点” 组成的列表，格式<code>[[x1,y1],[x2,y2],...]</code>，并按<code>x</code>坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如<code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code>是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p><blockquote><p><code>1 &lt;= buildings.length &lt;= 104</code><br><code>0 &lt;= lefti &lt; righti &lt;= 231 - 1</code><br><code>1 &lt;= heighti &lt;= 231 - 1</code><br><code>buildings</code>按<code>lefti</code>非递减排序</p></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220221113143326.png" alt="image-20220221113143326"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</span><br><span class="line">输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</span><br><span class="line">解释：</span><br><span class="line">图 A 显示输入的所有建筑物的位置和高度，</span><br><span class="line">图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings = [[0,2,3],[2,5,3]]</span><br><span class="line">输出：[[0,3],[5,0]]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>扫描线：把每个矩形转变成两条竖直边。题中所求的是，两个矩形相交位置为x坐标，两矩形高度更大者为y坐标。所以可以维护一个优先队列（大根堆），扫描线的过程中将每一条左边对应的高度入队列（矩形开始），如果遇到右边，则将对应的高度出队列（矩形结束）。因此优先队列的对头存储的始终是当前位置的最高矩形的高度，则该高度与当前位置x坐标就可以确定一个答案点（注意要忽略连续相同的高度）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getSkyline</span><span class="params">(<span class="type">int</span>[][] buildings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=buildings.length;</span><br><span class="line">        <span class="comment">//把每个矩形转变成两条竖线，记录下x坐标、高度、是矩形左边/右边 &#123;x,y,left/right&#125;</span></span><br><span class="line">        <span class="type">int</span> [][] lines=<span class="keyword">new</span> <span class="title class_">int</span>[n*<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []building:buildings)&#123;</span><br><span class="line">            <span class="comment">// 1代表左边，-1代表右边</span></span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;building[<span class="number">0</span>],building[<span class="number">2</span>],<span class="number">1</span>&#125;;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;building[<span class="number">1</span>],building[<span class="number">2</span>],-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对转换出来的竖线排序，按x坐标升序。</span></span><br><span class="line">        <span class="comment">//      如果x相同，则先排左边，再排右边。</span></span><br><span class="line">        <span class="comment">//          左边线按高度降序。 保证同一个位置，取的是最高的点</span></span><br><span class="line">        <span class="comment">//          右边线按高度升序。 保证此前最高的点，最晚出队列。</span></span><br><span class="line">                    <span class="comment">//  本质上是将高度不一，x坐标和宽度完全一致的矩形，看作是高度大的矩形包含高度小的矩形</span></span><br><span class="line">        Arrays.sort(lines,(line1,line2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(line1[<span class="number">0</span>]!=line2[<span class="number">0</span>]) <span class="keyword">return</span> line1[<span class="number">0</span>]-line2[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> line2[<span class="number">1</span>]*line2[<span class="number">2</span>]-line1[<span class="number">1</span>]*line1[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 优先队列记录此前最大高度</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeight=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((int1,int2)-&gt;int2-int1);</span><br><span class="line">        maxHeight.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 记录上一个输出的高度</span></span><br><span class="line">        <span class="type">int</span> lastHeight=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []line:lines)&#123;</span><br><span class="line">            <span class="type">int</span> x=line[<span class="number">0</span>],height=line[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 是右边界，则该高度的矩形结束一个，其对应的高度出队列</span></span><br><span class="line">            <span class="keyword">if</span>(line[<span class="number">2</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                maxHeight.remove(height);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 是左边界，其对应的高度入队列</span></span><br><span class="line">                maxHeight.offer(height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前队列中的最大值（结果高度）</span></span><br><span class="line">            <span class="type">int</span> curMaxHeight=maxHeight.peek();</span><br><span class="line">            <span class="comment">// 结果高度与上一次输出的高度不一致，输出</span></span><br><span class="line">            <span class="keyword">if</span>(curMaxHeight!=lastHeight)&#123;</span><br><span class="line">                List&lt;Integer&gt; tempList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                tempList.add(x);</span><br><span class="line">                tempList.add(curMaxHeight);</span><br><span class="line">                res.add(tempList);</span><br><span class="line">                <span class="comment">// 记录下高度</span></span><br><span class="line">                lastHeight=curMaxHeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://leetcode-cn.com/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/">【宫水三叶】扫描线算法基本思路 &amp; 优先队列维护当前最大高度</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。&lt;/p</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="hard" scheme="https://yi-jiao-chan.github.io/tags/hard/"/>
    
    <category term="扫描线" scheme="https://yi-jiao-chan.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-391. 完美矩形</title>
    <link href="https://yi-jiao-chan.github.io/posts/bb46c52a.html"/>
    <id>https://yi-jiao-chan.github.io/posts/bb46c52a.html</id>
    <published>2022-02-20T15:02:00.000Z</published>
    <updated>2022-02-21T03:29:17.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/perfect-rectangle">https://leetcode-cn.com/problems/perfect-rectangle</a></p><p>给你一个数组 rectangles ，其中 rectangles[i] &#x3D; [xi, yi, ai, bi] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (xi, yi) ，右上顶点是 (ai, bi) 。</p><p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。</p><blockquote><ul><li><code>1 &lt;= rectangles.length &lt;= 2 * 104</code></li><li><code>rectangles[i].length == 4</code></li><li><code>-105 &lt;= xi, yi, ai, bi &lt;= 105</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220230348305.png" alt="image-20220220230348305"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：5 个矩形一起可以精确地覆盖一个矩形区域。 </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220230620076.png" alt="image-20220220230620076"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：两个矩形之间有间隔，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220230647964.png" alt="image-20220220230647964"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>把每一个矩形，看作是两条x坐标不一样，y的始末坐标完全一致的竖直线组成，分别是左边线和右边线，因此引入一个标志来标识这是矩形是左边线还是右边线。因此通过<code>&#123;x,yLow,yHigh,left/right&#125;</code>记录下每一个矩形。</p><p>对于一个完美矩形来说：</p><ul><li><p>非边界线：非边界线在完美矩形的内部，因此必定是多个小矩形的拼接处，那么对于每一条线，都有一条与其位置完全一样，但是属于不同小矩形的不同方向的线。即<code>x,yLow,yHigh</code>相等，<code>left/right</code>相反。</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220231633077.png" alt="image-20220220231633077"></p></li><li><p>边界线（最左和最右的线）：在同一个x坐标下，只有一条连续的线</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220220231847774.png" alt="image-20220220231847774"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRectangleCover</span><span class="params">(<span class="type">int</span>[][] rectangles)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=rectangles.length;</span><br><span class="line">        <span class="comment">// 一个矩形可以转换成两条竖直边，每条边记录为&#123;x轴坐标，下方y轴坐标，上方y轴坐标，矩形左边还是右边（1/-1）&#125;</span></span><br><span class="line">        <span class="type">int</span> [][]lines=<span class="keyword">new</span> <span class="title class_">int</span>[n*<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把矩形转换成边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> []points:rectangles)&#123;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">3</span>],<span class="number">1</span>&#125;;</span><br><span class="line">            lines[index++]=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;points[<span class="number">2</span>],points[<span class="number">1</span>],points[<span class="number">3</span>],-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据x坐标升序排序，x坐标相同，则按照下方y轴坐标升序排序</span></span><br><span class="line">        Arrays.sort(lines,(line1,line2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(line1[<span class="number">0</span>]!=line2[<span class="number">0</span>]) <span class="keyword">return</span> line1[<span class="number">0</span>]-line2[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> line1[<span class="number">1</span>]-line2[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 分别记录左右边，只记录同一x下的，只记录y坐标 &#123;下方y轴坐标，上方y轴坐标&#125;</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; leftList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; rightList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 每次取出x坐标相同的所有边，根据其属于矩形的左边还是右边进行分类（扫描边）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;)&#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            leftList.clear();</span><br><span class="line">            rightList.clear();</span><br><span class="line">            <span class="comment">// 找出横坐标相同的边的范围,因为j初始等于i，所以至少执行一次，j&gt;i恒成立</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;<span class="number">2</span>*n&amp;&amp;lines[i][<span class="number">0</span>]==lines[j][<span class="number">0</span>]) j++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                <span class="type">int</span> []line=lines[k];</span><br><span class="line">                List&lt;<span class="type">int</span>[]&gt; tempList=line[<span class="number">3</span>]==<span class="number">1</span>?leftList:rightList;</span><br><span class="line">                <span class="comment">// 把当前遍历到的边，加入到list中</span></span><br><span class="line">                <span class="keyword">if</span>(tempList.isEmpty()) tempList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;line[<span class="number">1</span>],line[<span class="number">2</span>]&#125;);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 取出该list中，最靠近上方的边</span></span><br><span class="line">                    <span class="type">int</span> []pre=tempList.get(tempList.size()-<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 上一条边最高位置高于当前边最低位置，重叠（对于同一方向的边，有重叠则证明矩形重叠），返回false</span></span><br><span class="line">                    <span class="comment">//      （由于lines以根据边的最低位置升序排序，所以不需要判断当前边的最高位置是否大于上一条边的最低位置）</span></span><br><span class="line">                    <span class="keyword">if</span>(pre[<span class="number">1</span>]&gt;line[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 上一条边最高位置等于当前边最低位置，两条边紧邻，合并</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(pre[<span class="number">1</span>]==line[<span class="number">1</span>]) pre[<span class="number">1</span>]=line[<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span> tempList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;line[<span class="number">1</span>],line[<span class="number">2</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不是边缘，则判断是否每一条边都重合（left和right每条边始末都相等）</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j&lt;<span class="number">2</span>*n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(leftList.size()!=rightList.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;leftList.size();k++)&#123;</span><br><span class="line">                    <span class="type">int</span> []left=leftList.get(k);</span><br><span class="line">                    <span class="type">int</span> []right=rightList.get(k);</span><br><span class="line">                    <span class="keyword">if</span>(left[<span class="number">0</span>]!=right[<span class="number">0</span>]||left[<span class="number">1</span>]!=right[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 是边缘,判断是否连续且没有重叠</span></span><br><span class="line">                <span class="keyword">if</span>(leftList.size()+rightList.size()!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j肯定比i大，用来替代i++</span></span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://leetcode-cn.com/problems/perfect-rectangle/solution/gong-shui-san-xie-chang-gui-sao-miao-xia-p4q4/">【宫水三叶】常规扫描线题目</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/perfect-rectangle&quot;&gt;https://l</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="hard" scheme="https://yi-jiao-chan.github.io/tags/hard/"/>
    
    <category term="扫描线" scheme="https://yi-jiao-chan.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记-Spring框架</title>
    <link href="https://yi-jiao-chan.github.io/posts/690c4485.html"/>
    <id>https://yi-jiao-chan.github.io/posts/690c4485.html</id>
    <published>2022-02-17T02:38:00.000Z</published>
    <updated>2022-02-21T01:20:00.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解名称一、什么是Spring"><a href="#注解名称一、什么是Spring" class="headerlink" title="注解名称一、什么是Spring"></a><strong>注解名称</strong>一、什么是Spring</h1><p>Spring是一个轻量级的控制反转(IOC)和面向切面变成(AOP)的框架，可以用来整合其他框架</p><p>优点</p><ul><li>Spring是一个轻量级的，非入侵式的框架</li><li>Spring支持控制反转（IOC）和面向切面编程（AOP）</li><li>Spring支持事务管理，对框架的整合</li></ul><h1 id="二、Spring框架七大模块"><a href="#二、Spring框架七大模块" class="headerlink" title="二、Spring框架七大模块"></a>二、Spring框架七大模块</h1><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215105840732.png" alt="image-20220215105840732"></p><ol><li>Core：<strong>核心容器</strong>。这是Spring框架最基础的部分，它提供了依赖注入（Dependency Injection）特征来实现容器对Bean的管理。这里最基本的概念是BeanFactory，它是任何Spring应用的核心。BeanFactory是工厂模式的一个实现，它使用IOC将应用配置和依赖说明从实际的应用代码中分离出来。</li><li>Context：<strong>应用上下文</strong>。核心模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。该模块还提供了一些面向服务支持这个模块扩展了BeanFactory的概念，增加了对国际化（I18N）消息、事件传播以及验证的支持。另外，这个模块还提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括对模版框架例如Velocity和FreeMarker集成的支持。</li><li>AOP：<strong>面向切面编程</strong>。Spring在它的AOP模块中提供了对面向切面编程的丰富支持。AOP允许通过分离应用的业务逻辑与系统级服务（例如安全和事务管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。<strong>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务</strong>。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li><li>ORM：<strong>对象&#x2F;关系映射集成模块</strong>。Spring 框架集成了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li>DAO：<strong>Spring DAO模块</strong>。Spring虽然集成了几个ORM产品，但也可以不选择这几款产品，因为Spring提供了JDBC和DAO模块。该模块对现有的JDBC技术进行了优化。你可以保持你的数据库访问代码干净简洁，并且可以防止因关闭数据库资源失败而引起的问题。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li>Web：<strong>Web上下文模块</strong>。建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。它也提供了Spring和其它Web框架的集成，比如Struts、WebWork。</li><li>Web MVC：<strong>Spring的MVC框架</strong>Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts2，但Spring的MVC框架使用IOC对控制逻辑和业务对象提供了完全的分离，容纳了大量视图技术，如JSP。</li></ol><h1 id="三、IOC（控制反转）"><a href="#三、IOC（控制反转）" class="headerlink" title="三、IOC（控制反转）"></a>三、IOC（控制反转）</h1><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215114132804.png" alt="image-20220215114132804"></p><p>IOC就是<strong>对象的的创建移交给第三方</strong>，即在一个类当中不直接实例化另一个类的对象（例如：在service层中不直接new dao层对象，而是创建一个dao层接口的变量，通过这个接口变量调用dao层的各种方法实现业务逻辑。真正的dao层实例对象，是在程序运行过程中由容器提供并赋给接口变量的）。依赖注入（DI）是实 现IOC的一种方法。</p><h1 id="四、Spring使用IOC创建对象–依赖注入"><a href="#四、Spring使用IOC创建对象–依赖注入" class="headerlink" title="四、Spring使用IOC创建对象–依赖注入"></a>四、Spring使用IOC创建对象–依赖注入</h1><ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象的所有属性由容器注入</li></ul><h2 id="1、set方法注入"><a href="#1、set方法注入" class="headerlink" title="1、set方法注入"></a>1、set方法注入</h2><h3 id="1-1-复杂类型"><a href="#1-1-复杂类型" class="headerlink" title="1.1 复杂类型"></a>1.1 复杂类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-bean测试对象"><a href="#1-2-bean测试对象" class="headerlink" title="1.2 bean测试对象"></a>1.2 bean测试对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="comment">/*省略get set方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-applicationContext-xml"><a href="#1-3-applicationContext-xml" class="headerlink" title="1.3 applicationContext.xml"></a>1.3 applicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;广东省佛山市南海区华南师范大学南海校区&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--普通值注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--bean注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--Array注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>深入理解Java虚拟机<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Effective Java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>unix环境高级编程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--list注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打游戏<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打代码<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--map注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;440000000011112039&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;校园卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;201833330000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;银行卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2341212342134123423&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--set注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>NBA2K<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>地平线4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--null注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--properties注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;url&quot;</span>&gt;</span>www.lemonchan.top<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>Lemon Chan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;telephone&quot;</span>&gt;</span>13131313131<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-测试类"><a href="#1-4-测试类" class="headerlink" title="1.4 测试类"></a>1.4 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    System.out.println(context.getBean(<span class="string">&quot;student&quot;</span>));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Student&#123;</span></span><br><span class="line"><span class="comment">    *   name=&#x27;张三&#x27;,</span></span><br><span class="line"><span class="comment">    *   address=Address&#123;address=&#x27;广东省佛山市南海区华南师范大学南海校区&#x27;&#125;, </span></span><br><span class="line"><span class="comment">    *   books=[深入理解Java虚拟机, Effective Java, unix环境高级编程], </span></span><br><span class="line"><span class="comment">    *   hobbies=[打游戏, 看书, 打代码], </span></span><br><span class="line"><span class="comment">    *   card=&#123;</span></span><br><span class="line"><span class="comment">    *       身份证=440000000011112039, </span></span><br><span class="line"><span class="comment">    *       校园卡=201833330000, </span></span><br><span class="line"><span class="comment">    *       银行卡=2341212342134123423</span></span><br><span class="line"><span class="comment">    *   &#125;, </span></span><br><span class="line"><span class="comment">    *   games=[NBA2K, 地平线4], wife=&#x27;null&#x27;, </span></span><br><span class="line"><span class="comment">    *   info=&#123;telephone=13131313131, </span></span><br><span class="line"><span class="comment">    *       url=www.lemonchan.top, </span></span><br><span class="line"><span class="comment">    *       username=Lemon Chan</span></span><br><span class="line"><span class="comment">    *   &#125;</span></span><br><span class="line"><span class="comment">    * &#125;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、构造器注入"><a href="#2、构造器注入" class="headerlink" title="2、构造器注入"></a>2、构造器注入</h2><h3 id="2-1、无参构造方法创建"><a href="#2-1、无参构造方法创建" class="headerlink" title="2.1、无参构造方法创建"></a>2.1、无参构造方法创建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2、构造方法参数下标构造"><a href="#2-2、构造方法参数下标构造" class="headerlink" title="2.2、构造方法参数下标构造"></a>2.2、构造方法参数下标构造</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3、参数类型构造（不建议使用）"><a href="#2-3、参数类型构造（不建议使用）" class="headerlink" title="2.3、参数类型构造（不建议使用）"></a>2.3、参数类型构造（不建议使用）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4、参数名构造"><a href="#2-4、参数名构造" class="headerlink" title="2.4、参数名构造"></a>2.4、参数名构造</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bb&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件加载时，Spring容器就会实例化bean，而默认情况下通过ApplicationContext获取到的同一id的bean对象，都是同一个对象（即一个id对应一个bean对象）。</p><h2 id="3、拓展方式注入"><a href="#3、拓展方式注入" class="headerlink" title="3、拓展方式注入"></a>3、拓展方式注入</h2><ul><li>两种拓展注入方式只能注入普通值和bean对象</li></ul><h3 id="3-1、p命名空间"><a href="#3-1、p命名空间" class="headerlink" title="3.1、p命名空间"></a>3.1、p命名空间</h3><ul><li><code>p:key=&quot;value&quot;</code>实现了了<code>&lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt;</code>的功能</li><li><code>p:key-ref=&quot;value&quot;</code>实现了了<code>&lt;property name=&quot;key&quot; ref=&quot;value&quot;/&gt;</code>的功能</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--beans标签需要加上的属性--&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Address&quot;</span> <span class="attr">p:address</span>=<span class="string">&quot;广东省佛山市南海区华南师范大学南海校区&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">p:address-ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2、c命名空间"><a href="#3-2、c命名空间" class="headerlink" title="3.2、c命名空间"></a>3.2、c命名空间</h3><ul><li><code>c:key=&quot;value&quot;</code>实现了了<code>&lt;constructor-arg name=&quot;key&quot; value=&quot;value&quot;/&gt;</code>的功能</li><li><code>c:key-ref=&quot;value&quot;</code>实现了了<code>&lt;constructor-arg name=&quot;key&quot; ref=&quot;value&quot;/&gt;</code>的功能</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--beans标签需要加上的属性--&gt;</span></span><br><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">c:aa</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">c:bb-ref</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">c:_0</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">c:_1-ref</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="五、Spring常用配置"><a href="#五、Spring常用配置" class="headerlink" title="五、Spring常用配置"></a>五、Spring常用配置</h1><h2 id="1、bean"><a href="#1、bean" class="headerlink" title="1、bean"></a>1、bean</h2><ul><li>id：bean的唯一标识符</li><li>class：bean对象对应的全限类名</li><li>name：与alias类似，给bean对象取别名，而且<strong>可以同时有多个别名</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2 hello3&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、alias"><a href="#2、alias" class="headerlink" title="2、alias"></a>2、alias</h2><p>配置了alias后，可以通过alias获取bean对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;aliasHello&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name：bean的id</li><li>alias：bean的别名</li></ul><h2 id="3、import"><a href="#3、import" class="headerlink" title="3、import"></a>3、import</h2><p>将多个配置文件导入合并到当前xml文件中。多用于团队开发</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;helloWord&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="六、bean的作用域"><a href="#六、bean的作用域" class="headerlink" title="六、bean的作用域"></a>六、bean的作用域</h1><h2 id="1、singleton–单例模式"><a href="#1、singleton–单例模式" class="headerlink" title="1、singleton–单例模式"></a>1、singleton–单例模式</h2><p>Spring的bean对象作用域默认是singleton。每次从容器中getBean() 都是同一个对象</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215235010967.png" alt="image-20220215235010967"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pojo.Hello&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、prototype"><a href="#2、prototype" class="headerlink" title="2、prototype"></a>2、prototype</h2><p>每次从容器中getBean() 都是不同对象</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215235316311.png" alt="image-20220215235316311"></p><h2 id="3、request、session、application、websocket用于web开发中"><a href="#3、request、session、application、websocket用于web开发中" class="headerlink" title="3、request、session、application、websocket用于web开发中"></a>3、request、session、application、websocket用于web开发中</h2><h1 id="七、Bean的自动装配"><a href="#七、Bean的自动装配" class="headerlink" title="七、Bean的自动装配"></a>七、Bean的自动装配</h1><h2 id="1、byName自动装配"><a href="#1、byName自动装配" class="headerlink" title="1、byName自动装配"></a>1、byName自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--会在容器上下文中查找，找到与自己对象的set方法后面的变量名对应的beanId进行自动装配</span></span><br><span class="line"><span class="comment">例如：Person类有一个setDog方法，则会找到beanId未dog的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">要求容器上下文中所有bean的id唯一，且id要与set方法后面的变量名一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;张三&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、byType自动装配"><a href="#2、byType自动装配" class="headerlink" title="2、byType自动装配"></a>2、byType自动装配</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--会在容器上下文中查找，找到与自己对象属性的类型对应的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">例如：Person对象有一个Dog类型的属性，则会找到class=“Dog”的bean对象进行自动装配</span></span><br><span class="line"><span class="comment">要求容器上下文中只有一个该类型的bean对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;张三&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、注解实现自动装配"><a href="#3、注解实现自动装配" class="headerlink" title="3、注解实现自动装配"></a>3、注解实现自动装配</h2><p>准备工作</p><ol><li>导入约束：xmlns:context</li><li>配置注解支持标签：<code>&lt;context:annotation-config/&gt;</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@Autowired</strong><br>直接在属性上使用即可，不需要set方法。也可以在set方法上使用<br>使用Autowired的前提是这个自动装配的属性在IOC容器中存在，**@Autowired先使用byType方式注入，如果存在多个相同类型bean，则根据id注入**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required= false )</span> <span class="comment">// 说明这个对象可以为null，即找不到bean注入也报错</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value= &quot;dog222&quot;)</span><span class="comment">// 使用@Qualifier注解配合使用，指定beanId进行注入（Type和Name都满足才能注入）</span></span><br><span class="line"><span class="keyword">private</span> Dog dog; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用byName，找不到则使用byType，可以通过参数指定type和name</span></span><br><span class="line"><span class="meta">@Resource(type = Cat.class,name = &quot;cat123&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><h1 id="八、使用注解开发"><a href="#八、使用注解开发" class="headerlink" title="八、使用注解开发"></a>八、使用注解开发</h1><ul><li>使用注解开发前，需要导入Spring-AOP包</li><li>开启注解包扫描，指定要扫描的包<code>&lt;context:component-scan base-package=&quot;com.lemon.pojo&quot;/&gt;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span> <span class="comment">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot; scope=&quot;singleton&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span><span class="comment">//等价于&lt;property name=&quot;name&quot; value=&quot;lemon&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Component的衍生注解：功能与@Component一致，都是将某个类装装配成bean。</p><ul><li>@Component–用于pojo</li><li>@Reposity–用于dao层</li><li>@Service–用于service层</li><li>@Controller–用于controller层</li></ul><p>总结：</p><ul><li>xml更加万能，适用于各种场合，维护简单</li><li>注解更加方便，不是自己的类使用不了，维护更复杂</li><li>常用实践：<ul><li>使用xml管理bean</li><li>使用注解完成属性注入（@Value）</li></ul></li></ul><h1 id="九、AppConfig"><a href="#九、AppConfig" class="headerlink" title="九、AppConfig"></a>九、AppConfig</h1><p>完全使用Java配置Spring（无xml），实质上是用Java类来替代xml文件。配置类需要用@Configuration声明。</p><p>xml配置后用<code>ClassPathXmlApplicationContext(&quot;path&quot;)</code>获取IOC容器，**@Configuration声明的配置类用<code>AnnotationConfigApplicationContext(Class&lt;?&gt;)</code>获取IOC容器**。</p><p>使用@Import(Class&lt;?&gt; [])注解来引入其他的配置类</p><p>使用@ImportResource(String [])注解来引入xml配置文件</p><p><strong>使用@Configuration声明配置类时有两种方法生成（注册）Bean</strong></p><ol><li><p>在配置类中定义一个方法，使用@Bean注解。方法返回值对应class，方法名对应beanId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">// 等价于&lt;bean id=&quot;user&quot; class=&quot;com.lemon.pojo.User&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在需要注册的类上使用@Component注解，在配置类上使用@ComponentScan(“包”)开启包扫描（也可以用@ComponentScans(value&#x3D;”@ComponentScan数组”) 开启多个包扫描）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//等价于&lt;context:component-scan base-package=&quot;com.lemon.pojo&quot;/&gt;</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lemon.pojo&quot;)</span></span><br><span class="line"><span class="comment">//与上面等价 @ComponentScans(value=&#123;@ComponentScan(&quot;com.lemon.pojo&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;lemon&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果上述两种方法都使用，会创建两个Bean对象</p></li></ol><h1 id="十、代理模式"><a href="#十、代理模式" class="headerlink" title="十、代理模式"></a>十、代理模式</h1><p>代理模式即在不修改原有代码的基础上对原有功能进行增强。符合开闭原则。</p><h2 id="1、静态代理"><a href="#1、静态代理" class="headerlink" title="1、静态代理"></a>1、静态代理</h2><p>角色分析：</p><ul><li>抽象角色：一般使用接口或抽象类来解决，真实角色与代理角色都继承（实现）抽象角色。</li><li>真实角色：<strong>被代理</strong>的角色</li><li>代理角色：<strong>代理</strong>真实角色的角色，代理真实角色后，一般会做一些附属操作（比如权限检验）</li><li>客户：<strong>访问</strong>代理角色的角色</li></ul><p>优点：</p><ul><li>使真实角色的操作更加纯粹，不用去关注一些公共业务。（比如权限检验）</li><li>公共业务交给了代理角色，解耦。</li><li>公共业务发生拓展的时候，方便集中管理。（比如增加一个权限角色）</li></ul><p>缺点：</p><ul><li>一个真实角色就会产生一个代理角色，代码量翻倍，开发效率变低</li></ul><h2 id="2、动态代理"><a href="#2、动态代理" class="headerlink" title="2、动态代理"></a>2、动态代理</h2><ul><li>动态代理的角色与静态代理一致</li><li>动态代理的代理类是动态生成的，不是直接写好的</li><li>动态代理实现方法主要分为三类：<ul><li>基于接口的动态代理：JDK动态代理</li><li>基于类的动态代理：cglib</li><li>基于Java字节码：Javassist</li></ul></li></ul><h3 id="2-1、JDK的动态代理实现"><a href="#2-1、JDK的动态代理实现" class="headerlink" title="2.1、JDK的动态代理实现"></a>2.1、JDK的动态代理实现</h3><h4 id="2-1-1、Proxy类"><a href="#2-1-1、Proxy类" class="headerlink" title="2.1.1、Proxy类"></a>2.1.1、Proxy类</h4><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220216160801622.png" alt="image-20220216160801622"></p><p>用静态方法来获取代理类</p><h4 id="2-1-2、InvocationHandler接口"><a href="#2-1-2、InvocationHandler接口" class="headerlink" title="2.1.2、InvocationHandler接口"></a>2.1.2、InvocationHandler接口</h4><p>实现该接口的类称为处理机类，必须实现invoke方法。</p><p>使用该<code>处理机类的实例对象ih</code>生成<code>代理对象A</code>，A调用的任何方法，实质上都是通过反射获取到Method对象，然后交由给ih的invoke方法执行。</p><p>生成代理对象的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * classLoader:真实对象的类加载器</span></span><br><span class="line"><span class="comment"> * interfaces:需要代理的接口（真实对象中只有这些接口对应的方法才会被代理，生成的代理对象中只有这些接口对应的方法）</span></span><br><span class="line"><span class="comment"> * invocationHandler: 处理机对象，实现代理增加功能的关键！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Proxy.newProxyInstance(classLoader,<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]interfaces,invocationHandler);</span><br></pre></td></tr></table></figure><p><strong>特别注意</strong>：生成的代理对象<code>A</code>是接口对象，只有<code>interfaces</code>接口对应的方法</p><h4 id="2-1-3、demo"><a href="#2-1-3、demo" class="headerlink" title="2.1.3、demo"></a>2.1.3、demo</h4><ol><li><p>自定义InvocationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个处理机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">getUserService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceInvocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceInvocationHandler</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        check();</span><br><span class="line">        Object res=method.invoke(userService,args);</span><br><span class="line">        log(method.getName());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行权限检验&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;日志：执行了&quot;</span>+msg+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String arg)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insert业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;update业务,参数为：&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;select业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>client应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//        真实对象</span></span><br><span class="line">        UserServiceImpl userService=<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="comment">//        调用处理器，实现invoke方法，通过该调用处理器生成的代理对象，其调用方法都会使用这个invoke方法进行调用</span></span><br><span class="line">        UserServiceInvocationHandler invocationHandler=<span class="keyword">new</span> <span class="title class_">UserServiceInvocationHandler</span>(userService);</span><br><span class="line"><span class="comment">//        通过Proxy的静态方法，使用invocationHandler生成动态代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取代理对象</span></span><br><span class="line"><span class="comment">         * 真实对象的类加载器、代理对象代理的接口、处理机对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        UserService userService2= (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;UserService.class&#125;,invocationHandler);</span><br><span class="line"><span class="comment">//        通过代理对象调用方法</span></span><br><span class="line">        userService2.update(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* userService2.update(&quot;123&quot;); 等价于下面两行代码*/</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> invocationHandler.getUserService().getClass().getDeclaredMethod(<span class="string">&quot;update&quot;</span>, <span class="string">&quot;123&quot;</span>.getClass());</span><br><span class="line">        invocationHandler.invoke(userService2,method,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;123&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*newMethod()方法不是接口方法，因此userService2中没有该方法！*/</span></span><br><span class="line">        userService.newMethod();</span><br><span class="line"><span class="comment">//        userService2.newMethod(); //不存在该方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>项目结构</p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220221091953436.png" alt="image-20220221091953436"></p></li></ol><h3 id="2-2、动态代理的好处"><a href="#2-2、动态代理的好处" class="headerlink" title="2.2、动态代理的好处"></a>2.2、动态代理的好处</h3><ul><li>使真实角色的操作更加纯粹，不用去关注一些公共业务。（比如权限检验）</li><li>公共业务交给了代理角色，解耦。</li><li>公共业务发生拓展的时候，方便集中管理。（比如增加一个权限角色）</li><li>一个动态代理类代理的是一个&#x2F;多个接口，一般就是对应一类业务。</li><li>一个动态代理类可以代理多个类，只要是实现了同一接口</li></ul><h1 id="十一、AOP"><a href="#十一、AOP" class="headerlink" title="十一、AOP"></a>十一、AOP</h1><h2 id="1、什么是AOP"><a href="#1、什么是AOP" class="headerlink" title="1、什么是AOP"></a>1、什么是AOP</h2><p> AOP即面向切面编程（Aspect Oriented Program） 。使用面向对象编程，降低了代码的复杂程度，使类可重用，但也增加了代码的重复性。例如：每个类都需要做日志，那按面向对象的设计方法，需要在两个类的方法中都加入日志的内容。也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<strong>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong></p><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220216225246039.png" alt="image-20220216224738230"></p><h2 id="2、AOP在Spring中的作用"><a href="#2、AOP在Spring中的作用" class="headerlink" title="2、AOP在Spring中的作用"></a>2、AOP在Spring中的作用</h2><p><strong>提供声明式事务；允许用户自定义切面</strong></p><ul><li>横切关注点：影响应用多处的功能（日志、权限检验等）</li><li>通知（Adivce）：切面要完成的工作</li><li>连接点（JoinPoint）：应用程序执行过程中能插入切面的点（方法执行时，抛出错误时、方法返回时）</li><li>切点（PointCut）：定义通知被应用的位置（哪些方法需要织入切面）</li><li>切面（ASPECT）：通知和切点的集合</li><li>引入（Intorduction）：允许在现有的实现类中添加自定义的方法和属性。</li><li>目标（Target）：被通知的对象（动态代理中的真实对象）</li><li>代理（Proxy）：想目标对象应用通知后创建的对象（动态代理中的代理对象）</li><li>织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。Spring AOP框架默认采用动态代理织入，而AspectJ（基于Java语言的AOP框架）采用编译器织入和类装载期织入。</li></ul><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220216224738230.png" alt="image-20220216225246039"></p><p>SpringAOP中，通过Advice定义不同连接点的通知</p><table><thead><tr><th>通知类型</th><th>连接点</th><th>实现接口(org.springframework.aop.*)</th></tr></thead><tbody><tr><td>前置通知</td><td>方法前</td><td>MethonBeforeAdvice</td></tr><tr><td>后置通知</td><td>方法后</td><td>AfterReturningAdvice</td></tr><tr><td>环绕通知</td><td>方法前后</td><td>MethodInterceptor</td></tr><tr><td>异常抛出通知</td><td>方法抛出异常</td><td>ThrowAdvice</td></tr><tr><td>引介通知</td><td>类中增加新的方法属性</td><td>IntroductionInterceptor</td></tr></tbody></table><h2 id="3、使用Spring实现AOP"><a href="#3、使用Spring实现AOP" class="headerlink" title="3、使用Spring实现AOP"></a>3、使用Spring实现AOP</h2><h3 id="3-1、使用Spring的API接口"><a href="#3-1、使用Spring的API接口" class="headerlink" title="3.1、使用Spring的API接口"></a>3.1、使用Spring的API接口</h3><ol><li><p>自定义一个类，实现<code>AfterReturningAdive</code>接口（可以实现多个接口），即定义了一个<strong>连接点</strong>为方法返回时的<strong>通知</strong>，<code>afterReturning()</code>方法是通知的具体内容。并通过<code>@Component</code>注解将该切面注册到Spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterLog</span> <span class="keyword">implements</span> <span class="title class_">AfterReturningAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+method.getName()+<span class="string">&quot;方法，返回结果为&quot;</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml配置文件中配置AOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AOP，需要导入命名空间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点：在些方法执行 expression=&quot;execution(要执行的位置 方法修饰词 包名.类名 方法名 方法参数)&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行环绕增加</span></span><br><span class="line"><span class="comment">_ advice-ref:Spring容器中的切面beanID  pointcut-ref：已配置的切入点</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2、自定义类实现AOP"><a href="#3-2、自定义类实现AOP" class="headerlink" title="3.2、自定义类实现AOP"></a>3.2、自定义类实现AOP</h3><ol><li><p>自定义一个切面类，无需实现任何接口。在类中定义若干个方法作为<strong>通知</strong>。并通过<code>@Component</code>注解将该切面注册到Spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;diy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyPointCut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========方法执行前========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========方法执行后========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在xml配置文件中配置AOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--把beanID为diy的bean对象作为切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--切入点：在哪些方法执行  expression=&quot;execution(要执行的位置  方法修饰词 包名.类名.方法名(方法参数))&quot;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义连接点，before、after、...   method=该连接点用哪个通知（切面类中的方法） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>两种方法异同：</strong></p><ul><li>方法一在切面类中就已经规定好连接点，特定的方法名对应不同连接点。</li><li>方法二在xml配置文件中定义连接点，方法名与连接点之间无关。</li></ul><h3 id="3-3、注解实现"><a href="#3-3、注解实现" class="headerlink" title="3.3、注解实现"></a>3.3、注解实现</h3><ol><li><p>自定义一个切面类，不实现任何的接口。用<code>@Aspect</code>标记这是一个切面类。然后使用<code>@Component</code>将该切面类注册到Spring容器中。在类中定义若干个方法作为<strong>通知</strong>，并使用<code>@Before、@Around</code>等标记方法进行连接点和切点的定义。</p><p><strong>注意</strong>：一个方法只能有一个连接点-切入点注解生效，生效的是连接点最前的注解。例如在同一个方法同时使用了<code>@After @Before</code>，则生效的是<code>Before</code>，因为<code>@Before</code>是切点（方法执行）前执行，而<code>@After</code>是切点（方法执行）后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 把这个自定义切面注册到Spring容器中</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationPointCut</span> &#123;</span><br><span class="line">    <span class="comment">//  同时配置连接点（Before、After、...） 和切入点（execution()）</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======方法执行前=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.lemon.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  使用已定义的切点进行配置</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut1()&quot;)</span></span><br><span class="line">    <span class="comment">//  在环绕增强中，我们可以给定一个ProceedingJoinPoint参数，用来获取被 应用通知 的点（如：方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed(); <span class="comment">//        执行方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml配置文件中开启aop注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!--开启AOP注解  </span></span><br><span class="line"><span class="comment">--proxy-target-class=&quot;false&quot;  采用JDK方式实现动态代理/AOP  </span></span><br><span class="line"><span class="comment">--proxy-target-class=&quot;true&quot;   采用cglib的方式实现动态代理/AOP--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>常用AOP注解</p><table><thead><tr><th><strong>注解名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>@Aspect</td><td>用于定义一个切面，注解在切面类上</td></tr><tr><td>@Pointcut</td><td>用于定义切入点表达式。在使用时，需要定义一个切入点方法。该方法是一个返回值void，且方法体为空的普通方法，方法名()即切点名</td></tr><tr><td>@Before</td><td>用于定义前置通知。在使用时，通常为其指value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@AfterReturning</td><td>用于定义后置返回通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@Around</td><td>用于定义环绕通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr><tr><td>@AfterThrowing</td><td>用于定义异常通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式。另外，还有一个throwing属性用于访问目标方法抛出的异常，该属性值与异常通知方法中同名的形参一致</td></tr><tr><td>@Aftter</td><td>用于定义后置（最终）通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式</td></tr></tbody></table></li></ol><h1 id="十二、整合MyBatis"><a href="#十二、整合MyBatis" class="headerlink" title="十二、整合MyBatis"></a>十二、整合MyBatis</h1><blockquote><p>待补充</p></blockquote><h1 id="十三、声明式事务"><a href="#十三、声明式事务" class="headerlink" title="十三、声明式事务"></a>十三、声明式事务</h1><blockquote><p>待补充</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1WE411d7Dv">【狂神说Java】Spring5最新完整教程IDEA版通俗易懂</a></p><p><a href="https://blog.csdn.net/qq_33082731/article/details/75066956">Spring的七大模块，以及每个模块的作用</a></p><p><a href="https://zhuanlan.zhihu.com/p/40784174">Java编程—Spring框架七大模块</a></p><p><a href="https://baike.baidu.com/item/spring%E6%A1%86%E6%9E%B6/2853288?fr=aladdin">Spring框架-百度百科</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html">Spring官方文档</a></p><p><a href="https://www.iteye.com/blog/hejiajunsh-1776569">JavaWeb过滤器.监听器.拦截器-原理&amp;区别-个人总结</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注解名称一、什么是Spring&quot;&gt;&lt;a href=&quot;#注解名称一、什么是Spring&quot; class=&quot;headerlink&quot; title=&quot;注解名称一、什么是Spring&quot;&gt;&lt;/a&gt;&lt;strong&gt;注解名称&lt;/strong&gt;一、什么是Spring&lt;/h1&gt;&lt;p&gt;S</summary>
      
    
    
    
    <category term="Java" scheme="https://yi-jiao-chan.github.io/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://yi-jiao-chan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-200. 岛屿数量</title>
    <link href="https://yi-jiao-chan.github.io/posts/5ad2b77.html"/>
    <id>https://yi-jiao-chan.github.io/posts/5ad2b77.html</id>
    <published>2022-02-16T12:20:00.000Z</published>
    <updated>2022-02-16T13:49:34.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></p><p>给你一个由<code> &#39;1&#39;</code>（陆地）和<code> &#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><blockquote><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>两种思路：</p><ul><li>使用并查集把所有为<code>1</code>的节点连接起来，用<code>parent</code>数组记录，最后遍历<code>parent</code>数组查询有多少个<code>parent[i]=[i]</code></li><li>dfs&#x2F;bfs遍历所有<code>1</code>节点，把遍历到的节点修改成<code>0</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> []parent=<span class="keyword">new</span> <span class="title class_">int</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>) parent[i*grid[<span class="number">0</span>].length+j]=i*grid[<span class="number">0</span>].length+j;</span><br><span class="line">               <span class="keyword">else</span> parent[i*grid[<span class="number">0</span>].length+j]=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 上</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;grid[i-<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> now=getParent(parent,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="type">int</span> up=getParent(parent,(i-<span class="number">1</span>)*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="keyword">if</span>(now!=up)&#123;</span><br><span class="line">                        parent[now]=up;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>&amp;&amp;grid[i][j-<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> now=getParent(parent,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    <span class="type">int</span> left=getParent(parent,i*grid[<span class="number">0</span>].length+j-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(now!=left)&#123;</span><br><span class="line">                        parent[now]=left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;parent.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i]==i) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> []parent,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[index]!=index)&#123;</span><br><span class="line">            parent[index]=getParent(parent,parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs和dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[i].length;j++)&#123;</span><br><span class="line">                <span class="comment">/*bfs*/</span></span><br><span class="line">                <span class="comment">// if(grid[i][j]==&#x27;1&#x27;) bfs(grid,i,j);</span></span><br><span class="line">                <span class="comment">/*dfs*/</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span> [][]grid,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;=grid.length||col&lt;<span class="number">0</span>||col&gt;=grid[<span class="number">0</span>].length||grid[row][col]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> [] arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        grid[row][col]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            dfs(grid,row+arr[i-<span class="number">1</span>],col+arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="type">int</span> cols=grid[<span class="number">0</span>].length;</span><br><span class="line">        Deque&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(row*cols+col);</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> index=queue.poll();</span><br><span class="line">            row=index/cols;</span><br><span class="line">            col=index%cols;</span><br><span class="line">            <span class="keyword">if</span>(grid[row][col]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            grid[row][col]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line">            <span class="keyword">if</span>(row&gt;<span class="number">0</span>&amp;&amp;grid[row-<span class="number">1</span>][col]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index-cols);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span>(col&gt;<span class="number">0</span>&amp;&amp;grid[row][col-<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">if</span>(row&lt;grid.length-<span class="number">1</span>&amp;&amp;grid[row+<span class="number">1</span>][col]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index+cols);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(col&lt;cols-<span class="number">1</span>&amp;&amp;grid[row][col+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(index+<span class="number">1</span>);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands&quot;&gt;https://l</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="dfs" scheme="https://yi-jiao-chan.github.io/tags/dfs/"/>
    
    <category term="bfs" scheme="https://yi-jiao-chan.github.io/tags/bfs/"/>
    
    <category term="并查集" scheme="https://yi-jiao-chan.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-8. 字符串转换整数 (atoi)</title>
    <link href="https://yi-jiao-chan.github.io/posts/263d0e65.html"/>
    <id>https://yi-jiao-chan.github.io/posts/263d0e65.html</id>
    <published>2022-02-16T12:20:00.000Z</published>
    <updated>2022-02-16T13:49:34.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi">https://leetcode-cn.com/problems/string-to-integer-atoi</a></p><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li><li>返回整数作为最终结果。</li></ol><blockquote><ul><li><p>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</p></li><li><p>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</p></li><li><p><code>0 &lt;= s.length &lt;= 200</code></p></li><li><p><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</p></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>模拟题，多设计样例进行边界测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除前导空格</span></span><br><span class="line">        s=s.trim();</span><br><span class="line">        <span class="comment">// 转换成char数组遍历更快</span></span><br><span class="line">        <span class="type">char</span> []chars=s.toCharArray();</span><br><span class="line">        <span class="comment">// 去除前导空格后为空串，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(chars.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录正负</span></span><br><span class="line">        <span class="type">int</span> direction=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 判断第一位是否是正负号，如果是负号则修改direction</span></span><br><span class="line">        <span class="keyword">if</span>(chars[i]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chars[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            direction=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历计算连续值（前导0在计算过程中会自动去除）</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;chars.length)&#123;</span><br><span class="line">            <span class="comment">// 遇到非数字字节跳出遍历</span></span><br><span class="line">            <span class="keyword">if</span>(chars[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;chars[i]&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                res=res*<span class="number">10</span>+(<span class="type">int</span>)(chars[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超过int类型就跳出（根据正负号分别进行判断）</span></span><br><span class="line">            <span class="keyword">if</span>(direction==<span class="number">1</span>&amp;&amp;res&gt;=Integer.MAX_VALUE)&#123;</span><br><span class="line">                res=Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==-<span class="number">1</span>&amp;&amp;res&gt;Integer.MAX_VALUE)&#123;</span><br><span class="line">                res=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) res*direction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-integer-atoi&quot;&gt;http</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-215. 数组中的第K个最大元素.md</title>
    <link href="https://yi-jiao-chan.github.io/posts/b783d239.html"/>
    <id>https://yi-jiao-chan.github.io/posts/b783d239.html</id>
    <published>2022-02-15T13:08:00.000Z</published>
    <updated>2022-02-15T13:18:19.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><blockquote><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要找到第k大的元素，就要找到k-1个比他大的元素。可以用堆排序、快排变式来快速解题</p><ul><li>快排变式：降序快排，快排调用<code>partition()</code>方法得到分割点坐标<code>mid</code>后，跟<code>k</code>进行比较，如果等于<code>k-1</code>，则<code>nums[mid]</code>就是结果，如果<code>mid&gt;k-1</code>则对<code>[begin,mid-1]</code>进行快排，否则对<code>[mid+1,end]</code>进行快排。运用了剪枝思想，把不需要排序的部分剪掉。</li><li>堆排序：构建一个<code>大小为k</code>的小根堆，存放最大的<code>k</code>个元素，先把<code>nums[0]~nums[k-1]</code>放入堆中，然后从<code>nums[k]</code>开始遍历，如果遍历到的元素比堆顶大，则其替换掉堆顶，并重新整理堆。遍历完成以后，堆顶元素则是堆的<code>k</code>个元素中最小的一个，刚好是第<code>k</code>大的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写堆排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 存放堆的数组，左节点=父节点*2+1,右节点=父节点*2+2</span></span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">// 原数组前k个元素入堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            res[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建小根堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(k-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            heapSort(res,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历元素，入堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;res[<span class="number">0</span>])&#123;</span><br><span class="line">                res[<span class="number">0</span>]=nums[i];</span><br><span class="line">                heapSort(res,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> []arr,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">// 左节点不存在，则不需要调整当前节点位置</span></span><br><span class="line">        <span class="keyword">if</span>(index*<span class="number">2</span>+<span class="number">1</span>&gt;=arr.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右节点存在且右节点更小，则当前节点与右节点比较（left++后就是右节点下标）</span></span><br><span class="line">        <span class="keyword">if</span>(left+<span class="number">1</span>&lt;arr.length&amp;&amp;arr[left]&gt;arr[left+<span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&lt;arr[index])&#123;</span><br><span class="line">            <span class="comment">// 交换并对交换后的子节点堆化</span></span><br><span class="line">            <span class="type">int</span> temp=arr[left];</span><br><span class="line">            arr[left]=arr[index];</span><br><span class="line">            arr[index]=temp;</span><br><span class="line">            heapSort(arr,left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用优先队列完成堆排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; priorityQueue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            priorityQueue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;priorityQueue.peek())&#123;</span><br><span class="line">                priorityQueue.poll();</span><br><span class="line">                priorityQueue.offer(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priorityQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排+剪枝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findK(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findK</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> begin,<span class="type">int</span> end,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=partition(nums,begin,end);</span><br><span class="line">        <span class="keyword">if</span>(mid==k-<span class="number">1</span>) <span class="keyword">return</span> nums[mid];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;k) <span class="keyword">return</span> findK(nums,mid+<span class="number">1</span>,end,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> findK(nums,begin,mid-<span class="number">1</span>,k);     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> target=nums[begin];</span><br><span class="line">        <span class="type">int</span> i=begin+<span class="number">1</span>,j=end;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j&amp;&amp;nums[i]&gt;=target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j&amp;&amp;nums[j]&lt;target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;j) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,begin,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定整数数组 &lt;code&gt;nums&lt;/code&gt; 和整数 &lt;code&gt;k&lt;/code&gt;，请返回数组中第 &lt;code&gt;k&lt;/code&gt; 个最大</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="堆排序" scheme="https://yi-jiao-chan.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-剑指 Offer 34. 二叉树中和为某一值的路径</title>
    <link href="https://yi-jiao-chan.github.io/posts/c60dd476.html"/>
    <id>https://yi-jiao-chan.github.io/posts/c60dd476.html</id>
    <published>2022-02-14T12:40:00.000Z</published>
    <updated>2022-02-15T13:18:19.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a></p><p>给你二叉树的根节点 root 和一个整数目标和 <code>targetSum </code>，<strong>找出所有 从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220214204233529.png" alt="image-20220214204233529"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220214204305011.png" alt="image-20220214204305011"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dfs+回溯。前序遍历树，记录路径节点和，判断节点是否为叶子节点，如果是，则继续判断路径和是否&#x3D;target</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tempList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        dfs(root,<span class="number">0</span>,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> sum,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="comment">// 空节点返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        <span class="comment">// 修改路径</span></span><br><span class="line">        tempList.add(root.val);</span><br><span class="line">        <span class="comment">// 到达了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 存储到结果中，要新建一个List存放</span></span><br><span class="line">            <span class="keyword">if</span>(sum==target) res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(tempList));</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs</span></span><br><span class="line">        dfs(root.left,sum,target);</span><br><span class="line">        dfs(root.right,sum,target);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="树" scheme="https://yi-jiao-chan.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-881. 救生艇</title>
    <link href="https://yi-jiao-chan.github.io/posts/7c2a7986.html"/>
    <id>https://yi-jiao-chan.github.io/posts/7c2a7986.html</id>
    <published>2022-02-14T10:20:00.000Z</published>
    <updated>2022-02-14T10:36:31.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><a href="https://leetcode-cn.com/problems/boats-to-save-people">https://leetcode-cn.com/problems/boats-to-save-people</a></p><p>给定数组 <code>people </code>。<code>people[i]</code>表示第 <code>i </code>个人的体重 ，船的数量不限，每艘船可以承载的最大重量为<code> limit</code>。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。</p><p>返回 承载所有人所需的最小船数 。</p><blockquote><ul><li><code>1 &lt;= people.length &lt;= 5 * 104</code></li><li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 104</code></li></ul></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [1,2], limit = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：1 艘船载 (1, 2)</span><br><span class="line"></span><br><span class="line">输入：people = [3,2,2,1], limit = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：3 艘船分别载 (1, 2), (2) 和 (3)</span><br><span class="line"></span><br><span class="line">输入：people = [3,5,3,4], limit = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：4 艘船分别载 (3), (3), (4), (5)</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为<code>people[i]&lt;=limit</code>，该船最多只能坐两人，至少能坐一人，贪心思想，每次先把重量最大的人放上船，然后找重量最小的人，看能不能也放上船。</p><p>将<code>people</code>排序后，用两个指针分别指向当前重量最小和重量最大的人，双指针扫描。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>[] people, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="comment">// 本题limit较小，可以使用桶排序，时间复杂度降为O(n)</span></span><br><span class="line">        Arrays.sort(people);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=people.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(people[i]+people[j--]&lt;=limit)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/boats-to-save-people&quot;&gt;https:</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="贪心" scheme="https://yi-jiao-chan.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="双指针" scheme="https://yi-jiao-chan.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-452. 用最少数量的箭引爆气球</title>
    <link href="https://yi-jiao-chan.github.io/posts/80e00419.html"/>
    <id>https://yi-jiao-chan.github.io/posts/80e00419.html</id>
    <published>2022-02-14T07:50:00.000Z</published>
    <updated>2022-02-14T10:36:31.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为<code> xstart，xend</code>， 且满足 <code> xstart ≤ x ≤ xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组<code>points</code>，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br><span class="line"></span><br><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：points = [[1,2]]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：points = [[2,3],[2,3]]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：points = [[2,3],[1,3],[5,8],[6,10],[9,10]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>气球被击中的条件是<code>气球起始坐标≤击打坐标≤气球终止坐标</code>，要想一次性击打多个气球，则击打点应当是气球边界位置（起始坐标或终止坐标）。</p><ul><li>假如取起始坐标 <code>x</code> 为击打点，则<code>starX≤ x ≤ endX</code>的气球都可以被击破<ul><li>选<code>起始坐标</code>为击打点，则每次击打都应该选取<code>起始坐标</code>最大的气球，因此对<code>points</code>按<code>points[0]</code>进行降序排序。</li><li>排序之后开始遍历，<code>points[i][0]&gt;=points[i+1][0]</code>恒成立，因此<code>starX≤ x</code>必定满足，只需要判断<code>x ≤ endX</code>即可，如果成立，则重叠，可以一支箭射穿</li></ul></li><li>假如取终止坐标 <code>x</code> 为击打点，则<code>starX≤ x ≤ endX</code>的气球都可以被击破<ul><li>选<code>终止坐标</code>为击打点，则每次击打都应该选取<code>终止坐标</code>最大的气球，因此对<code>points</code>按<code>points[0</code>]进行升序排序。</li><li>排序之后开始遍历，<code>points[i][1]&lt;=points[i+1][1]</code>恒成立，因此<code>x ≤ endX</code>必定满足，只需要判断<code>starX≤ x</code>即可，如果成立，则重叠，可以一支箭射穿</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取终止坐标为击打点的解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 贪心</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">// 对气球进行排序，按终点坐标增序排序。</span></span><br><span class="line">        <span class="comment">//  如果终点坐标一样,则不用管（因为终点坐标一样，一枪肯定能全打爆，只要有一个气球不能和前面区间合并，都只会新增一支箭，不影响结果）</span></span><br><span class="line">        <span class="comment">//      例如：[5,8],[6,10],[9,10]  和  [5,8],[9,10],[6,10]   res都是2，区别是前者[[5,8,[6,10]] 和[9,10] 后者是[5,8],[[9,10],[6,10]]</span></span><br><span class="line">        Arrays.sort(points,(point1,point2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> point1[<span class="number">1</span>]&lt;point2[<span class="number">1</span>]?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 记录上一个区间的箭击打坐标</span></span><br><span class="line">        <span class="type">int</span> end=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 只要遍历到的气球起始坐标&lt;= 上一个区间的击打坐标，则可以合并一箭击打。否则要再射一箭，击打坐标为当前气球的终点坐标</span></span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]&gt;end)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                end=points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-number-of-arrows-to-</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
    <category term="贪心" scheme="https://yi-jiao-chan.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-1904. 你完成的完整对局数</title>
    <link href="https://yi-jiao-chan.github.io/posts/ac5912c2.html"/>
    <id>https://yi-jiao-chan.github.io/posts/ac5912c2.html</id>
    <published>2022-02-12T12:46:00.000Z</published>
    <updated>2022-02-12T14:33:56.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>微软2022春招实习后端笔试原题</p><p><a href="https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played">https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played</a></p><p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 <code>HH:00、HH:15、HH:30 和 HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00 到 23 </code>的整数表示。游戏中使用<code> 24 小时制</code>的时钟 ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p><p>给你两个字符串 <code>startTime</code> 和<code>finishTime</code>，均符合 “HH:MM” 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。</p><p>例如，如果 <code>startTime = &quot;05:20&quot;</code> 且 <code>finishTime = &quot;05:59&quot;</code> ，这意味着你仅仅完成从<code> 05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15 到 05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45 到 06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。<br>如果<code> finishTime 早于 startTime</code> ，这表示你玩了个通宵（<a href="https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played%EF%BC%89%E3%80%82">https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played）。</a></p><p>假设你是从 <code>startTime </code>进入游戏，并在<code>finishTime</code>退出游戏，请计算并返回你完成的 完整对局的对局数 。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：startTime = &quot;12:01&quot;, finishTime = &quot;12:44&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：你完成了从 12:15 到 12:30 的一个完整对局。</span><br><span class="line">你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。</span><br><span class="line">你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。</span><br><span class="line"></span><br><span class="line">输入：startTime = &quot;20:00&quot;, finishTime = &quot;06:00&quot;</span><br><span class="line">输出：40</span><br><span class="line">解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。</span><br><span class="line">16 + 24 = 40</span><br><span class="line"></span><br><span class="line">输入：startTime = &quot;00:00&quot;, finishTime = &quot;23:59&quot;</span><br><span class="line">输出：95</span><br><span class="line">解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>没什么好说的….纯纯的模拟，笔试的时候太粗心了对通宵情况只判断了hour没判断min…..第一次笔试交点学费吧！后面再加油！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfRounds</span><span class="params">(String loginTime, String logoutTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 分离hour和min</span></span><br><span class="line">        <span class="type">int</span> hourA=Integer.parseInt(loginTime.substring(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> minA=Integer.parseInt(loginTime.substring(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">        <span class="type">int</span> hourB=Integer.parseInt(logoutTime.substring(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> minB=Integer.parseInt(logoutTime.substring(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 退出时间比登录时间小，两种情况：hour小、hour相等min小。 要对退出时间的hour+24</span></span><br><span class="line">        <span class="keyword">if</span>(hourB&lt;hourA||(hourA==hourB&amp;&amp;minA&gt;minB)) hourB+=<span class="number">24</span>;</span><br><span class="line">        <span class="comment">// 向上取整登录时间</span></span><br><span class="line">        <span class="keyword">if</span>(minA%<span class="number">15</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            minA=(minA/<span class="number">15</span>+<span class="number">1</span>)*<span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下取整退出时间</span></span><br><span class="line">        <span class="keyword">if</span>(minB%<span class="number">15</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            minB=(minB/<span class="number">15</span>)*<span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hour不相同，则分别计算登录和退出两个hour中可以玩的次数，再用中间的hour数*4</span></span><br><span class="line">        <span class="keyword">if</span>(hourB!=hourA)&#123;</span><br><span class="line">            res=(<span class="number">60</span>-minA)/<span class="number">15</span>;</span><br><span class="line">            res+=minB/<span class="number">15</span>;</span><br><span class="line">            res+=(hourB-hourA-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res=(minB-minA)/<span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&gt;=<span class="number">0</span>?res:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;微软2022春招实习后端笔试原题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/the-</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="medium" scheme="https://yi-jiao-chan.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-124(变式). 二叉树中的最大路径和</title>
    <link href="https://yi-jiao-chan.github.io/posts/f3bed3dc.html"/>
    <id>https://yi-jiao-chan.github.io/posts/f3bed3dc.html</id>
    <published>2022-02-12T12:14:00.000Z</published>
    <updated>2022-02-15T13:20:39.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>微软2022春招实习后端笔试题，是leetcode中二叉树最大路径和的变式。</p><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum</a></p><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>本题中树为<strong>多叉树</strong>，树的<strong>节点内容只有’a’和’b’<strong>两种，请设计一个函数，返回</strong>相邻节点内容不同的最长序列长度</strong>。</p><p>即：求得是abababab这样的最长路径。</p><p><strong>输入：</strong>（String S，int[] A）</p><p><code>S</code>由<code>&#39;a&#39;和&#39;b&#39;</code>组成，<code>S[i]</code>代表是序号为<code>i</code>的节点值</p><p><code>A[i]</code>记录的是序号为<code>i</code>的节点的双亲结点序号，例如<code>A[3]=2</code>表示序号为3的节点，其双亲节点的下标为2，<code>A[0]=-1</code>,因为0是根节点</p><p>​    <strong>注意</strong>：除了序号0为根节点以外，其他节点序号与节点出现顺序无关</p><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215210030400.png" alt="image-20220215210030400"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：S=&quot;ababa&quot;  A=[-1,0,3,0,0]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215210134740.png" alt="image-20220215210134740"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：S=&quot;abbab&quot;  A=[-1,0,0,0,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aged_lemon/typora-image/raw/master/image/image-20220215210258154.png" alt="image-20220215210258154"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：S=&quot;aabb&quot;  A=[-1,2,0,1]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><strong>此题解正确性有待探究</strong>，如有大佬发现错误劳烦在评论区留言！非常感谢！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// 记录结果</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solution</span><span class="params">(String S, <span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="comment">// write your code in Java SE 8</span></span><br><span class="line">        <span class="type">char</span> [] chars=S.toCharArray();</span><br><span class="line">        <span class="comment">// 构建数组记录每一个节点的子节点序号</span></span><br><span class="line">        List&lt;Integer&gt;[] sons=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[chars.length];</span><br><span class="line">        <span class="comment">// 初始化子节点数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sons[A[i]]==<span class="literal">null</span>) sons[A[i]]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            sons[A[i]].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从根节点开始dfs</span></span><br><span class="line">        dfs(chars,<span class="number">0</span>,sons);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chars 记录每个节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前dfs的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sons 记录每个节点的子节点序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回以当前节点为起点，其满足条件的最长序列长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[]chars,<span class="type">int</span> index,List&lt;Integer&gt;[] sons)</span>&#123;</span><br><span class="line">        <span class="comment">// 越界判断</span></span><br><span class="line">        <span class="keyword">if</span>(index&gt;=chars.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分别记录子节点为a、b时的最大长度和第二大长度</span></span><br><span class="line">        <span class="type">int</span> maxA=<span class="number">0</span>,maxB=<span class="number">0</span>,secondA=<span class="number">0</span>,secondB=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 有子节点才遍历</span></span><br><span class="line">        <span class="keyword">if</span>(sons[index]!=<span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 遍历子节点List</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> sonIndex:sons[index])&#123;</span><br><span class="line">                <span class="comment">// 获取以子节点为起点，满足要求的最长序列长度</span></span><br><span class="line">                temp=dfs(chars,sonIndex,sons);</span><br><span class="line">                <span class="comment">// 子节点是a则尝试更新maxA和secondA，否则尝试更新B</span></span><br><span class="line">                <span class="keyword">if</span>(sonIndex&lt;chars.length&amp;&amp;chars[sonIndex]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(maxA&lt;temp)&#123;</span><br><span class="line">                        secondA=maxA;</span><br><span class="line">                        maxA=temp;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(secondA&lt;temp)&#123;</span><br><span class="line">                        secondA=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sonIndex&lt;chars.length&amp;&amp;chars[sonIndex]==<span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(maxB&lt;temp)&#123;</span><br><span class="line">                        secondB=maxB;</span><br><span class="line">                        maxB=temp;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(secondB&lt;temp)&#123;</span><br><span class="line">                        secondB=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 最长长度可能不包含当前节点</span></span><br><span class="line">        res=Math.max(res,Math.max(maxA,maxB));</span><br><span class="line">        <span class="keyword">if</span>(chars[index]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 当前节点为a，则其最多可以连接两个B节点，最长长度可能是maxB+secondB+1</span></span><br><span class="line">            res=Math.max(res,maxB+secondB+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> maxB+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res=Math.max(res,maxA+secondA+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> maxA+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;微软2022春招实习后端笔试题，是leetcode中二叉树最大路径和的变式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcod</summary>
      
    
    
    
    <category term="leetcode" scheme="https://yi-jiao-chan.github.io/categories/leetcode/"/>
    
    
    <category term="hard" scheme="https://yi-jiao-chan.github.io/tags/hard/"/>
    
    <category term="树" scheme="https://yi-jiao-chan.github.io/tags/%E6%A0%91/"/>
    
    <category term="面试题" scheme="https://yi-jiao-chan.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
